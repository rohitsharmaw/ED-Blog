{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-stellar/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/copycode.js","path":"js/plugins/copycode.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/download-file.js","path":"js/plugins/download-file.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/video.js","path":"js/plugins/video.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/voice.js","path":"js/plugins/voice.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/artalk_latest_comment.js","path":"js/services/artalk_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/contributors.js","path":"js/services/contributors.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/fcircle.js","path":"js/services/fcircle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends.js","path":"js/services/friends.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends_and_posts.js","path":"js/services/friends_and_posts.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/ghinfo.js","path":"js/services/ghinfo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/giscus_latest_comment.js","path":"js/services/giscus_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/mdrender.js","path":"js/services/mdrender.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/memos.js","path":"js/services/memos.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/rating.js","path":"js/services/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/siteinfo.js","path":"js/services/siteinfo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/sites.js","path":"js/services/sites.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/timeline.js","path":"js/services/timeline.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/twikoo_latest_comment.js","path":"js/services/twikoo_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/vote.js","path":"js/services/vote.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/waline_latest_comment.js","path":"js/services/waline_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/weibo.js","path":"js/services/weibo.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/备战CSP-J.md","hash":"d537977b96d7ed106830a100f817b810c7fd8050","modified":1756096884453},{"_id":"source/_posts/快读快写模板.md","hash":"216970915ffbc302c01e52534f659fb05fac67f4","modified":1756096884453},{"_id":"source/_posts/搜索题目整理.md","hash":"1cac9a1bf4e9daa44b126f48742a085b9d4c4f71","modified":1756096884453},{"_id":"source/_posts/最小生成树.md","hash":"149216a4913e063055f9f1df39e59a68a6f392eb","modified":1756096884453},{"_id":"source/_posts/最短路.md","hash":"f819f468da03f293eec0413145ad962a792b4e07","modified":1756096884453},{"_id":"source/_posts/链式前向星.md","hash":"8bda0c60d4598a4e3d354d89e8f23877dca12401","modified":1756096884453},{"_id":"source/friends/index.md","hash":"e874662da2f53235311555585fbba162e86bad5d","modified":1753789460064},{"_id":"source/about/index.md","hash":"20c618634dafe5aa259156fa66322b608941f73f","modified":1756096884453},{"_id":"source/_data/links/qpoem.yml","hash":"f3a536d87ec08291abbb4aff30174691861fb52e","modified":1756096884453},{"_id":"source/_data/notebooks/scsn.yml","hash":"6dfa3bf7b26004e6f7889b18b1c7c6e2a130c4ff","modified":1756096884453},{"_id":"source/notebooks/scsn/index.md","hash":"ff93ced9a3d9016287442f185f515732cd418378","modified":1756096884453},{"_id":"source/notebooks/scsn/单调栈和单调队列.md","hash":"65465160a52ed9f6ac2a0fac69d898e15067e42b","modified":1756096884453},{"_id":"source/notebooks/scsn/线段树和树状数组.md","hash":"bd5cec98f1fa7d5c7060099a5e6dc4154137212b","modified":1756096884454},{"_id":"node_modules/hexo-theme-stellar/_data/chat_users.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1755045395959},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/tree.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1755045397818},{"_id":"node_modules/hexo-theme-stellar/LICENSE","hash":"7fdfdb5dbc7d672fa28a2a3c9efa03ff8df5917d","modified":1755045395569},{"_id":"node_modules/hexo-theme-stellar/README.md","hash":"2af9a521d78c96c4aeb6069adcb52b138536b800","modified":1755045395647},{"_id":"node_modules/hexo-theme-stellar/package.json","hash":"04c43bb3fb975acdbdf6e0f5145ed54e4e7b866a","modified":1755045395864},{"_id":"node_modules/hexo-theme-stellar/_config.yml","hash":"9f8e9ff8a8c2bff829a1ae8a18288b876db543c5","modified":1755045395758},{"_id":"node_modules/hexo-theme-stellar/languages/en.yml","hash":"42c8040336776386f974ca127f0aa1b213bb8f1a","modified":1755045396173},{"_id":"node_modules/hexo-theme-stellar/_data/widgets.yml","hash":"f86a03e31758e096050ecf5b82e687fddb174073","modified":1755045396070},{"_id":"node_modules/hexo-theme-stellar/_data/icons.yml","hash":"3b9ed4cec71810dfa8ec661af1811327c88bda52","modified":1755045396030},{"_id":"node_modules/hexo-theme-stellar/layout/404.ejs","hash":"d84f01256feb3c0bc0b280031fb78ae9f0d86f26","modified":1755045396251},{"_id":"node_modules/hexo-theme-stellar/languages/zh-TW.yml","hash":"b136f321fbbab62c0c5669ee8051473db11d4d86","modified":1755045396219},{"_id":"node_modules/hexo-theme-stellar/languages/zh-CN.yml","hash":"67c6742bd95c6669fe91e33ddc5950d2cf35923c","modified":1755045396199},{"_id":"node_modules/hexo-theme-stellar/layout/categories.ejs","hash":"50e24a6dd300ebb787ef3ad9d746eb7f71590772","modified":1755045396306},{"_id":"node_modules/hexo-theme-stellar/layout/archive.ejs","hash":"239657e053d7a66851f3205bed74d99d892dc5a8","modified":1755045396291},{"_id":"node_modules/hexo-theme-stellar/layout/index.ejs","hash":"56c641005125a0abf1227a9ba339a7dd5aac960e","modified":1755045396329},{"_id":"node_modules/hexo-theme-stellar/layout/index_topic.ejs","hash":"85ac8aed79bf2e939f3def0137d1c5724d33a6e6","modified":1755045396360},{"_id":"node_modules/hexo-theme-stellar/layout/index_wiki.ejs","hash":"d35222b0f070f31d80bb1ca90354bdc60bd62692","modified":1755045396372},{"_id":"node_modules/hexo-theme-stellar/layout/notebooks.ejs","hash":"d11ab953e00bd4191459451f63601582ab53f38f","modified":1755045396398},{"_id":"node_modules/hexo-theme-stellar/layout/notes.ejs","hash":"492e8d83b5233d510d094c66e66949a6a88dacf5","modified":1755045396408},{"_id":"node_modules/hexo-theme-stellar/layout/tags.ejs","hash":"66477707f525a1ee4131c11d79defd18da641599","modified":1755045396440},{"_id":"node_modules/hexo-theme-stellar/layout/layout.ejs","hash":"4292198534807d1303aef5fc224f46d584fe2e25","modified":1755045396383},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/head.ejs","hash":"dedbd6a5507fc3cf8cf23f5a4cd1f4f3abe07bb5","modified":1755045396454},{"_id":"node_modules/hexo-theme-stellar/layout/page.ejs","hash":"b8070e812b4468b4a7df22d5b5e8e848afdab251","modified":1755045396424},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts.ejs","hash":"125084ef723813968aac71bfe841aad5c4b6460e","modified":1755045396472},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/copycode.ejs","hash":"7cedd8eced00f6813f7d772334ec92acbc8bd982","modified":1755045396499},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/menubtn.ejs","hash":"0f080d7aefc9c7e208daddf2981b81d36783e034","modified":1755045396463},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/fancybox.ejs","hash":"2f6b7c118fcb54a1cae0bdaa55a1e8a09cf3e013","modified":1755045396520},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/index.ejs","hash":"29407e95f14d4d50c1f8a8b9a5af242927676432","modified":1755045396560},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/heti.ejs","hash":"c3956c8fd5fabd4ec8cea05dc076bf7a03eb012a","modified":1755045396545},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/mermaid.ejs","hash":"5ad208b430071ed4ee84af4ae69356219ec586f0","modified":1755045396589},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/mathjax.ejs","hash":"ddcb15575bf2897c57b92c9b23ffb0b3878e5ec4","modified":1755045396574},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/preload.ejs","hash":"f25523da5633b249da8cebe7c866265bf7825697","modified":1755045396600},{"_id":"node_modules/hexo-theme-stellar/scripts/.cache/stellar-version.json","hash":"d1dd2193e3a46e820dec1fdc980ece47c1ea6282","modified":1756096902508},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/scrollreveal.ejs","hash":"f763156bcd1ed4611e4541069d9d928d3df37fe9","modified":1755045396611},{"_id":"node_modules/hexo-theme-stellar/scripts/events/index.js","hash":"0ce4b1068fe46e3c2cb0da1b3b8b4357d64f7250","modified":1755045396641},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/swiper.ejs","hash":"b80d6185c0263375df82498705a98ad32238b12f","modified":1755045396622},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/tianli_gpt.ejs","hash":"c63f65df336bd10b2c5f068830c3086f3f13f3a3","modified":1755045396629},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/index.js","hash":"1fca6cadef00b661f1ef4fc27c2dffc5d97bebdd","modified":1755045396665},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/404.js","hash":"66b53d2b35b18d5f3835b47467c23f31eb322553","modified":1755045396699},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/pretty_urls.js","hash":"b3fd456a0ce1388886306afe99ec1e7342998ee3","modified":1755045396680},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/author.js","hash":"0de0824fdbc4f67c84910267901095504b253751","modified":1755045396710},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/categories.js","hash":"936d4d406fd401359bab1e5f74c6e1e097e8f092","modified":1755045396728},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/notebooks.js","hash":"87ede05eb8ea9c02f53177c83a2258dc163f28dc","modified":1755045396763},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/tags.js","hash":"ed29755154d8e7a9346019ba4ac8782a8649b177","modified":1755045396797},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/search.js","hash":"8a59c0923c2a4a11c09ce87fccf98c090c73a0e4","modified":1755045396777},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/wiki.js","hash":"61efe22787c3fea9d935df4b088a9dd2d1af0868","modified":1755045396828},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/topic.js","hash":"88c0f2990365fb0ce751682815e07f36cf333d3f","modified":1755045396810},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/category_color.js","hash":"20b19d6b6307cdeb0b0832bf4931366abe972490","modified":1755045396846},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/dynamic_color.js","hash":"507acbb7445ec172e10ab03c8917a4d8132e264a","modified":1755045396856},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/icon.js","hash":"b7c84be7f08abc1725f351ed8718791a861466c3","modified":1755045396873},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/parse_config.js","hash":"1251d82318972f22283dc7a089b77a3f0135b1b6","modified":1755045396904},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/json_ld.js","hash":"16a52b6c7fb7899c4f7b04bf4e87194d71d25f06","modified":1755045396891},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/pretty_url.js","hash":"f2d94135de1d44460e65ed2167271c2068b18597","modified":1755045396911},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/related_posts.js","hash":"6763a97fa25669fa1d1aa8e5291919deb5dc7f67","modified":1755045396934},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/scrollreveal.js","hash":"57e3da4a3dd751b3ebd384a674e26f08f69da018","modified":1755045396946},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/utils.js","hash":"05c127baa250b192c9c673355bf90d7134e1ea11","modified":1755045396979},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/stellar_info.js","hash":"5b7a10c8b09237a467767f5467749c7d9378c2c1","modified":1755045396964},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/index.js","hash":"ee19ee68f94844ea7bd91dbd914938a46da3ee99","modified":1755045396994},{"_id":"node_modules/hexo-theme-stellar/source/css/_custom.styl","hash":"4a3aa7213e89a72a30b35b08d5e6b79a90a898ed","modified":1755045397021},{"_id":"node_modules/hexo-theme-stellar/source/css/main.styl","hash":"7244b3269d777a3a67446c0e20c53bc60b577304","modified":1755045397026},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/inline-labels.js","hash":"307a7331ab39521f4af0d6bdbc2ba3a114942017","modified":1755045397003},{"_id":"node_modules/hexo-theme-stellar/source/js/main.js","hash":"e702e941a62bf081e9209fdc20d0f5873e9eb902","modified":1755045397034},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/index.ejs","hash":"4b317700640749b1e04e6d51a542a2bcd28c8b72","modified":1755045397059},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/script.ejs","hash":"62be59ef634ceee342c81ecc4e23cb664cdbf620","modified":1755045397046},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/layout.ejs","hash":"a38e9684721afe2015570b978654f5805e173ae0","modified":1755045397041},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/footer.ejs","hash":"39e822090c2f9dbe1f1ebc4ed108b16bb0e7da9e","modified":1755045397089},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/wiki_cover.ejs","hash":"8c2b00fed4124fb9571944d87177dba4d925780d","modified":1755045397079},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/defines.ejs","hash":"f6db1704f9b89992b802c01af332289c4af718d1","modified":1755045397096},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/post_cover.ejs","hash":"56ed19f8150e2e3f3070a79ba7c4b63f903d9df2","modified":1755045397067},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/sidebar.ejs","hash":"403b6986bfc54177a7ee3ddba9e0a55e7b79e3a1","modified":1755045397108},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/lazyload.ejs","hash":"d88f31ea258c52e80e9134b56ab58e65830f805e","modified":1755045397101},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/services.ejs","hash":"9dec23072ebbdf96d164bc698a11f3a09ea26d1a","modified":1755045397104},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/theme.ejs","hash":"ad8194beff5faa3495ad72799cc81399b7d84871","modified":1755045397117},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/index_leftbar.ejs","hash":"c005a146d8f733e83af8f1652bbd71d75b13b807","modified":1755045397129},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/utils.ejs","hash":"d07baba303b5e03d4ee4a33d404524da3e3499cf","modified":1755045397124},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/index_rightbar.ejs","hash":"a16ecd6d9421c30ffe2ca1a44cc9597309b5b70c","modified":1755045397136},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/tagtree.ejs","hash":"c16031694fee3e0c305139136126dee88e1e88cf","modified":1755045397111},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/menu.ejs","hash":"84ee2d7fe8eededb5103e5fab0b7359cb01d6408","modified":1755045397144},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/author.ejs","hash":"b77e88418227d4691e2ad8a4996727753f31b1f5","modified":1755045397154},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/logo.ejs","hash":"9bbac48b3d18b3e686dacc624e12758c0c96f6e3","modified":1755045397141},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/search.ejs","hash":"770056e023a00b22d2853c4fa65bb48035ade3b2","modified":1755045397149},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghissues.ejs","hash":"e65ed1f0fffb6fef595eb775d34742798bb2493e","modified":1755045397158},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/linklist.ejs","hash":"813336cbbe4505e9be42d5682fd7b720dba25194","modified":1755045397173},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghrepo.ejs","hash":"8586ff53e3fe7361880f77c2cc1782335770c089","modified":1755045397161},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/markdown.ejs","hash":"16c0553fb56422ce343e5c9ddcfda5d989c97579","modified":1755045397175},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/recent.ejs","hash":"425419a7b67082366ed391392d9ac861f6cba851","modified":1755045397179},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghuser.ejs","hash":"b9ba4cca16293986e5980027fdd2da78dae95b6b","modified":1755045397167},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tagcloud.ejs","hash":"d95c26f84c7d9061ba3ef6188d58fa14f1c63bf3","modified":1755045397187},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/related.ejs","hash":"abef14819f5c513e8834ea92a625a87cb9dfcf57","modified":1755045397184},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tagtree.ejs","hash":"f7f7705da3313a90f6c3312880986a275d93d570","modified":1755045397190},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/toc.ejs","hash":"bdfd167a73304ab76903011a26be456839bd5816","modified":1755045397196},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/timeline.ejs","hash":"54f105f537c5c6cd1b84e4f5e586d4cca15c3c2a","modified":1755045397193},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/search/algolia_search.ejs","hash":"1d720e4b0308a0818f45a9a4b63df1e9f6521737","modified":1755045397203},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tree.ejs","hash":"395b2e4cc644f2e62824b4f5493baa8208e82839","modified":1755045397199},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/search/local_search.ejs","hash":"38a3641bb532583b699fda42175cb14242f07575","modified":1755045397205},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/config.js","hash":"731a596b124fd37671fb69fecf45c94f35bcece5","modified":1755045397223},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/authors.js","hash":"eedefb5430fc4176bdc2814c8a88295f0e524d10","modified":1755045397213},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/doc_tree.js","hash":"f7d6b86a442afabf885566adfc02d42dc5eaf46e","modified":1755045397231},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/fix_image_tags.js","hash":"bf23791be2fdd6e12bac5745aa002888cae9bc4e","modified":1755045397234},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/get_image_ratios.js","hash":"0fc3d7e6083a2b0482504a86206fcdd723027075","modified":1755045397237},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/links.js","hash":"881cac75e4071d219a18156738e18eb397d83c00","modified":1755045397240},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/merge_posts.js","hash":"4e45b8dc5317f7d66bc14879ae6b5f972123ce5d","modified":1755045397245},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/notebooks.js","hash":"ad5eae17a77a92100c748fd668c73e1b09f7a21f","modified":1755045397251},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/lib/img_lazyload.js","hash":"b3dedcc1fc4189589e63d4fa6f169a70e9d63cd1","modified":1755045397266},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/topic_tree.js","hash":"7f735f2573c87d202e2d4b845307d0725d619e8e","modified":1755045397254},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/utils.js","hash":"271ba6c8cc997e4f55b2e146a99bde8301818400","modified":1755045397257},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/version-check.js","hash":"16a9602caaa37ac5bb047bb3fa4649b61e2fb3e3","modified":1755045397260},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/lib/img_onerror.js","hash":"d44a8e20d4d537c0cf85b980e1fc3bc84865a2d3","modified":1755045397269},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/about.js","hash":"c9778c35c1ccd9f2018174bafbd37b23dd52cf62","modified":1755045397272},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/albums.js","hash":"9f95c5053a59ad05df8c8add8975df24b86266e1","modified":1755045397277},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/audio.js","hash":"9b094b16dce131a5c09373661c88a1de9b5326f7","modified":1755045397279},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/banner.js","hash":"8c7fb7f0abe55868dea09eaa0b4ae7d52cbe6b08","modified":1755045397284},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/blockquote.js","hash":"3db333c573f94346b1b0192c57e4609966f9a43f","modified":1755045397286},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/box.js","hash":"66bed2e303468a8fd9c664ce3e697ceb4e3eb931","modified":1755045397289},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/button.js","hash":"e0890a759335b1c5ad09db084bcf62073b2557cb","modified":1755045397292},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/checkbox.js","hash":"69caf7488b6c92cb2524df81ece6f33a46a89fe0","modified":1755045397301},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/copy.js","hash":"d22a82b6fd9c96c7ac49677b427e6c629fa889d7","modified":1755045397306},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/emoji.js","hash":"e10f68f69206fc6e9d0c478630be2b4514d328d7","modified":1755045397311},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/folders.js","hash":"4ca5470285541033b8272ba7cc3bd5860504169e","modified":1755045397314},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/folding.js","hash":"9f51610fc62067a16a9c27884864f69e4200843c","modified":1755045397319},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/frame.js","hash":"1251a8622260af8efc55c2f0aac8ee5cf79d9043","modified":1755045397321},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/friends.js","hash":"89c23e27bd483ed1a842f205460f6c46e1cc2b2b","modified":1755045397323},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/gallery.js","hash":"b069a958377ed370e138a633280115103c89c731","modified":1755045397326},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/ghcard.js","hash":"87afee954b97b6f945cc4b7f50b012fca3e68f11","modified":1755045397328},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/grid.js","hash":"dad59b638c2fd30538e3a69bf0c8d76d34cf3ece","modified":1755045397330},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/icon.js","hash":"273898ae29a07c1baccb432efa0d33ccfabe7db9","modified":1755045397341},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/hashtag.js","hash":"f38ce98fff40ed35be9b1f1be3194bc4c5d44dc3","modified":1755045397335},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/image.js","hash":"b0f913a08f0b6df4271498c6a9e17d74e22b7897","modified":1755045397344},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/link.js","hash":"5b5d41a0bbe1af30487c178c69a7373f598f16b6","modified":1755045397346},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/md.js","hash":"cbc81d08056fcf071b480c806e358bf46c61060d","modified":1755045397353},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/mark.js","hash":"cfd8198f349dba60fbdf53042b6ebd9a0ba521c7","modified":1755045397347},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/navbar.js","hash":"b517b0a5758f7971868f4ca4b4472770ab205280","modified":1755045397355},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/note.js","hash":"a70d1fcb440ad029ddddb72b053a59b1ed3bfef8","modified":1755045397358},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/okr.js","hash":"6a11a364081ecb3fc5e36408fd57da91f6aa2297","modified":1755045397360},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/poetry.js","hash":"c36321caeec845ed131bdd0922bff25eb59f086a","modified":1755045397365},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/posters.js","hash":"4d9a6d4f392cd757513e94020e82e6e788962239","modified":1755045397368},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/quot.js","hash":"c262e4bd70a2c6501909a2ef51c13e64a445637d","modified":1755045397371},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/rating.js","hash":"0cba03c1b3931633cffc7a41a1554c025fb8d31c","modified":1755045397374},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/sites.js","hash":"62147a1d195a07d7c57fa5cfee6d2365bf4423ca","modified":1755045397376},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/swiper.js","hash":"dc025c79b190d233383fec001ddbe478f2675cc8","modified":1755045397380},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/tabs.js","hash":"1b3d7b6b962293b44430e7b40560b8d1fa5c618d","modified":1755045397384},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/timeline.js","hash":"2646355804c1c442a2ac19d6a5a67e01e36d19f2","modified":1755045397389},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/toc.js","hash":"d7b51b66d7b83a77e501930e735092a9967d5d18","modified":1755045397392},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/vote.js","hash":"d7fd783e9c22e6083d8042df89913c5991c9ef8c","modified":1755045397397},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/video.js","hash":"75c750467540777349a396a068517173fdac31b5","modified":1755045397395},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/blockquote.styl","hash":"64be440550197ab5cbed921428a8e63846bb351c","modified":1755045397406},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/blur.styl","hash":"81685461475c4c98b7850490ddf54116a469306a","modified":1755045397408},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/button.styl","hash":"6794cf6af2538d56537b7ece30132c6918a9a78f","modified":1755045397409},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/base.styl","hash":"ae0332e4cf880e833648a4b30b21fbab2b0be69b","modified":1755045397404},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/cap.styl","hash":"1b10f72a936ad9695196116626dd741a0b797918","modified":1755045397414},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/control.styl","hash":"75081ca9d522a76ec4acffb8111c918b2297650a","modified":1755045397417},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/canonical.styl","hash":"4d6087993858fa21415a1453310905a27e5ef099","modified":1755045397412},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/html.styl","hash":"fae4375fc45121ffc3a43872ddc3331d6d49700d","modified":1755045397422},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/device.styl","hash":"59a6b9ac262a87fcb57e50e69d0d6518a7cf0bf8","modified":1755045397419},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/image.styl","hash":"cca1103a9185202b13be49e16d77d259e9ffb482","modified":1755045397425},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/highlight.styl","hash":"086db146f4c108826ed41aa068805a673379fc63","modified":1755045397422},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/layout.styl","hash":"c7d0d3c70087e14bd1f6d8d50d56762d8c5ad44d","modified":1755045397428},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/input.styl","hash":"953fc87072cd760d92dfef55310addbb17bb2b51","modified":1755045397427},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/loading.styl","hash":"5daad36cbb1d05e7b579e0c775ea52fd777c80e0","modified":1755045397430},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/media.styl","hash":"fa7dbcaa31089fe547acb01a767af97fb019bba6","modified":1755045397436},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/pre.styl","hash":"68b2c99a811dc03a4aa1c4ce35003f65404306e8","modified":1755045397438},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/span.styl","hash":"86462ffaf1603b5d5ab6534c0f7fe0eb495aad2d","modified":1755045397440},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/svg.styl","hash":"bb4d1a4676eb5229685ba21c7c69acbf4482bf55","modified":1755045397441},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/toast.styl","hash":"f2930874174763da2338fa95087c345bf5c41800","modified":1755045397450},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/index.styl","hash":"7a7ab293e065116646102546c6bab01166836059","modified":1755045397455},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/title.styl","hash":"12323840adcc748d5c854536ae38db26f7bd3687","modified":1755045397445},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/layout.styl","hash":"4be8936e7f2f593ecc14668bdf2ea6c7e44aa53c","modified":1755045397458},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/list.styl","hash":"8872ff6cab827775d47e7017c9e9c028c732eb0e","modified":1755045397460},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/main.styl","hash":"66bf332a79067e871e20ae29722175e0bb1c4f98","modified":1755045397467},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/md.styl","hash":"150aa0d6654b3d2775499304c0cec8ac6112d845","modified":1755045397475},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/const.styl","hash":"223292db0208f8ed8127d54d42501d2a29d24dc1","modified":1755045397511},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/theme_colorful.styl","hash":"1c602b7e690e6fb08acb8e9eae30ce7540625de4","modified":1755045397521},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/func.styl","hash":"d19aaeb33d5f249b064bb338b50ee746b5a2e2ec","modified":1755045397514},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/aplayer.styl","hash":"00b6e9209638eef9f70e75a24a5a90b05f7b5347","modified":1755045397535},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/theme_base.styl","hash":"08a6592c43e19b7fb073825bc9dd3d73b8cc1e77","modified":1755045397517},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/fancybox.styl","hash":"f4a709dcac4e21ca0fbeca552a8dde2ac2bf8d97","modified":1755045397542},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/copycode.styl","hash":"a9f27136143eb779d1aeb903e863c94a98b82aac","modified":1755045397538},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/katex.styl","hash":"f58016799f7a534d453625fab4cd66a13063e4b8","modified":1755045397546},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/index.styl","hash":"c5ce6de9724f74a81c3b0567639385a2b5dcc549","modified":1755045397544},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/lazyload.styl","hash":"d4c9e49fb99ac4dccaa92c11bb3503552bc96598","modified":1755045397549},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/mermaid.styl","hash":"1a2643ba6375b0d3b5d56437604dcb94cd666977","modified":1755045397553},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/scrollreveal.styl","hash":"21b9125c1bae3e5348547e85500ceb992de21923","modified":1755045397556},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/swiper.styl","hash":"759fdb34f0b2019f0a5d210225748e3a18c00603","modified":1755045397558},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/tianli_gpt.styl","hash":"1f2efe2e13866e25d5a1d7471aeb2314682a9f85","modified":1755045397560},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1755045397564},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/download-file.js","hash":"6bd0cc2f31164406013313543cb04f9ab3cd2452","modified":1755045397570},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/video.js","hash":"e87d271175dfb4763c9c017046f7d857c7a3ba56","modified":1755045397572},{"_id":"node_modules/hexo-theme-stellar/source/js/search/algolia-search.js","hash":"94dae768b275b12753553553b3338fca4973a1e3","modified":1755045397579},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/voice.js","hash":"4c865125754c98dd61de28ad88c831be3d673a35","modified":1755045397575},{"_id":"node_modules/hexo-theme-stellar/source/js/search/local-search.js","hash":"d54e8d53e22875faa0e360fc7827f6f9dd068276","modified":1755045397582},{"_id":"node_modules/hexo-theme-stellar/source/js/services/fcircle.js","hash":"a684b276713a1c6f07817de9b70744c1a5c745ea","modified":1755045397590},{"_id":"node_modules/hexo-theme-stellar/source/js/services/contributors.js","hash":"be5c8ae1055696a0da9c5552fce20c120b2eb584","modified":1755045397587},{"_id":"node_modules/hexo-theme-stellar/source/js/services/artalk_latest_comment.js","hash":"31acb9a3587aa3012569969675c17645b7722f1f","modified":1755045397584},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends_and_posts.js","hash":"0ce8b46873e21e778b315e6c190387cdd1e1e107","modified":1755045397594},{"_id":"node_modules/hexo-theme-stellar/source/js/services/ghinfo.js","hash":"693acbabc79426bf276dd3072f40b2d9a98ee026","modified":1755045397596},{"_id":"node_modules/hexo-theme-stellar/source/js/services/giscus_latest_comment.js","hash":"b1f0f1a5941a4fdd20fc53444fd4fa6e58b0088e","modified":1755045397598},{"_id":"node_modules/hexo-theme-stellar/source/js/services/mdrender.js","hash":"cf90dd3f4aa37b1131fb871ec1a78eff96f2a861","modified":1755045397601},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends.js","hash":"6b30960a86ce11998c1861cfe3b7a9ecdc28259f","modified":1755045397591},{"_id":"node_modules/hexo-theme-stellar/source/js/services/memos.js","hash":"9ecffb14c952d903b21bf2184179868837f74ffa","modified":1755045397604},{"_id":"node_modules/hexo-theme-stellar/source/js/services/rating.js","hash":"19e8db4f26af6e656074bebda53d9a00216a0d31","modified":1755045397605},{"_id":"node_modules/hexo-theme-stellar/source/js/services/sites.js","hash":"f05d40a3476c796ed9e142ec2d1de15a8d1aef92","modified":1755045397610},{"_id":"node_modules/hexo-theme-stellar/source/js/services/siteinfo.js","hash":"e484765fdcabdbbeabf2062baf6ccb94d7ba777f","modified":1755045397607},{"_id":"node_modules/hexo-theme-stellar/source/js/services/timeline.js","hash":"43e225ee469d10efe22cae965483a0dabd13388c","modified":1755045397611},{"_id":"node_modules/hexo-theme-stellar/source/js/services/twikoo_latest_comment.js","hash":"4e9a18f32faa168b5fd1465d91df67ae3cdde6bf","modified":1755045397614},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/artalk/layout.ejs","hash":"43ca5e6a263f1e06fe75f4ca11ca7d955311ea72","modified":1755045397627},{"_id":"node_modules/hexo-theme-stellar/source/js/services/vote.js","hash":"0fdef6519fa2528f2ffd3b38272955d8469a8b2e","modified":1755045397617},{"_id":"node_modules/hexo-theme-stellar/source/js/services/waline_latest_comment.js","hash":"25ed1f668161941869e5effd4fbb408846c6deae","modified":1755045397620},{"_id":"node_modules/hexo-theme-stellar/source/js/services/weibo.js","hash":"144200d261c85b4f353243afc1f50003bdf23a93","modified":1755045397625},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/beaudar/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1755045397631},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/artalk/script.ejs","hash":"3ee0e3b898c1fa5e5cf3843fab0baafb7fd0e95b","modified":1755045397629},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/beaudar/script.ejs","hash":"69a2582d4e9e3203368196f4806adab2274e41fb","modified":1755045397634},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/giscus/layout.ejs","hash":"144e313ab45889c715ea1cfff3976b1f1322469e","modified":1755045397637},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/giscus/script.ejs","hash":"49fd68b7752d0ca06d80a52bf800cf03845909e0","modified":1755045397638},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/twikoo/script.ejs","hash":"3c93fe825769cd70027281c28980021b3ff8c4b0","modified":1755045397641},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/twikoo/layout.ejs","hash":"a3d429f4eafc582f739dd48865b39afd7c22ed56","modified":1755045397640},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/utterances/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1755045397644},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/utterances/script.ejs","hash":"0c54bbd610c1b31d7f45b9b4ded65690b673482c","modified":1755045397645},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/waline/layout.ejs","hash":"2abe764ffeab5603645b0e5148a17e9373de5eb4","modified":1755045397648},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/article_footer.ejs","hash":"d1bb42114db160e9f0d5ae078429db4c58bf7295","modified":1755045397656},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/contributors.ejs","hash":"c311ed2591b8b6155734df7dd50e14a603dbbf4a","modified":1755045397658},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/related_posts.ejs","hash":"ef485a4dc2db40bd68b35128f2140520db859b45","modified":1755045397660},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/waline/script.ejs","hash":"ef4b59476f4edf03cb25bdffe449b5da161d1d8e","modified":1755045397651},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/read_next.ejs","hash":"ce4f88f182022e1642345ddc09f98d4982ad7fd5","modified":1755045397659},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/article_banner.ejs","hash":"80dd9ebe6c7dbfb8c2bc6e8199320f339e6264e1","modified":1755045397663},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/dateinfo.ejs","hash":"d6e317db0030ace1f9cbab283ae7c40183859996","modified":1755045397664},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/ghinfo.ejs","hash":"336cad7d997ba31000ee1f08cd6cff84978a589a","modified":1755045397668},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/nav_tabs_blog.ejs","hash":"a377fe5c3fde1fc215428cd41f82a8a7f7aa4a59","modified":1755045397670},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/paginator.ejs","hash":"1a4b3bc64325ec7d5932ea78c36f2ec4978c09eb","modified":1755045397686},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/nav_tabs_wiki.ejs","hash":"8a796024968a344c33a96ab0d003119ddd5d9e47","modified":1755045397672},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/note_card.ejs","hash":"f9b87418fbecf9e7e3a5d074ee9e9a26f5cc1788","modified":1755045397675},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/notebook_card.ejs","hash":"999b9c8895d84db707b1654c42326dfbb5fbe0fa","modified":1755045397679},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/note_tags.ejs","hash":"c74624f495b34cf3f40c8771542f9913f060effc","modified":1755045397677},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/paginator.ejs","hash":"3c2f797fd3cf7e6e8c1b1dac168db26e92430b60","modified":1755045397683},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/topic_card.ejs","hash":"9f100016e7cfa07c8728f9c3cf9543ed3ed43cfe","modified":1755045397689},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/wiki_card.ejs","hash":"d2676c1817f09be21008fbf1c2a25e3c9dc1793f","modified":1755045397691},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/post_card.ejs","hash":"0de2735c06858282a94a3152bba916e2c8b70a62","modified":1755045397688},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/link.ejs","hash":"090d697211e4ff984923342fdd3272f46aec415c","modified":1755045397693},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/linklist.ejs","hash":"91f3a83ff54284200951637c0cfcd3e4e613942e","modified":1755045397694},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/read/reel.js","hash":"3a833a0c7d29f98972d6141103d62d5abfd913e4","modified":1755045397702},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/read/paper.js","hash":"e87bbcf10f743e1fcfadc03cf6281aee87c255f5","modified":1755045397697},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/archives.styl","hash":"775f54ade1ed0c673946104149bf37eda06928c2","modified":1755045397705},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/article-indent.styl","hash":"06ac54d4c380a973b0705e3edab099fc218b07d3","modified":1755045397706},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/article-tech.styl","hash":"31fd2b79251b3ebc17976f68c98619a230339b6d","modified":1755045397709},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/error.styl","hash":"91f9df285a87bc7b7e9da19d547ea4b1dc392828","modified":1755045397711},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/article-story.styl","hash":"8c9ffd8309df412b306d2df5f732335a0391007f","modified":1755045397707},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/notebook.styl","hash":"50784f59807f63440f49fd499f05c8871462ef1c","modified":1755045397712},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/article-banner.styl","hash":"49acfb06f81cc0326ffb32c2401876574475fffd","modified":1755045397715},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/article-footer.styl","hash":"c8f47c3798efba31b87c09d880a02e8d59752481","modified":1755045397720},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/cover.styl","hash":"ef44c47d0a70feb84d69cf8bb2bc6977f61b94f2","modified":1755045397726},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/bread-nav.styl","hash":"daf58b32af0b5dfea6cbfa1c3cab695976e57164","modified":1755045397724},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/navbar.styl","hash":"101bc440e18dca938deaf287278e72550f5b7144","modified":1755045397729},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/footer.styl","hash":"870db1f93f9f20d6e86ab11f403eb3011f384c41","modified":1755045397728},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/footer.styl","hash":"e12be49ec96b592f39be2e12b14630b45cd2f508","modified":1755045397737},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/paginator.styl","hash":"04a60ae497a75a8c11880544f97c44e4468608a3","modified":1755045397730},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/related.styl","hash":"699c8b97933358e14ae52873831144165ad5443c","modified":1755045397733},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/logo.styl","hash":"f81eb3d7a49c71f728d8bf42081bde30c6ff596e","modified":1755045397740},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/menu.styl","hash":"11dfb9446c15d6a76073040712aba688e77d8d53","modified":1755045397742},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/nav-area.styl","hash":"35a7482eba84fd48f2439dff626b5e1dc7471dbe","modified":1755045397743},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/search.styl","hash":"976cfd5fe6b10e5227f67f7b06184d3ef009764c","modified":1755045397744},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/sidebar.styl","hash":"e2683183e29c54b69df1dd5606159f893e7c9f5d","modified":1755045397745},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/components.styl","hash":"ebaa8306267f42265be69351a61ae236fc42f4b3","modified":1755045397808},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/ghrepo.styl","hash":"ec728b9649f617a290eb6e4084e30f892671c5b7","modified":1755045397809},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/markdown.styl","hash":"e687ca89549dedd4a724847df1b3be937d945e35","modified":1755045397812},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/ghuser.styl","hash":"21f5f557292ec7b6b434bde918c97ba2a07014ea","modified":1755045397810},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/list.styl","hash":"568645fa91b9bf250af335e10bd8f38df6707a1f","modified":1755045397811},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/related.styl","hash":"edc3e6dd86d881cce6162d6dfb10983c5b843560","modified":1755045397813},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/tagcloud.styl","hash":"b7bd034f85e449c1d5d0f7e691c1812fa9510a3a","modified":1755045397814},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/timeline.styl","hash":"b913cd570a38276e1806fb7685055beb6036973d","modified":1755045397817},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/widgets.styl","hash":"d7d8b864b0e60ae5a55294a2be2bad9001d315c1","modified":1755045397821},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/about.styl","hash":"cdaf1ccd782db961cecda0802c94dabe27656731","modified":1755045397747},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/toc.styl","hash":"cf3ee0ed3b6e855415fc5e858ea63127753caae8","modified":1755045397818},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/button.styl","hash":"25a0fd7d6a39005b2f30f03f94eaa038ece87b22","modified":1755045397752},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/chat.styl","hash":"728954cb8b94823e19abc3483ef57b0d0beb40ae","modified":1755045397754},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/banner.styl","hash":"6dd2b64394bed541814304b90d4bb5ee169e45bb","modified":1755045397750},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/checkbox.styl","hash":"0ba4c88831b8a395e2da74969084cbb3e579a5a1","modified":1755045397755},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/copy.styl","hash":"a51ee1eea2f332d95299e408421fc1f2894b738d","modified":1755045397756},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/emoji.styl","hash":"100d2e0c43496464dd97fa83fa3e603e68bf30e9","modified":1755045397757},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/folders.styl","hash":"2eae18b521a613a19dd6399dcb5504f843dcbb88","modified":1755045397759},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/folding.styl","hash":"84eb11a5a5808f3a4bd0985d97a7b108a36fd044","modified":1755045397760},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/friends.styl","hash":"98cd2513e233dcc3a6aa96e0bb93e87db6d6bc5e","modified":1755045397762},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/frame.styl","hash":"f8621b5a155ea78c5828e7ccbd1dfe6a72c9733c","modified":1755045397761},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/friends_posts.styl","hash":"405c282fa3faab5a4aa6a32971b67abb6852aadf","modified":1755045397763},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/ghcard.styl","hash":"98a50d3fab79ce03dd7f161fe3442d803712c284","modified":1755045397767},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/gallery.styl","hash":"73bc6159765a8dae07733bb313967500dcc49a75","modified":1755045397765},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/grid.styl","hash":"606311fa8326152f99fc721284a09e06490d0cca","modified":1755045397769},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/icon.styl","hash":"ea5372d1042db221f6c3ce5a31e18153c5e00d39","modified":1755045397772},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/hashtag.styl","hash":"0e2e74fcff5c30be9533e451a1c06ed1477dc9aa","modified":1755045397771},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/image.styl","hash":"51dc8e343a5f1ed5b8153138d1d0b4be203052b0","modified":1755045397773},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/inline-labels.styl","hash":"76d7777eb68de8738286ba6ac428854bfdda1945","modified":1755045397774},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/index.styl","hash":"d76245514a5a0aecb65120b7117cd125a70617fb","modified":1755045397773},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/link.styl","hash":"b0039f8ac20f463c3b7dedf2c4f664b48cef8c41","modified":1755045397775},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/mark.styl","hash":"1d31ad6ea25b23dd068508d05e12f76b723790a6","modified":1755045397777},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/mdrender.styl","hash":"95ef27e5937b145329a67e829e20f77e9475ccac","modified":1755045397777},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/media.styl","hash":"392b64b346f6f363f7a15febbc975e5d6c0d33d2","modified":1755045397779},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/navbar.styl","hash":"75a5d208c0a83fa27ed33331ab97dad2bd358d36","modified":1755045397782},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/override.styl","hash":"f02bad5416362f2f82213ce9b111ecfd1cd776ab","modified":1755045397790},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/okr.styl","hash":"3f2232b94fc7fa5a3aa7c3ea120cef87c6379fdd","modified":1755045397788},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/note.styl","hash":"c037dec8860118dba2c5a4f395a3af2ff33ce7b6","modified":1755045397785},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/poetry.styl","hash":"b495d798f4c8a08c6a4bf7b71e1a414b9be0786b","modified":1755045397791},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/quote.styl","hash":"e22fd4527a90f39da29f46e5d35d4d3413ffaa77","modified":1755045397793},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/quot.styl","hash":"aa90d3d99f40da8eebb8f16cfc41ce54b62e88c6","modified":1755045397792},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/sites.styl","hash":"da34492a66b411ed77a15a8c9c398145a9aaf0e2","modified":1755045397796},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/rating.styl","hash":"498934d5b483dcb42bef70c4be7d6e058904b19e","modified":1755045397794},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/timeline.styl","hash":"acad47a9b0175169a5515b2ef6483d7d32e1b9b1","modified":1755045397802},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/tabs.styl","hash":"5c4b4ae76404d9bbfd428f741f371f116296cccb","modified":1755045397799},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/vote.styl","hash":"9253a4627025265da5d22b49955bdc931957af91","modified":1755045397806},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/toc.styl","hash":"32a35fe8c237583542c6965f601a32b28ad83713","modified":1755045397804},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/beaudar.styl","hash":"e9800f67a650f1c022aee494768e05da76e6a6b7","modified":1755045397824},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/artalk.styl","hash":"cbfd6ab362260d7e869cb1fc927d8c66e21a5390","modified":1755045397823},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/twikoo.styl","hash":"838e3c44274ddce8f2d5bb3c54daf6abeae30fc6","modified":1755045397825},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/utterances.styl","hash":"be43f728d9515acaf050fbb3eed83cfefa2fe702","modified":1755045397827},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/waline.styl","hash":"36bfdb6a763f13ff669612c72d066de72d81c0af","modified":1755045397829},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/blog.ejs","hash":"4dad91e5f12af9ee9af91e263afe0796f4f536f0","modified":1755045397831},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/wiki.ejs","hash":"6cdde847f337ddb06bd11f9f0cd26c3183995ddb","modified":1755045397835},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/note.ejs","hash":"c5305bc48e085085334c0e04ddfc597b5c6bc7ae","modified":1755045397833},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/page.ejs","hash":"e27ef964f56860d483e435143c3bf70206223484","modified":1755045397834},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/read/paper.styl","hash":"60f9acda855f45ce57ebb2cbc5ef509aa535c0c8","modified":1755045397838},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/read/reel.styl","hash":"7cc17cd641629d11d435722f75525a92b02c1b5f","modified":1755045397839},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/chat.js","hash":"5effce604c1e4c9868fe0a4f258eef1c44c1b94f","modified":1755045397299},{"_id":"public/search.json","hash":"fa92a21cbae8256e72cba0cc35dd382671118027","modified":1756096901828},{"_id":"public/404.html","hash":"07c97bd311bc79c0b8224226c3e6d998c3bf8c9f","modified":1756096901828},{"_id":"public/about/index.html","hash":"d15d4aef782d66265a600688296c9a5d871ec2aa","modified":1756096901828},{"_id":"public/notebooks/scsn/单调栈和单调队列/index.html","hash":"d24c167ff5a87efd9296da2e2e40edbf15d6ce36","modified":1756096901828},{"_id":"public/friends/index.html","hash":"a206b6556de290cec179ee4bbe3eea39f8885705","modified":1756096901828},{"_id":"public/notebooks/scsn/index.html","hash":"9168a12949c4fbc3d990513e752f999b2aa90368","modified":1756096901828},{"_id":"public/notebooks/scsn/线段树和树状数组/index.html","hash":"2281170baf5280cf44b22c411367e270f8fb0345","modified":1756096901828},{"_id":"public/2025/07/12/快读快写模板/index.html","hash":"3a38d811aef46cfb5e37befd3efb09811443a787","modified":1756096901828},{"_id":"public/2025/07/15/链式前向星/index.html","hash":"17e107750fe84808184b84e4a389f4429d1ae47c","modified":1756096901828},{"_id":"public/2025/08/13/备战CSP-J/index.html","hash":"2049b7d2cdd342f89773a621f0aac4919b4b5e32","modified":1756096901828},{"_id":"public/2025/07/12/搜索题目整理/index.html","hash":"f5f4de5ea227e55ff40475860bf57add8a5b9c4b","modified":1756096901828},{"_id":"public/2025/07/10/最小生成树/index.html","hash":"769c62083efe58e47f7ca3729504eb125b897b5b","modified":1756096901828},{"_id":"public/2025/07/10/最短路/index.html","hash":"6ce41abd8e7a8153c2765e8dc059f0896af8f3d3","modified":1756096901828},{"_id":"public/index.html","hash":"20c4ee98106afdcc97cc9d372750ab1e27d5fcfb","modified":1756097615187},{"_id":"public/categories/学习/index.html","hash":"45602070d5b44821567cffa2f6d2fe6498473aa1","modified":1756097615187},{"_id":"public/categories/学习/分享/index.html","hash":"64d24f79af835361d8fa01e1c6bbf48ee5704b4c","modified":1756097615187},{"_id":"public/tags/OI/index.html","hash":"77e52664715d47a10493fa5a70c6732edefb84a8","modified":1756097615187},{"_id":"public/categories/学习/努力/index.html","hash":"15baff2e5d1ee05cc3a43ad90c9f7f147e301c86","modified":1756097615187},{"_id":"public/categories/学习/努力/备考/index.html","hash":"520aee9a42908bc96c02fa482f16af460f6f3b73","modified":1756097615187},{"_id":"public/tags/模板/index.html","hash":"a7d8c69eeba59edfeca758b299cd2188d57a2854","modified":1756097615187},{"_id":"public/tags/CSP-J/index.html","hash":"bd60447505446fde06d4a4a0a29ab1f49ea2fe25","modified":1756097615187},{"_id":"public/tags/图论/index.html","hash":"bb7406c2dc4c656b59ebca6fa2334057de70bb50","modified":1756097615187},{"_id":"public/tags/搜索/index.html","hash":"a0ab8e49c20cc7e200618e5974cedd7cd92aa54e","modified":1756097615187},{"_id":"public/tags/算法/index.html","hash":"da479706d5f05f67d16866bf95d02866f3c18916","modified":1756097615187},{"_id":"public/tags/存储/index.html","hash":"3f2aafff2344e8b0d5c3ec2d7fb9369aec372efa","modified":1756097615187},{"_id":"public/tags/最小生成树/index.html","hash":"2319a6c407df6ae867c529fcc2df9ddaa543d20d","modified":1756097615187},{"_id":"public/tags/最短路/index.html","hash":"6a4ac182f88dc11bb78a0cc964236f7f41c68666","modified":1756097615187},{"_id":"public/archives/2025/index.html","hash":"b189b973e2e14f83df0fb11b85c3e27540eb2836","modified":1756097615187},{"_id":"public/archives/index.html","hash":"aac38cad5a7bd24503dfee57cfe81d338c8cab29","modified":1756097615187},{"_id":"public/archives/2025/08/index.html","hash":"38111c8ed2bf5c076255e168bb974d950efa60ce","modified":1756097615187},{"_id":"public/archives/2025/07/index.html","hash":"368e106cdd299f2b00f47d89ca24f42c093c92e4","modified":1756097615187},{"_id":"public/categories/index.html","hash":"0bc7674bd318c116f5863aa28ea1050a8f1a5362","modified":1756097615187},{"_id":"public/notebooks/index.html","hash":"be7b21f804dd4fb2a1baff087e7fdb3de148c955","modified":1756096901828},{"_id":"public/scsn/index.html","hash":"d0ac418226fefe02a3777323aeec4b22a75de02f","modified":1756096901828},{"_id":"public/scsn/tags/数据提高班/index.html","hash":"41664fce0acbb6ef2ba53106e7e6969e577ae56b","modified":1756096901828},{"_id":"public/tags/index.html","hash":"c76eda583c29e9b5f2280df0714768c4250235ff","modified":1756097615187},{"_id":"public/css/main.css","hash":"46ae4785e11ab853ff0d92d968a156e7f77fb69d","modified":1756096901828},{"_id":"public/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1756096901828},{"_id":"public/js/main.js","hash":"e702e941a62bf081e9209fdc20d0f5873e9eb902","modified":1756096901828},{"_id":"public/js/plugins/download-file.js","hash":"6bd0cc2f31164406013313543cb04f9ab3cd2452","modified":1756096901828},{"_id":"public/js/plugins/video.js","hash":"e87d271175dfb4763c9c017046f7d857c7a3ba56","modified":1756096901828},{"_id":"public/js/plugins/voice.js","hash":"4c865125754c98dd61de28ad88c831be3d673a35","modified":1756096901828},{"_id":"public/js/search/algolia-search.js","hash":"94dae768b275b12753553553b3338fca4973a1e3","modified":1756096901828},{"_id":"public/js/services/artalk_latest_comment.js","hash":"31acb9a3587aa3012569969675c17645b7722f1f","modified":1756096901828},{"_id":"public/js/search/local-search.js","hash":"d54e8d53e22875faa0e360fc7827f6f9dd068276","modified":1756096901828},{"_id":"public/js/services/fcircle.js","hash":"a684b276713a1c6f07817de9b70744c1a5c745ea","modified":1756096901828},{"_id":"public/js/services/contributors.js","hash":"be5c8ae1055696a0da9c5552fce20c120b2eb584","modified":1756096901828},{"_id":"public/js/services/friends.js","hash":"6b30960a86ce11998c1861cfe3b7a9ecdc28259f","modified":1756096901828},{"_id":"public/js/services/friends_and_posts.js","hash":"0ce8b46873e21e778b315e6c190387cdd1e1e107","modified":1756096901828},{"_id":"public/js/services/ghinfo.js","hash":"693acbabc79426bf276dd3072f40b2d9a98ee026","modified":1756096901828},{"_id":"public/js/services/giscus_latest_comment.js","hash":"b1f0f1a5941a4fdd20fc53444fd4fa6e58b0088e","modified":1756096901828},{"_id":"public/js/services/mdrender.js","hash":"cf90dd3f4aa37b1131fb871ec1a78eff96f2a861","modified":1756096901828},{"_id":"public/js/services/memos.js","hash":"9ecffb14c952d903b21bf2184179868837f74ffa","modified":1756096901828},{"_id":"public/js/services/rating.js","hash":"19e8db4f26af6e656074bebda53d9a00216a0d31","modified":1756096901828},{"_id":"public/js/services/sites.js","hash":"f05d40a3476c796ed9e142ec2d1de15a8d1aef92","modified":1756096901828},{"_id":"public/js/services/twikoo_latest_comment.js","hash":"4e9a18f32faa168b5fd1465d91df67ae3cdde6bf","modified":1756096901828},{"_id":"public/js/services/timeline.js","hash":"43e225ee469d10efe22cae965483a0dabd13388c","modified":1756096901828},{"_id":"public/js/services/siteinfo.js","hash":"e484765fdcabdbbeabf2062baf6ccb94d7ba777f","modified":1756096901828},{"_id":"public/js/services/vote.js","hash":"0fdef6519fa2528f2ffd3b38272955d8469a8b2e","modified":1756096901828},{"_id":"public/js/services/weibo.js","hash":"144200d261c85b4f353243afc1f50003bdf23a93","modified":1756096901828},{"_id":"public/js/services/waline_latest_comment.js","hash":"25ed1f668161941869e5effd4fbb408846c6deae","modified":1756096901828},{"_id":"source/_data/widgets.yml","hash":"5e8f0eac30419dd2e0ca758681a3f40a3c717e47","modified":1756097561801}],"Category":[{"name":"学习","_id":"cmebjcsw60004c4bobabm89ps"},{"name":"分享","parent":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsxy000ic4bodphwgh5k"},{"name":"努力","parent":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsy4000lc4bocslr4pjk"},{"name":"备考","parent":"cmebjcsy4000lc4bocslr4pjk","_id":"cmebjcsys0015c4bogf1s3zcz"}],"Data":[{"_id":"links/qpoem","data":[{"title":"量子诗笺","url":"https://qpoem.org.cn","cover":"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png","icon":"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png","description":"代码如量子般跳跃，书写在诗笺上的每一行都是对未来的预言。"}]},{"_id":"notebooks/scsn","data":{"name":"夏令营学习笔记","title":"Summer Camping Study Note","description":"这是一本用来记录夏令营学习笔记的笔记本","base_dir":"/scsn/","sort":1,"per_page":10,"license":true,"menu_id":"scsn","leftbar":["tagtree"],"rightbar":[],"note_leftbar":["tagtree"],"note_rightbar":["toc"]}},{"_id":"widgets","data":{"welcome":{"layout":"markdown","title":"Welcome to ED-Blog","content":"欢迎使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 主题，下面是您的入门指南，祝您使用愉快！\n<br>\n**第一步**\n创建 `blog/_config.stellar.yml` 文件，在此文件中填写需要自定义的主题配置。\n<br>\n**第二步**\n创建 `blog/source/_data/widgets.yml` 文件，此文件中填写需要自定义的侧边栏组件，例如 `welcome` 组件。\n<br>\n如果有任何疑问，请先查阅 [文档](https://xaoxuu.com/wiki/stellar/)，如果文档中没有提供，请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues/) 向开发者询问。\n"}}}],"Page":[{"menu_id":"about","title":"关于我","_content":"\n我写的不好，大部分都是直接搬运 [Luogu 主页](https://www.luogu.com.cn/user/1023494) 的。\n\n<!-- more -->\n\n![](https://cards.jerryz.com.cn/api?img=2&counter=ED_Builder&date=2025-10-22&str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&quote=Loves+star+forever&qq=2100553299&site=ED-Builder.top&email=ED-Builder%40outlook.com&gitee=ED_Builder&bilibili=ED_Builder&google=edbuilder398%40gmail.com&microsoft=ED-Builder%40outlook.com&luogu=ED_Builder&codeforces=ED_Builder&linuxdo=ED_Builder&bg=255%2C255%2C255%2C0.8)\n### 关于我\n- 一个 [ISTJ-T](https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC)\n- 一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）\n- 一个尽力学习的 OIer\n- 一个用私人服务器的 Arcaea 玩家（PTT = 11.08）\n- 一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）\n- 一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）\n- 一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）\n### 我的参与\n- 现任 [量子诗笺](https://qpoem.org.cn) 技术站长\n- [生物死刑网站](https://github.com/FishLucky/Lucky-Entity) 主要开发者\n- 欢迎来使用 [ED-ImgHub](https://imghub.ed-builder.top) 和 [ED-Comment](https://comment.api.ed-builder.top)","source":"about/index.md","raw":"---\nmenu_id: about\ntitle: 关于我\n---\n\n我写的不好，大部分都是直接搬运 [Luogu 主页](https://www.luogu.com.cn/user/1023494) 的。\n\n<!-- more -->\n\n![](https://cards.jerryz.com.cn/api?img=2&counter=ED_Builder&date=2025-10-22&str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&quote=Loves+star+forever&qq=2100553299&site=ED-Builder.top&email=ED-Builder%40outlook.com&gitee=ED_Builder&bilibili=ED_Builder&google=edbuilder398%40gmail.com&microsoft=ED-Builder%40outlook.com&luogu=ED_Builder&codeforces=ED_Builder&linuxdo=ED_Builder&bg=255%2C255%2C255%2C0.8)\n### 关于我\n- 一个 [ISTJ-T](https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC)\n- 一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）\n- 一个尽力学习的 OIer\n- 一个用私人服务器的 Arcaea 玩家（PTT = 11.08）\n- 一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）\n- 一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）\n- 一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）\n### 我的参与\n- 现任 [量子诗笺](https://qpoem.org.cn) 技术站长\n- [生物死刑网站](https://github.com/FishLucky/Lucky-Entity) 主要开发者\n- 欢迎来使用 [ED-ImgHub](https://imghub.ed-builder.top) 和 [ED-Comment](https://comment.api.ed-builder.top)","date":"2025-08-25T04:41:24.901Z","updated":"2025-08-25T04:41:24.453Z","path":"about/index.html","_id":"cmebjcsum0000c4boauspd466","comments":1,"layout":"page","content":"<p>我写的不好，大部分都是直接搬运 <a href=\"https://www.luogu.com.cn/user/1023494\">Luogu 主页</a> 的。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://cards.jerryz.com.cn/api?img=2&amp;counter=ED_Builder&amp;date=2025-10-22&amp;str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&amp;quote=Loves+star+forever&amp;qq=2100553299&amp;site=ED-Builder.top&amp;email=ED-Builder%40outlook.com&amp;gitee=ED_Builder&amp;bilibili=ED_Builder&amp;google=edbuilder398%40gmail.com&amp;microsoft=ED-Builder%40outlook.com&amp;luogu=ED_Builder&amp;codeforces=ED_Builder&amp;linuxdo=ED_Builder&amp;bg=255%2C255%2C255%2C0.8\" alt=\"\" /></p>\n<h3 id=\"关于我\"><a class=\"markdownIt-Anchor\" href=\"#关于我\"></a> 关于我</h3>\n<ul>\n<li>一个 <a href=\"https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC\">ISTJ-T</a></li>\n<li>一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）</li>\n<li>一个尽力学习的 OIer</li>\n<li>一个用私人服务器的 Arcaea 玩家（PTT = 11.08）</li>\n<li>一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）</li>\n<li>一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）</li>\n<li>一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）</li>\n</ul>\n<h3 id=\"我的参与\"><a class=\"markdownIt-Anchor\" href=\"#我的参与\"></a> 我的参与</h3>\n<ul>\n<li>现任 <a href=\"https://qpoem.org.cn\">量子诗笺</a> 技术站长</li>\n<li><a href=\"https://github.com/FishLucky/Lucky-Entity\">生物死刑网站</a> 主要开发者</li>\n<li>欢迎来使用 <a href=\"https://imghub.ed-builder.top\">ED-ImgHub</a> 和 <a href=\"https://comment.api.ed-builder.top\">ED-Comment</a></li>\n</ul>\n","excerpt":"<p>我写的不好，大部分都是直接搬运 <a href=\"https://www.luogu.com.cn/user/1023494\">Luogu 主页</a> 的。</p>","more":"<p><img src=\"https://cards.jerryz.com.cn/api?img=2&amp;counter=ED_Builder&amp;date=2025-10-22&amp;str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&amp;quote=Loves+star+forever&amp;qq=2100553299&amp;site=ED-Builder.top&amp;email=ED-Builder%40outlook.com&amp;gitee=ED_Builder&amp;bilibili=ED_Builder&amp;google=edbuilder398%40gmail.com&amp;microsoft=ED-Builder%40outlook.com&amp;luogu=ED_Builder&amp;codeforces=ED_Builder&amp;linuxdo=ED_Builder&amp;bg=255%2C255%2C255%2C0.8\" alt=\"\" /></p>\n<h3 id=\"关于我\"><a class=\"markdownIt-Anchor\" href=\"#关于我\"></a> 关于我</h3>\n<ul>\n<li>一个 <a href=\"https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC\">ISTJ-T</a></li>\n<li>一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）</li>\n<li>一个尽力学习的 OIer</li>\n<li>一个用私人服务器的 Arcaea 玩家（PTT = 11.08）</li>\n<li>一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）</li>\n<li>一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）</li>\n<li>一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）</li>\n</ul>\n<h3 id=\"我的参与\"><a class=\"markdownIt-Anchor\" href=\"#我的参与\"></a> 我的参与</h3>\n<ul>\n<li>现任 <a href=\"https://qpoem.org.cn\">量子诗笺</a> 技术站长</li>\n<li><a href=\"https://github.com/FishLucky/Lucky-Entity\">生物死刑网站</a> 主要开发者</li>\n<li>欢迎来使用 <a href=\"https://imghub.ed-builder.top\">ED-ImgHub</a> 和 <a href=\"https://comment.api.ed-builder.top\">ED-Comment</a></li>\n</ul>"},{"notebook":"scsn","title":"Summer Camping Study Note","_content":"\n这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。","source":"notebooks/scsn/index.md","raw":"---\nnotebook: scsn\ntitle: Summer Camping Study Note\n---\n\n这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。","date":"2025-08-25T04:41:24.901Z","updated":"2025-08-25T04:41:24.453Z","path":"notebooks/scsn/index.html","_id":"cmebjcsvr0002c4bohpe372if","comments":1,"layout":"page","content":"<p>这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。</p>\n","excerpt":"","more":"<p>这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。</p>\n"},{"_content":"{% friends qpoem %}","source":"friends/index.md","raw":"{% friends qpoem %}","date":"2025-07-29T11:44:20.064Z","updated":"2025-07-29T11:44:20.064Z","path":"friends/index.html","title":"","comments":1,"layout":"page","_id":"cmebjcswl0006c4boh59p9788","content":"<div class=\"tag-plugin users-wrap\"><div class=\"grid-box\"><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://qpoem.org.cn\"><div class=\"lazy-box icon\"><img class=\"lazy\" data-src=\"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"lazy-icon\" style=\"background-image:url(&quot;https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd&quot;);\"></div></div><div class=\"name\"><span>量子诗笺</span></div></a></div></div></div>","excerpt":"","more":"<div class=\"tag-plugin users-wrap\"><div class=\"grid-box\"><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://qpoem.org.cn\"><div class=\"lazy-box icon\"><img class=\"lazy\" data-src=\"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"lazy-icon\" style=\"background-image:url(&quot;https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd&quot;);\"></div></div><div class=\"name\"><span>量子诗笺</span></div></a></div></div></div>"},{"notebook":"scsn","title":"单调栈和单调队列","tags":["数据提高班"],"_content":"\n## 算法分析\n|数据结构|时间复杂度|空间复杂度|典型用途|\n|:-:|:-:|:-:|:-:|\n|单调栈|$O(n)$|$O(n)$|找下一个更大 / 更小元素|\n|单调队列|$O(n)$|$O(n)$|滑动窗口最大 / 最小值|\n\n## 单调栈\n单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。  \n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。\n### 思路\n- 使用一个栈 `sta`，栈中存储的是“候选元素”的下标（下同）。\n- 栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。\n- 遍历数组 `A`：\n  1. 当 `A[i]` 大于栈顶元素 `A[sta.top()]` 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。\n  2. 重复上述步骤直到栈空或 `A[i] <= A[sta.top()]`。\n  3. 将当前下标 `i` 入栈。\n- 最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。\n### 代码示例\n例题：[Luogu P5788 - 【模板】单调栈](https://luogu.com.cn/problem/P5788)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=3e6+5;\nint a[LEN],f[LEN];\nint n;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    stack<int> sta;//存储下标\n    for(int i=1;i<=n;i++)\n    {\n        //找到一个更大的元素下标\n        while(!sta.empty()&&a[i]>a[sta.top()])\n        {\n            f[sta.top()]=i;\n            sta.pop();//维护单调性\n        }\n        sta.push(i);\n    }\n    for(int i=1;i<=n;i++)  cout<<f[i]<<' ';\n    return 0;\n}\n\n```\n\n---\n## 单调队列\n单调队列通常用来维护滑动窗口中的最大值或最小值，以 **O(1)** 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。\n### 思路\n- 使用 `deque<int> dq`，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。\n- 遍历数组 `A`，下标为 `i`：\n  1. 如果队头 `dq.front()` 已经滑出窗口范围（`i - dq.front() >= k`），则 `dq.pop_front()`。\n  2. 将当前元素与队尾元素比较，若 `A[i]` 大于等于 `A[dq.back()]`，弹出队尾，直到队尾大于当前元素。\n  3. 将 `i` 推入队尾。\n  4. 当窗口形成（`i >= k-1`）时，队头即为窗口最大值下标，记录 `A[dq.front()]`。\n\n### 代码示例\n例题：[Luogu P1886 - 滑动窗口 /【模板】单调队列](https://luogu.com.cn/problem/P1886)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=1e6+5;\nint a[LEN],n,k;\n//单调递增队列求最小值\nvoid getMin()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递增性：弹出比当前值大的队尾元素\n        while(!dq.empty()&&a[dq.back()]>a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        //输出窗口最小值\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\n//单调递减队列求最大值\nvoid getMax()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递减性：弹出比当前值小的队尾元素\n        while(!dq.empty()&&a[dq.back()]<a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\nint main()\n{\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    getMin();//输出每个窗口的最小值\n    cout<<endl;\n    getMax();//输出每个窗口的最大值\n    return 0;\n}\n\n```\n\n---\n## 小结\n- 单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。\n- 单调队列主要用于“滑动窗口”相关最大/最小值。\n- 维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。","source":"notebooks/scsn/单调栈和单调队列.md","raw":"---\nnotebook: scsn\ntitle: 单调栈和单调队列\ntags: [数据提高班]\n---\n\n## 算法分析\n|数据结构|时间复杂度|空间复杂度|典型用途|\n|:-:|:-:|:-:|:-:|\n|单调栈|$O(n)$|$O(n)$|找下一个更大 / 更小元素|\n|单调队列|$O(n)$|$O(n)$|滑动窗口最大 / 最小值|\n\n## 单调栈\n单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。  \n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。\n### 思路\n- 使用一个栈 `sta`，栈中存储的是“候选元素”的下标（下同）。\n- 栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。\n- 遍历数组 `A`：\n  1. 当 `A[i]` 大于栈顶元素 `A[sta.top()]` 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。\n  2. 重复上述步骤直到栈空或 `A[i] <= A[sta.top()]`。\n  3. 将当前下标 `i` 入栈。\n- 最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。\n### 代码示例\n例题：[Luogu P5788 - 【模板】单调栈](https://luogu.com.cn/problem/P5788)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=3e6+5;\nint a[LEN],f[LEN];\nint n;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    stack<int> sta;//存储下标\n    for(int i=1;i<=n;i++)\n    {\n        //找到一个更大的元素下标\n        while(!sta.empty()&&a[i]>a[sta.top()])\n        {\n            f[sta.top()]=i;\n            sta.pop();//维护单调性\n        }\n        sta.push(i);\n    }\n    for(int i=1;i<=n;i++)  cout<<f[i]<<' ';\n    return 0;\n}\n\n```\n\n---\n## 单调队列\n单调队列通常用来维护滑动窗口中的最大值或最小值，以 **O(1)** 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。\n### 思路\n- 使用 `deque<int> dq`，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。\n- 遍历数组 `A`，下标为 `i`：\n  1. 如果队头 `dq.front()` 已经滑出窗口范围（`i - dq.front() >= k`），则 `dq.pop_front()`。\n  2. 将当前元素与队尾元素比较，若 `A[i]` 大于等于 `A[dq.back()]`，弹出队尾，直到队尾大于当前元素。\n  3. 将 `i` 推入队尾。\n  4. 当窗口形成（`i >= k-1`）时，队头即为窗口最大值下标，记录 `A[dq.front()]`。\n\n### 代码示例\n例题：[Luogu P1886 - 滑动窗口 /【模板】单调队列](https://luogu.com.cn/problem/P1886)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=1e6+5;\nint a[LEN],n,k;\n//单调递增队列求最小值\nvoid getMin()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递增性：弹出比当前值大的队尾元素\n        while(!dq.empty()&&a[dq.back()]>a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        //输出窗口最小值\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\n//单调递减队列求最大值\nvoid getMax()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递减性：弹出比当前值小的队尾元素\n        while(!dq.empty()&&a[dq.back()]<a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\nint main()\n{\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    getMin();//输出每个窗口的最小值\n    cout<<endl;\n    getMax();//输出每个窗口的最大值\n    return 0;\n}\n\n```\n\n---\n## 小结\n- 单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。\n- 单调队列主要用于“滑动窗口”相关最大/最小值。\n- 维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。","date":"2025-08-25T04:41:24.901Z","updated":"2025-08-25T04:41:24.453Z","path":"notebooks/scsn/单调栈和单调队列.html","_id":"cmebjcswv0008c4bo1pll1dfc","comments":1,"layout":"page","content":"<h2 id=\"算法分析\"><a class=\"markdownIt-Anchor\" href=\"#算法分析\"></a> 算法分析</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单调栈</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">找下一个更大 / 更小元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单调队列</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">滑动窗口最大 / 最小值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"单调栈\"><a class=\"markdownIt-Anchor\" href=\"#单调栈\"></a> 单调栈</h2>\n<p>单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。<br />\n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h3>\n<ul>\n<li>使用一个栈 <code>sta</code>，栈中存储的是“候选元素”的下标（下同）。</li>\n<li>栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。</li>\n<li>遍历数组 <code>A</code>：\n<ol>\n<li>当 <code>A[i]</code> 大于栈顶元素 <code>A[sta.top()]</code> 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。</li>\n<li>重复上述步骤直到栈空或 <code>A[i] &lt;= A[sta.top()]</code>。</li>\n<li>将当前下标 <code>i</code> 入栈。</li>\n</ol>\n</li>\n<li>最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。</li>\n</ul>\n<h3 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P5788\">Luogu P5788 - 【模板】单调栈</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">3e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],f[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; sta;<span class=\"comment\">//存储下标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到一个更大的元素下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!sta.<span class=\"built_in\">empty</span>()&amp;&amp;a[i]&gt;a[sta.<span class=\"built_in\">top</span>()])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[sta.<span class=\"built_in\">top</span>()]=i;</span><br><span class=\"line\">            sta.<span class=\"built_in\">pop</span>();<span class=\"comment\">//维护单调性</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sta.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;f[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单调队列\"><a class=\"markdownIt-Anchor\" href=\"#单调队列\"></a> 单调队列</h2>\n<p>单调队列通常用来维护滑动窗口中的最大值或最小值，以 <strong>O(1)</strong> 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。</p>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h3>\n<ul>\n<li>使用 <code>deque&lt;int&gt; dq</code>，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。</li>\n<li>遍历数组 <code>A</code>，下标为 <code>i</code>：\n<ol>\n<li>如果队头 <code>dq.front()</code> 已经滑出窗口范围（<code>i - dq.front() &gt;= k</code>），则 <code>dq.pop_front()</code>。</li>\n<li>将当前元素与队尾元素比较，若 <code>A[i]</code> 大于等于 <code>A[dq.back()]</code>，弹出队尾，直到队尾大于当前元素。</li>\n<li>将 <code>i</code> 推入队尾。</li>\n<li>当窗口形成（<code>i &gt;= k-1</code>）时，队头即为窗口最大值下标，记录 <code>A[dq.front()]</code>。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码示例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码示例-2\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P1886\">Luogu P1886 - 滑动窗口 /【模板】单调队列</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],n,k;</span><br><span class=\"line\"><span class=\"comment\">//单调递增队列求最小值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递增性：弹出比当前值大的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&gt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出窗口最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//单调递减队列求最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMax</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递减性：弹出比当前值小的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&lt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"built_in\">getMin</span>();<span class=\"comment\">//输出每个窗口的最小值</span></span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">getMax</span>();<span class=\"comment\">//输出每个窗口的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h2>\n<ul>\n<li>单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。</li>\n<li>单调队列主要用于“滑动窗口”相关最大/最小值。</li>\n<li>维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"算法分析\"><a class=\"markdownIt-Anchor\" href=\"#算法分析\"></a> 算法分析</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单调栈</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">找下一个更大 / 更小元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单调队列</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">滑动窗口最大 / 最小值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"单调栈\"><a class=\"markdownIt-Anchor\" href=\"#单调栈\"></a> 单调栈</h2>\n<p>单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。<br />\n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h3>\n<ul>\n<li>使用一个栈 <code>sta</code>，栈中存储的是“候选元素”的下标（下同）。</li>\n<li>栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。</li>\n<li>遍历数组 <code>A</code>：\n<ol>\n<li>当 <code>A[i]</code> 大于栈顶元素 <code>A[sta.top()]</code> 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。</li>\n<li>重复上述步骤直到栈空或 <code>A[i] &lt;= A[sta.top()]</code>。</li>\n<li>将当前下标 <code>i</code> 入栈。</li>\n</ol>\n</li>\n<li>最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。</li>\n</ul>\n<h3 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P5788\">Luogu P5788 - 【模板】单调栈</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">3e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],f[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; sta;<span class=\"comment\">//存储下标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到一个更大的元素下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!sta.<span class=\"built_in\">empty</span>()&amp;&amp;a[i]&gt;a[sta.<span class=\"built_in\">top</span>()])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[sta.<span class=\"built_in\">top</span>()]=i;</span><br><span class=\"line\">            sta.<span class=\"built_in\">pop</span>();<span class=\"comment\">//维护单调性</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sta.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;f[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单调队列\"><a class=\"markdownIt-Anchor\" href=\"#单调队列\"></a> 单调队列</h2>\n<p>单调队列通常用来维护滑动窗口中的最大值或最小值，以 <strong>O(1)</strong> 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。</p>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h3>\n<ul>\n<li>使用 <code>deque&lt;int&gt; dq</code>，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。</li>\n<li>遍历数组 <code>A</code>，下标为 <code>i</code>：\n<ol>\n<li>如果队头 <code>dq.front()</code> 已经滑出窗口范围（<code>i - dq.front() &gt;= k</code>），则 <code>dq.pop_front()</code>。</li>\n<li>将当前元素与队尾元素比较，若 <code>A[i]</code> 大于等于 <code>A[dq.back()]</code>，弹出队尾，直到队尾大于当前元素。</li>\n<li>将 <code>i</code> 推入队尾。</li>\n<li>当窗口形成（<code>i &gt;= k-1</code>）时，队头即为窗口最大值下标，记录 <code>A[dq.front()]</code>。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码示例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码示例-2\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P1886\">Luogu P1886 - 滑动窗口 /【模板】单调队列</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],n,k;</span><br><span class=\"line\"><span class=\"comment\">//单调递增队列求最小值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递增性：弹出比当前值大的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&gt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出窗口最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//单调递减队列求最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMax</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递减性：弹出比当前值小的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&lt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"built_in\">getMin</span>();<span class=\"comment\">//输出每个窗口的最小值</span></span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">getMax</span>();<span class=\"comment\">//输出每个窗口的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h2>\n<ul>\n<li>单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。</li>\n<li>单调队列主要用于“滑动窗口”相关最大/最小值。</li>\n<li>维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。</li>\n</ul>\n"},{"notebook":"scsn","title":"线段树和树状数组","tags":["数据提高班"],"_content":"\n# 线段树\n## 基本概念\n线段树是一棵 **完全二叉树**，用于在 **静态数组** 上快速完成区间查询（如区间和、区间最大值等）和单点更新。  \n每个节点维护一个区间的信息，根节点代表整个区间，左右子节点分别代表区间的前后半部分。\n\n---\n## 构建流程\n1. 准备大小为 $4\\times LEN$ 的数组 `tree` 来存储节点值。  \n2. 从根节点开始，递归构建：  \n   - 如果区间左端点 = 右端点，直接把原始数组的值写入该节点。  \n   - 否则，计算中点 $mid$，分别构建左右子区间，并将左右子区间结果合并到父节点。\n\n```cpp\nvoid build(int idx,int l,int r)\n{\n    if(l==r)//叶子节点\n    {\n        tree[idx]=arr[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(idx<<1,l,mid);//左子树\n    build(idx<<1|1,mid+1,r);//右子树\n    tree[idx]=tree[idx<<1]+tree[idx<<1|1];//求区间和\n}\n```\n\n---\n## 区间查询\n1. 从根节点开始，看当前节点区间 $[l, r]$ 是否与查询区间 $[L, R]$ 完全重合。  \n2. 如果完全重合，直接返回该节点值。  \n3. 否则，根据中点 $mid$ 决定向左或右子树深入，或者分成两部分递归查询，再把结果相加。\n\n```cpp\nint query(int idx,int l,int r,int L,int R)\n{\n    if(L<=l&&r<=R)  return tree[idx];//区间重合\n    int mid=(l+r)>>1,sum=0;\n    if(L<=mid)  sum+=query(idx<<1,l,mid,L,R);//左子树\n    if(mid<R)  sum+=query(idx<<1|1,mid+1,r,L,R);//右子树\n    return sum;\n}\n```\n\n---\n## 单点更新\n1. 定位到要更新的叶子节点，修改其值。  \n2. 递归返回时，依次在父节点更新合并后的值，保持整棵树信息正确。\n\n```cpp\nvoid update(int idx,int l,int r,int pos,int val)\n{\n    if(l==r)//叶子节点\n    {\n        tree[idx]=val;\n        return;\n    }\n    int mid=(l+r)>>1;\n    if(pos<=mid) update(idx<<1,l,mid,pos,val);//左子树\n    else update(idx<<1|1,mid+1,r,pos,val);//右子树\n    tree[idx]=tree[idx<<1]+tree[idx<<1|1];\n}\n```\n## 代码示例\n例题：[Luogu P3372 - 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)\n### 题意\n维护长度为 n 的序列，支持两种操作：\n1. 区间 `[l, r]` 每个数加上同一个值\n2. 查询区间 `[l, r]` 的所有数之和\n\n### 输入格式\n- 第一行 `n`，`m`\n- 第二行 $n$ 个初始值\n- 接下来 $m$ 行，每行三种格式：\n  - `1 x y k` 表示给区间 `[x, y]` 的每个数加上 k  \n  - `2 x y`   表示询问区间 `[x, y]` 的和  \n\n### 数据范围\n- $1\\le n,m\\le 10^5$\n\n### 代码  \n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int LEN=1e5+5;\nstruct Node\n{\n    int sum,tag;\n    //sum:区间和，tag:懒惰标记\n}tr[LEN*4];\n\nint n,m;\nint a[LEN];\n\nvoid pushup(int u)//更新父节点\n{\n    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\n    return;\n}\n\nvoid apply(int u,int l,int r,int v)//更新子节点\n{\n    tr[u].sum+=v*(r-l+1);\n    tr[u].tag+=v;\n    return;\n}\n\nvoid pushdown(int u,int l,int r)//下传懒惰标记\n{\n    if(tr[u].tag)\n    {\n        int mid=(l+r)>>1;\n        apply(u<<1,l,mid,tr[u].tag);\n        apply(u<<1|1,mid+1,r,tr[u].tag);\n        tr[u].tag=0;\n    }\n    return;\n}\n\nvoid build(int u,int l,int r)//构建线段树\n{\n    tr[u].tag=0;\n    if(l==r)\n    {\n        tr[u].sum=a[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(u<<1,l,mid);\n    build(u<<1|1,mid+1,r);\n    pushup(u);\n    return;\n}\n\nvoid update(int u,int l,int r,int L,int R,int v)//区间更新\n{\n    if(L<=l&&r<=R)\n    {\n        apply(u,l,r,v);\n        return;\n    }\n    pushdown(u,l,r);\n    int mid=(l+r)>>1;\n    if(L<=mid)  update(u<<1,l,mid,L,R,v);\n    if(mid<R)  update(u<<1|1,mid+1,r,L,R,v);\n    pushup(u);\n    return;\n}\n\nint query(int u,int l,int r,int L,int R)//区间查询\n{\n    if(L<=l&&r<=R)  return tr[u].sum;\n    pushdown(u,l,r);\n    int mid=(l+r)>>1;\n    int ans=0;\n    if(L<=mid)  ans+=query(u<<1,l,mid,L,R);\n    if(mid<R)  ans+=query(u<<1|1,mid+1,r,L,R);\n    return ans;\n}\n\nsigned main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    build(1,1,n);\n\n    while(m--)\n    {\n        int op,x,y;\n        cin>>op>>x>>y;\n        if(op==1)\n        {\n            int k;\n            cin>>k;\n            update(1,1,n,x,y,k);\n        }\n        else  cout<<query(1,1,n,x,y)<<endl;\n    }\n    return 0;\n}\n```\n\n---\n# 树状数组（Fenwick Tree）\n## 基本概念\n树状数组又称 **二叉索引树**，用于在 **动态数组** 上快速完成前缀和查询和单点更新。  \n利用 **低位优先** 的思想，把数组分成若干层次，实现 $O(log\\ n)$ 的更新与查询。\n\n---\n## 初始化\n1. 定义大小为 $n+1$ 的数组 `bit`，下标从 1 开始。  \n2. 遍历原始数组，每次调用一次单点更新，把值累加到 `bit` 中。\n\n```cpp\nvector<int> bit(n+1,0);\nfor(int i=1;i<=n;i++)  add(i,arr[i]);//单点更新\n```\n\n---\n## 单点更新\n1. 从更新位置 `i` 开始，依次向后跳到 `i+=lowbit(i)`，把增量 `delta` 累加到所有相关节点上。  \n2. `lowbit(i)` = `i & -i`，表示 i 的最低位权重。\n\n```cpp\nvoid add(int i,int delta)\n{\n    while(i<=n)\n    {\n        bit[i]+=delta;\n        i+=i&-i;\n    }\n}\n```\n\n---\n## 前缀和查询\n1. 从查询位置 `i` 开始，依次向前跳到 `i-=lowbit(i)`，把所有经过节点的 `bit[i]` 累加到结果中。  \n2. 最终得到前缀和 `sum(arr[1..i])`。\n\n```cpp\nint sum(int i)\n{\n    int res=0;\n    while(i>0)\n    {\n        res+=bit[i];\n        i-=i&-i;\n    }\n    return res;\n}\n```\n\n## 代码示例\n例题：[Luogu P3374 - 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)\n### 题意\n给定长度为 n 的整数序列，初始值 $a_1, a_2, \\ldots, a_n$。需要执行 m 次操作，每次操作有两种类型：\n- `1 x k`：将第 x 个数加上 k  \n- `2 x y`：询问区间 $[x, y]$ 内所有数之和  \n### 输入格式\n第一行包含两个整数 n 和 m，分别表示序列长度和操作次数。  \n第二行包含 n 个整数，为序列的初始值。  \n接下来 m 行，每行一个操作指令。  \n### 数据范围\n- $1\\le n,m\\le 5\\times 10^5$；  \n- 所有加数和初始值的绝对值均不超过 $2^{31}$。\n### 解题思路\n我们使用 **树状数组（Fenwick Tree）** 来维护前缀和，支持单点更新和区间查询均为 $O(log\\ n)$：  \n- 初始化时，将每个 a[i] 插入到树状数组。  \n- 对于 “`1 x k`” 操作，在下标 x 处加上 k，即调用 `update(x,k)`。  \n- 对于 “`2 x y`” 操作，利用前缀和差值：`query(y)-query(x-1)`。  \n\n核心操作：  \n- `update(i,v)`：从 i 开始，不断 `i+=lowbit(i)`，将 `tree[i]` 累加 v。  \n- `query(i)`：从 i 开始，不断 `i-=lowbit(i)`，累加 `tree[i]`，直到 `i=0`。  \n\n时间复杂度：$O((n+m)\\ log\\ n)$；空间复杂度：$O(n)$。\n### 代码\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int LEN=5e5+5;\nint n,m;\nint tree[LEN];\n\n//返回最低位 1 的值\ninline int lowbit(int x){return x&-x;}\n\n//单点更新：a[i]+=v\nvoid update(int i,int v)\n{\n    for(;i<=n;i+=lowbit(i))  tree[i]+=v;\n    return;\n}\n\n//查询前缀和 a[1..i]\nint query(int i)\n{\n    int s=0;\n    for(;i>0;i-=lowbit(i))  s+=tree[i];\n    return s;\n}\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        int x;\n        cin>>x;\n        update(i,x);\n    }\n\n    while(m--)\n    {\n        int op,x,y;\n        cin>>op>>x>>y;\n        if(op==1)  update(x,y);\n        else  cout<<query(y)-query(x-1)<<endl;\n    }\n    return 0;\n}\n```\n\n---\n# 对比总结\n|数据结构|区间查询|前缀/区间查询|单点更新|空间复杂度|\n|:-:|:-:|:-:|:-:|:-:|\n|线段树|支持任意区间查询|逻辑同区间查询，$O(log\\ n)$|$O(log\\ n)$|$O(4n)$|\n|树状数组|不直接支持任意区间查询|前缀和 $O(log\\ n)$，区间和可转化|$O(log\\ n)$|$O(n)$|\n\n- 若需支持区间加值、单点查询，可在树状数组中维护差分数组。  \n- 若需支持区间加值、区间查询，则需要 **双树状数组** 或 **差分 + 前缀和** 技巧。  \n- 对比线段树，树状数组代码更简洁，但不易扩展到区间修改和区间查询的混合场景。\n","source":"notebooks/scsn/线段树和树状数组.md","raw":"---\nnotebook: scsn\ntitle: 线段树和树状数组\ntags: [数据提高班]\n---\n\n# 线段树\n## 基本概念\n线段树是一棵 **完全二叉树**，用于在 **静态数组** 上快速完成区间查询（如区间和、区间最大值等）和单点更新。  \n每个节点维护一个区间的信息，根节点代表整个区间，左右子节点分别代表区间的前后半部分。\n\n---\n## 构建流程\n1. 准备大小为 $4\\times LEN$ 的数组 `tree` 来存储节点值。  \n2. 从根节点开始，递归构建：  \n   - 如果区间左端点 = 右端点，直接把原始数组的值写入该节点。  \n   - 否则，计算中点 $mid$，分别构建左右子区间，并将左右子区间结果合并到父节点。\n\n```cpp\nvoid build(int idx,int l,int r)\n{\n    if(l==r)//叶子节点\n    {\n        tree[idx]=arr[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(idx<<1,l,mid);//左子树\n    build(idx<<1|1,mid+1,r);//右子树\n    tree[idx]=tree[idx<<1]+tree[idx<<1|1];//求区间和\n}\n```\n\n---\n## 区间查询\n1. 从根节点开始，看当前节点区间 $[l, r]$ 是否与查询区间 $[L, R]$ 完全重合。  \n2. 如果完全重合，直接返回该节点值。  \n3. 否则，根据中点 $mid$ 决定向左或右子树深入，或者分成两部分递归查询，再把结果相加。\n\n```cpp\nint query(int idx,int l,int r,int L,int R)\n{\n    if(L<=l&&r<=R)  return tree[idx];//区间重合\n    int mid=(l+r)>>1,sum=0;\n    if(L<=mid)  sum+=query(idx<<1,l,mid,L,R);//左子树\n    if(mid<R)  sum+=query(idx<<1|1,mid+1,r,L,R);//右子树\n    return sum;\n}\n```\n\n---\n## 单点更新\n1. 定位到要更新的叶子节点，修改其值。  \n2. 递归返回时，依次在父节点更新合并后的值，保持整棵树信息正确。\n\n```cpp\nvoid update(int idx,int l,int r,int pos,int val)\n{\n    if(l==r)//叶子节点\n    {\n        tree[idx]=val;\n        return;\n    }\n    int mid=(l+r)>>1;\n    if(pos<=mid) update(idx<<1,l,mid,pos,val);//左子树\n    else update(idx<<1|1,mid+1,r,pos,val);//右子树\n    tree[idx]=tree[idx<<1]+tree[idx<<1|1];\n}\n```\n## 代码示例\n例题：[Luogu P3372 - 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)\n### 题意\n维护长度为 n 的序列，支持两种操作：\n1. 区间 `[l, r]` 每个数加上同一个值\n2. 查询区间 `[l, r]` 的所有数之和\n\n### 输入格式\n- 第一行 `n`，`m`\n- 第二行 $n$ 个初始值\n- 接下来 $m$ 行，每行三种格式：\n  - `1 x y k` 表示给区间 `[x, y]` 的每个数加上 k  \n  - `2 x y`   表示询问区间 `[x, y]` 的和  \n\n### 数据范围\n- $1\\le n,m\\le 10^5$\n\n### 代码  \n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int LEN=1e5+5;\nstruct Node\n{\n    int sum,tag;\n    //sum:区间和，tag:懒惰标记\n}tr[LEN*4];\n\nint n,m;\nint a[LEN];\n\nvoid pushup(int u)//更新父节点\n{\n    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\n    return;\n}\n\nvoid apply(int u,int l,int r,int v)//更新子节点\n{\n    tr[u].sum+=v*(r-l+1);\n    tr[u].tag+=v;\n    return;\n}\n\nvoid pushdown(int u,int l,int r)//下传懒惰标记\n{\n    if(tr[u].tag)\n    {\n        int mid=(l+r)>>1;\n        apply(u<<1,l,mid,tr[u].tag);\n        apply(u<<1|1,mid+1,r,tr[u].tag);\n        tr[u].tag=0;\n    }\n    return;\n}\n\nvoid build(int u,int l,int r)//构建线段树\n{\n    tr[u].tag=0;\n    if(l==r)\n    {\n        tr[u].sum=a[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(u<<1,l,mid);\n    build(u<<1|1,mid+1,r);\n    pushup(u);\n    return;\n}\n\nvoid update(int u,int l,int r,int L,int R,int v)//区间更新\n{\n    if(L<=l&&r<=R)\n    {\n        apply(u,l,r,v);\n        return;\n    }\n    pushdown(u,l,r);\n    int mid=(l+r)>>1;\n    if(L<=mid)  update(u<<1,l,mid,L,R,v);\n    if(mid<R)  update(u<<1|1,mid+1,r,L,R,v);\n    pushup(u);\n    return;\n}\n\nint query(int u,int l,int r,int L,int R)//区间查询\n{\n    if(L<=l&&r<=R)  return tr[u].sum;\n    pushdown(u,l,r);\n    int mid=(l+r)>>1;\n    int ans=0;\n    if(L<=mid)  ans+=query(u<<1,l,mid,L,R);\n    if(mid<R)  ans+=query(u<<1|1,mid+1,r,L,R);\n    return ans;\n}\n\nsigned main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    build(1,1,n);\n\n    while(m--)\n    {\n        int op,x,y;\n        cin>>op>>x>>y;\n        if(op==1)\n        {\n            int k;\n            cin>>k;\n            update(1,1,n,x,y,k);\n        }\n        else  cout<<query(1,1,n,x,y)<<endl;\n    }\n    return 0;\n}\n```\n\n---\n# 树状数组（Fenwick Tree）\n## 基本概念\n树状数组又称 **二叉索引树**，用于在 **动态数组** 上快速完成前缀和查询和单点更新。  \n利用 **低位优先** 的思想，把数组分成若干层次，实现 $O(log\\ n)$ 的更新与查询。\n\n---\n## 初始化\n1. 定义大小为 $n+1$ 的数组 `bit`，下标从 1 开始。  \n2. 遍历原始数组，每次调用一次单点更新，把值累加到 `bit` 中。\n\n```cpp\nvector<int> bit(n+1,0);\nfor(int i=1;i<=n;i++)  add(i,arr[i]);//单点更新\n```\n\n---\n## 单点更新\n1. 从更新位置 `i` 开始，依次向后跳到 `i+=lowbit(i)`，把增量 `delta` 累加到所有相关节点上。  \n2. `lowbit(i)` = `i & -i`，表示 i 的最低位权重。\n\n```cpp\nvoid add(int i,int delta)\n{\n    while(i<=n)\n    {\n        bit[i]+=delta;\n        i+=i&-i;\n    }\n}\n```\n\n---\n## 前缀和查询\n1. 从查询位置 `i` 开始，依次向前跳到 `i-=lowbit(i)`，把所有经过节点的 `bit[i]` 累加到结果中。  \n2. 最终得到前缀和 `sum(arr[1..i])`。\n\n```cpp\nint sum(int i)\n{\n    int res=0;\n    while(i>0)\n    {\n        res+=bit[i];\n        i-=i&-i;\n    }\n    return res;\n}\n```\n\n## 代码示例\n例题：[Luogu P3374 - 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)\n### 题意\n给定长度为 n 的整数序列，初始值 $a_1, a_2, \\ldots, a_n$。需要执行 m 次操作，每次操作有两种类型：\n- `1 x k`：将第 x 个数加上 k  \n- `2 x y`：询问区间 $[x, y]$ 内所有数之和  \n### 输入格式\n第一行包含两个整数 n 和 m，分别表示序列长度和操作次数。  \n第二行包含 n 个整数，为序列的初始值。  \n接下来 m 行，每行一个操作指令。  \n### 数据范围\n- $1\\le n,m\\le 5\\times 10^5$；  \n- 所有加数和初始值的绝对值均不超过 $2^{31}$。\n### 解题思路\n我们使用 **树状数组（Fenwick Tree）** 来维护前缀和，支持单点更新和区间查询均为 $O(log\\ n)$：  \n- 初始化时，将每个 a[i] 插入到树状数组。  \n- 对于 “`1 x k`” 操作，在下标 x 处加上 k，即调用 `update(x,k)`。  \n- 对于 “`2 x y`” 操作，利用前缀和差值：`query(y)-query(x-1)`。  \n\n核心操作：  \n- `update(i,v)`：从 i 开始，不断 `i+=lowbit(i)`，将 `tree[i]` 累加 v。  \n- `query(i)`：从 i 开始，不断 `i-=lowbit(i)`，累加 `tree[i]`，直到 `i=0`。  \n\n时间复杂度：$O((n+m)\\ log\\ n)$；空间复杂度：$O(n)$。\n### 代码\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int LEN=5e5+5;\nint n,m;\nint tree[LEN];\n\n//返回最低位 1 的值\ninline int lowbit(int x){return x&-x;}\n\n//单点更新：a[i]+=v\nvoid update(int i,int v)\n{\n    for(;i<=n;i+=lowbit(i))  tree[i]+=v;\n    return;\n}\n\n//查询前缀和 a[1..i]\nint query(int i)\n{\n    int s=0;\n    for(;i>0;i-=lowbit(i))  s+=tree[i];\n    return s;\n}\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        int x;\n        cin>>x;\n        update(i,x);\n    }\n\n    while(m--)\n    {\n        int op,x,y;\n        cin>>op>>x>>y;\n        if(op==1)  update(x,y);\n        else  cout<<query(y)-query(x-1)<<endl;\n    }\n    return 0;\n}\n```\n\n---\n# 对比总结\n|数据结构|区间查询|前缀/区间查询|单点更新|空间复杂度|\n|:-:|:-:|:-:|:-:|:-:|\n|线段树|支持任意区间查询|逻辑同区间查询，$O(log\\ n)$|$O(log\\ n)$|$O(4n)$|\n|树状数组|不直接支持任意区间查询|前缀和 $O(log\\ n)$，区间和可转化|$O(log\\ n)$|$O(n)$|\n\n- 若需支持区间加值、单点查询，可在树状数组中维护差分数组。  \n- 若需支持区间加值、区间查询，则需要 **双树状数组** 或 **差分 + 前缀和** 技巧。  \n- 对比线段树，树状数组代码更简洁，但不易扩展到区间修改和区间查询的混合场景。\n","date":"2025-08-25T04:41:24.901Z","updated":"2025-08-25T04:41:24.454Z","path":"notebooks/scsn/线段树和树状数组.html","_id":"cmebjcsx7000ac4boa162ci8z","comments":1,"layout":"page","content":"<h1 id=\"线段树\"><a class=\"markdownIt-Anchor\" href=\"#线段树\"></a> 线段树</h1>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\"></a> 基本概念</h2>\n<p>线段树是一棵 <strong>完全二叉树</strong>，用于在 <strong>静态数组</strong> 上快速完成区间查询（如区间和、区间最大值等）和单点更新。<br />\n每个节点维护一个区间的信息，根节点代表整个区间，左右子节点分别代表区间的前后半部分。</p>\n<hr />\n<h2 id=\"构建流程\"><a class=\"markdownIt-Anchor\" href=\"#构建流程\"></a> 构建流程</h2>\n<ol>\n<li>准备大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mi>L</mi><mi>E</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">4\\times LEN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的数组 <code>tree</code> 来存储节点值。</li>\n<li>从根节点开始，递归构建：\n<ul>\n<li>如果区间左端点 = 右端点，直接把原始数组的值写入该节点。</li>\n<li>否则，计算中点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span>，分别构建左右子区间，并将左右子区间结果合并到父节点。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> idx,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)<span class=\"comment\">//叶子节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tree[idx]=arr[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(idx&lt;&lt;<span class=\"number\">1</span>,l,mid);<span class=\"comment\">//左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">build</span>(idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r);<span class=\"comment\">//右子树</span></span><br><span class=\"line\">    tree[idx]=tree[idx&lt;&lt;<span class=\"number\">1</span>]+tree[idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];<span class=\"comment\">//求区间和</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"区间查询\"><a class=\"markdownIt-Anchor\" href=\"#区间查询\"></a> 区间查询</h2>\n<ol>\n<li>从根节点开始，看当前节点区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[l, r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 是否与查询区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 完全重合。</li>\n<li>如果完全重合，直接返回该节点值。</li>\n<li>否则，根据中点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span> 决定向左或右子树深入，或者分成两部分递归查询，再把结果相加。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> idx,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> L,<span class=\"type\">int</span> R)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=l&amp;&amp;r&lt;=R)  <span class=\"keyword\">return</span> tree[idx];<span class=\"comment\">//区间重合</span></span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>,sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=mid)  sum+=<span class=\"built_in\">query</span>(idx&lt;&lt;<span class=\"number\">1</span>,l,mid,L,R);<span class=\"comment\">//左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&lt;R)  sum+=<span class=\"built_in\">query</span>(idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,L,R);<span class=\"comment\">//右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单点更新\"><a class=\"markdownIt-Anchor\" href=\"#单点更新\"></a> 单点更新</h2>\n<ol>\n<li>定位到要更新的叶子节点，修改其值。</li>\n<li>递归返回时，依次在父节点更新合并后的值，保持整棵树信息正确。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> idx,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> pos,<span class=\"type\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)<span class=\"comment\">//叶子节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tree[idx]=val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos&lt;=mid) <span class=\"built_in\">update</span>(idx&lt;&lt;<span class=\"number\">1</span>,l,mid,pos,val);<span class=\"comment\">//左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,pos,val);<span class=\"comment\">//右子树</span></span><br><span class=\"line\">    tree[idx]=tree[idx&lt;&lt;<span class=\"number\">1</span>]+tree[idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\"></a> 代码示例</h2>\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P3372\">Luogu P3372 - 【模板】线段树 1</a></p>\n<h3 id=\"题意\"><a class=\"markdownIt-Anchor\" href=\"#题意\"></a> 题意</h3>\n<p>维护长度为 n 的序列，支持两种操作：</p>\n<ol>\n<li>区间 <code>[l, r]</code> 每个数加上同一个值</li>\n<li>查询区间 <code>[l, r]</code> 的所有数之和</li>\n</ol>\n<h3 id=\"输入格式\"><a class=\"markdownIt-Anchor\" href=\"#输入格式\"></a> 输入格式</h3>\n<ul>\n<li>第一行 <code>n</code>，<code>m</code></li>\n<li>第二行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个初始值</li>\n<li>接下来 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 行，每行三种格式：\n<ul>\n<li><code>1 x y k</code> 表示给区间 <code>[x, y]</code> 的每个数加上 k</li>\n<li><code>2 x y</code>   表示询问区间 <code>[x, y]</code> 的和</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据范围\"><a class=\"markdownIt-Anchor\" href=\"#数据范围\"></a> 数据范围</h3>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<h3 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum,tag;</span><br><span class=\"line\">    <span class=\"comment\">//sum:区间和，tag:懒惰标记</span></span><br><span class=\"line\">&#125;tr[LEN*<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//更新父节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tr[u].sum=tr[u&lt;&lt;<span class=\"number\">1</span>].sum+tr[u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">apply</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> v)</span><span class=\"comment\">//更新子节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tr[u].sum+=v*(r-l<span class=\"number\">+1</span>);</span><br><span class=\"line\">    tr[u].tag+=v;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span><span class=\"comment\">//下传懒惰标记</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tr[u].tag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">apply</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid,tr[u].tag);</span><br><span class=\"line\">        <span class=\"built_in\">apply</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,tr[u].tag);</span><br><span class=\"line\">        tr[u].tag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span><span class=\"comment\">//构建线段树</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tr[u].tag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tr[u].sum=a[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(u);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> L,<span class=\"type\">int</span> R,<span class=\"type\">int</span> v)</span><span class=\"comment\">//区间更新</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">apply</span>(u,l,r,v);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">pushdown</span>(u,l,r);</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=mid)  <span class=\"built_in\">update</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid,L,R,v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&lt;R)  <span class=\"built_in\">update</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,L,R,v);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(u);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> L,<span class=\"type\">int</span> R)</span><span class=\"comment\">//区间查询</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=l&amp;&amp;r&lt;=R)  <span class=\"keyword\">return</span> tr[u].sum;</span><br><span class=\"line\">    <span class=\"built_in\">pushdown</span>(u,l,r);</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=mid)  ans+=<span class=\"built_in\">query</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&lt;R)  ans+=<span class=\"built_in\">query</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> op,x,y;</span><br><span class=\"line\">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op==<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> k;</span><br><span class=\"line\">            cin&gt;&gt;k;</span><br><span class=\"line\">            <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,x,y,k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  cout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,x,y)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"树状数组fenwick-tree\"><a class=\"markdownIt-Anchor\" href=\"#树状数组fenwick-tree\"></a> 树状数组（Fenwick Tree）</h1>\n<h2 id=\"基本概念-2\"><a class=\"markdownIt-Anchor\" href=\"#基本概念-2\"></a> 基本概念</h2>\n<p>树状数组又称 <strong>二叉索引树</strong>，用于在 <strong>动态数组</strong> 上快速完成前缀和查询和单点更新。<br />\n利用 <strong>低位优先</strong> 的思想，把数组分成若干层次，实现 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的更新与查询。</p>\n<hr />\n<h2 id=\"初始化\"><a class=\"markdownIt-Anchor\" href=\"#初始化\"></a> 初始化</h2>\n<ol>\n<li>定义大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的数组 <code>bit</code>，下标从 1 开始。</li>\n<li>遍历原始数组，每次调用一次单点更新，把值累加到 <code>bit</code> 中。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bit</span><span class=\"params\">(n<span class=\"number\">+1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  <span class=\"built_in\">add</span>(i,arr[i]);<span class=\"comment\">//单点更新</span></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单点更新-2\"><a class=\"markdownIt-Anchor\" href=\"#单点更新-2\"></a> 单点更新</h2>\n<ol>\n<li>从更新位置 <code>i</code> 开始，依次向后跳到 <code>i+=lowbit(i)</code>，把增量 <code>delta</code> 累加到所有相关节点上。</li>\n<li><code>lowbit(i)</code> = <code>i &amp; -i</code>，表示 i 的最低位权重。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bit[i]+=delta;</span><br><span class=\"line\">        i+=i&amp;-i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"前缀和查询\"><a class=\"markdownIt-Anchor\" href=\"#前缀和查询\"></a> 前缀和查询</h2>\n<ol>\n<li>从查询位置 <code>i</code> 开始，依次向前跳到 <code>i-=lowbit(i)</code>，把所有经过节点的 <code>bit[i]</code> 累加到结果中。</li>\n<li>最终得到前缀和 <code>sum(arr[1..i])</code>。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        res+=bit[i];</span><br><span class=\"line\">        i-=i&amp;-i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码示例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码示例-2\"></a> 代码示例</h2>\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P3374\">Luogu P3374 - 【模板】树状数组 1</a></p>\n<h3 id=\"题意-2\"><a class=\"markdownIt-Anchor\" href=\"#题意-2\"></a> 题意</h3>\n<p>给定长度为 n 的整数序列，初始值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1, a_2, \\ldots, a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。需要执行 m 次操作，每次操作有两种类型：</p>\n<ul>\n<li><code>1 x k</code>：将第 x 个数加上 k</li>\n<li><code>2 x y</code>：询问区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[x, y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">]</span></span></span></span> 内所有数之和</li>\n</ul>\n<h3 id=\"输入格式-2\"><a class=\"markdownIt-Anchor\" href=\"#输入格式-2\"></a> 输入格式</h3>\n<p>第一行包含两个整数 n 和 m，分别表示序列长度和操作次数。<br />\n第二行包含 n 个整数，为序列的初始值。<br />\n接下来 m 行，每行一个操作指令。</p>\n<h3 id=\"数据范围-2\"><a class=\"markdownIt-Anchor\" href=\"#数据范围-2\"></a> 数据范围</h3>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>；</li>\n<li>所有加数和初始值的绝对值均不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{31}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>。</li>\n</ul>\n<h3 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\"></a> 解题思路</h3>\n<p>我们使用 <strong>树状数组（Fenwick Tree）</strong> 来维护前缀和，支持单点更新和区间查询均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>：</p>\n<ul>\n<li>初始化时，将每个 a[i] 插入到树状数组。</li>\n<li>对于 “<code>1 x k</code>” 操作，在下标 x 处加上 k，即调用 <code>update(x,k)</code>。</li>\n<li>对于 “<code>2 x y</code>” 操作，利用前缀和差值：<code>query(y)-query(x-1)</code>。</li>\n</ul>\n<p>核心操作：</p>\n<ul>\n<li><code>update(i,v)</code>：从 i 开始，不断 <code>i+=lowbit(i)</code>，将 <code>tree[i]</code> 累加 v。</li>\n<li><code>query(i)</code>：从 i 开始，不断 <code>i-=lowbit(i)</code>，累加 <code>tree[i]</code>，直到 <code>i=0</code>。</li>\n</ul>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((n+m)\\ log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>；空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h3 id=\"代码-2\"><a class=\"markdownIt-Anchor\" href=\"#代码-2\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">5e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> tree[LEN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回最低位 1 的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;<span class=\"keyword\">return</span> x&amp;-x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单点更新：a[i]+=v</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;=n;i+=<span class=\"built_in\">lowbit</span>(i))  tree[i]+=v;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询前缀和 a[1..i]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&gt;<span class=\"number\">0</span>;i-=<span class=\"built_in\">lowbit</span>(i))  s+=tree[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(i,x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> op,x,y;</span><br><span class=\"line\">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op==<span class=\"number\">1</span>)  <span class=\"built_in\">update</span>(x,y);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  cout&lt;&lt;<span class=\"built_in\">query</span>(y)-<span class=\"built_in\">query</span>(x<span class=\"number\">-1</span>)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"对比总结\"><a class=\"markdownIt-Anchor\" href=\"#对比总结\"></a> 对比总结</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">区间查询</th>\n<th style=\"text-align:center\">前缀/区间查询</th>\n<th style=\"text-align:center\">单点更新</th>\n<th style=\"text-align:center\">空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">线段树</td>\n<td style=\"text-align:center\">支持任意区间查询</td>\n<td style=\"text-align:center\">逻辑同区间查询，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>4</mn><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(4n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">树状数组</td>\n<td style=\"text-align:center\">不直接支持任意区间查询</td>\n<td style=\"text-align:center\">前缀和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，区间和可转化</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>若需支持区间加值、单点查询，可在树状数组中维护差分数组。</li>\n<li>若需支持区间加值、区间查询，则需要 <strong>双树状数组</strong> 或 <strong>差分 + 前缀和</strong> 技巧。</li>\n<li>对比线段树，树状数组代码更简洁，但不易扩展到区间修改和区间查询的混合场景。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"线段树\"><a class=\"markdownIt-Anchor\" href=\"#线段树\"></a> 线段树</h1>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\"></a> 基本概念</h2>\n<p>线段树是一棵 <strong>完全二叉树</strong>，用于在 <strong>静态数组</strong> 上快速完成区间查询（如区间和、区间最大值等）和单点更新。<br />\n每个节点维护一个区间的信息，根节点代表整个区间，左右子节点分别代表区间的前后半部分。</p>\n<hr />\n<h2 id=\"构建流程\"><a class=\"markdownIt-Anchor\" href=\"#构建流程\"></a> 构建流程</h2>\n<ol>\n<li>准备大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mi>L</mi><mi>E</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">4\\times LEN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 的数组 <code>tree</code> 来存储节点值。</li>\n<li>从根节点开始，递归构建：\n<ul>\n<li>如果区间左端点 = 右端点，直接把原始数组的值写入该节点。</li>\n<li>否则，计算中点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span>，分别构建左右子区间，并将左右子区间结果合并到父节点。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> idx,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)<span class=\"comment\">//叶子节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tree[idx]=arr[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(idx&lt;&lt;<span class=\"number\">1</span>,l,mid);<span class=\"comment\">//左子树</span></span><br><span class=\"line\">    <span class=\"built_in\">build</span>(idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r);<span class=\"comment\">//右子树</span></span><br><span class=\"line\">    tree[idx]=tree[idx&lt;&lt;<span class=\"number\">1</span>]+tree[idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];<span class=\"comment\">//求区间和</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"区间查询\"><a class=\"markdownIt-Anchor\" href=\"#区间查询\"></a> 区间查询</h2>\n<ol>\n<li>从根节点开始，看当前节点区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[l, r]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">]</span></span></span></span> 是否与查询区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[L, R]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">]</span></span></span></span> 完全重合。</li>\n<li>如果完全重合，直接返回该节点值。</li>\n<li>否则，根据中点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span> 决定向左或右子树深入，或者分成两部分递归查询，再把结果相加。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> idx,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> L,<span class=\"type\">int</span> R)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=l&amp;&amp;r&lt;=R)  <span class=\"keyword\">return</span> tree[idx];<span class=\"comment\">//区间重合</span></span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>,sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=mid)  sum+=<span class=\"built_in\">query</span>(idx&lt;&lt;<span class=\"number\">1</span>,l,mid,L,R);<span class=\"comment\">//左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&lt;R)  sum+=<span class=\"built_in\">query</span>(idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,L,R);<span class=\"comment\">//右子树</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单点更新\"><a class=\"markdownIt-Anchor\" href=\"#单点更新\"></a> 单点更新</h2>\n<ol>\n<li>定位到要更新的叶子节点，修改其值。</li>\n<li>递归返回时，依次在父节点更新合并后的值，保持整棵树信息正确。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> idx,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> pos,<span class=\"type\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)<span class=\"comment\">//叶子节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tree[idx]=val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos&lt;=mid) <span class=\"built_in\">update</span>(idx&lt;&lt;<span class=\"number\">1</span>,l,mid,pos,val);<span class=\"comment\">//左子树</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,pos,val);<span class=\"comment\">//右子树</span></span><br><span class=\"line\">    tree[idx]=tree[idx&lt;&lt;<span class=\"number\">1</span>]+tree[idx&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\"></a> 代码示例</h2>\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P3372\">Luogu P3372 - 【模板】线段树 1</a></p>\n<h3 id=\"题意\"><a class=\"markdownIt-Anchor\" href=\"#题意\"></a> 题意</h3>\n<p>维护长度为 n 的序列，支持两种操作：</p>\n<ol>\n<li>区间 <code>[l, r]</code> 每个数加上同一个值</li>\n<li>查询区间 <code>[l, r]</code> 的所有数之和</li>\n</ol>\n<h3 id=\"输入格式\"><a class=\"markdownIt-Anchor\" href=\"#输入格式\"></a> 输入格式</h3>\n<ul>\n<li>第一行 <code>n</code>，<code>m</code></li>\n<li>第二行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个初始值</li>\n<li>接下来 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 行，每行三种格式：\n<ul>\n<li><code>1 x y k</code> 表示给区间 <code>[x, y]</code> 的每个数加上 k</li>\n<li><code>2 x y</code>   表示询问区间 <code>[x, y]</code> 的和</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据范围\"><a class=\"markdownIt-Anchor\" href=\"#数据范围\"></a> 数据范围</h3>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<h3 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum,tag;</span><br><span class=\"line\">    <span class=\"comment\">//sum:区间和，tag:懒惰标记</span></span><br><span class=\"line\">&#125;tr[LEN*<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//更新父节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tr[u].sum=tr[u&lt;&lt;<span class=\"number\">1</span>].sum+tr[u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">apply</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> v)</span><span class=\"comment\">//更新子节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tr[u].sum+=v*(r-l<span class=\"number\">+1</span>);</span><br><span class=\"line\">    tr[u].tag+=v;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span><span class=\"comment\">//下传懒惰标记</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tr[u].tag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">apply</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid,tr[u].tag);</span><br><span class=\"line\">        <span class=\"built_in\">apply</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,tr[u].tag);</span><br><span class=\"line\">        tr[u].tag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span><span class=\"comment\">//构建线段树</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tr[u].tag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l==r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tr[u].sum=a[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(u);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> L,<span class=\"type\">int</span> R,<span class=\"type\">int</span> v)</span><span class=\"comment\">//区间更新</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">apply</span>(u,l,r,v);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">pushdown</span>(u,l,r);</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=mid)  <span class=\"built_in\">update</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid,L,R,v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&lt;R)  <span class=\"built_in\">update</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,L,R,v);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(u);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> L,<span class=\"type\">int</span> R)</span><span class=\"comment\">//区间查询</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=l&amp;&amp;r&lt;=R)  <span class=\"keyword\">return</span> tr[u].sum;</span><br><span class=\"line\">    <span class=\"built_in\">pushdown</span>(u,l,r);</span><br><span class=\"line\">    <span class=\"type\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L&lt;=mid)  ans+=<span class=\"built_in\">query</span>(u&lt;&lt;<span class=\"number\">1</span>,l,mid,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mid&lt;R)  ans+=<span class=\"built_in\">query</span>(u&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid<span class=\"number\">+1</span>,r,L,R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> op,x,y;</span><br><span class=\"line\">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op==<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> k;</span><br><span class=\"line\">            cin&gt;&gt;k;</span><br><span class=\"line\">            <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,x,y,k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  cout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,x,y)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"树状数组fenwick-tree\"><a class=\"markdownIt-Anchor\" href=\"#树状数组fenwick-tree\"></a> 树状数组（Fenwick Tree）</h1>\n<h2 id=\"基本概念-2\"><a class=\"markdownIt-Anchor\" href=\"#基本概念-2\"></a> 基本概念</h2>\n<p>树状数组又称 <strong>二叉索引树</strong>，用于在 <strong>动态数组</strong> 上快速完成前缀和查询和单点更新。<br />\n利用 <strong>低位优先</strong> 的思想，把数组分成若干层次，实现 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的更新与查询。</p>\n<hr />\n<h2 id=\"初始化\"><a class=\"markdownIt-Anchor\" href=\"#初始化\"></a> 初始化</h2>\n<ol>\n<li>定义大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的数组 <code>bit</code>，下标从 1 开始。</li>\n<li>遍历原始数组，每次调用一次单点更新，把值累加到 <code>bit</code> 中。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bit</span><span class=\"params\">(n<span class=\"number\">+1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  <span class=\"built_in\">add</span>(i,arr[i]);<span class=\"comment\">//单点更新</span></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单点更新-2\"><a class=\"markdownIt-Anchor\" href=\"#单点更新-2\"></a> 单点更新</h2>\n<ol>\n<li>从更新位置 <code>i</code> 开始，依次向后跳到 <code>i+=lowbit(i)</code>，把增量 <code>delta</code> 累加到所有相关节点上。</li>\n<li><code>lowbit(i)</code> = <code>i &amp; -i</code>，表示 i 的最低位权重。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=n)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bit[i]+=delta;</span><br><span class=\"line\">        i+=i&amp;-i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"前缀和查询\"><a class=\"markdownIt-Anchor\" href=\"#前缀和查询\"></a> 前缀和查询</h2>\n<ol>\n<li>从查询位置 <code>i</code> 开始，依次向前跳到 <code>i-=lowbit(i)</code>，把所有经过节点的 <code>bit[i]</code> 累加到结果中。</li>\n<li>最终得到前缀和 <code>sum(arr[1..i])</code>。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        res+=bit[i];</span><br><span class=\"line\">        i-=i&amp;-i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码示例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码示例-2\"></a> 代码示例</h2>\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P3374\">Luogu P3374 - 【模板】树状数组 1</a></p>\n<h3 id=\"题意-2\"><a class=\"markdownIt-Anchor\" href=\"#题意-2\"></a> 题意</h3>\n<p>给定长度为 n 的整数序列，初始值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_1, a_2, \\ldots, a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。需要执行 m 次操作，每次操作有两种类型：</p>\n<ul>\n<li><code>1 x k</code>：将第 x 个数加上 k</li>\n<li><code>2 x y</code>：询问区间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[x, y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">]</span></span></span></span> 内所有数之和</li>\n</ul>\n<h3 id=\"输入格式-2\"><a class=\"markdownIt-Anchor\" href=\"#输入格式-2\"></a> 输入格式</h3>\n<p>第一行包含两个整数 n 和 m，分别表示序列长度和操作次数。<br />\n第二行包含 n 个整数，为序列的初始值。<br />\n接下来 m 行，每行一个操作指令。</p>\n<h3 id=\"数据范围-2\"><a class=\"markdownIt-Anchor\" href=\"#数据范围-2\"></a> 数据范围</h3>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">1\\le n,m\\le 5\\times 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>；</li>\n<li>所有加数和初始值的绝对值均不超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{31}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>。</li>\n</ul>\n<h3 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\"></a> 解题思路</h3>\n<p>我们使用 <strong>树状数组（Fenwick Tree）</strong> 来维护前缀和，支持单点更新和区间查询均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>：</p>\n<ul>\n<li>初始化时，将每个 a[i] 插入到树状数组。</li>\n<li>对于 “<code>1 x k</code>” 操作，在下标 x 处加上 k，即调用 <code>update(x,k)</code>。</li>\n<li>对于 “<code>2 x y</code>” 操作，利用前缀和差值：<code>query(y)-query(x-1)</code>。</li>\n</ul>\n<p>核心操作：</p>\n<ul>\n<li><code>update(i,v)</code>：从 i 开始，不断 <code>i+=lowbit(i)</code>，将 <code>tree[i]</code> 累加 v。</li>\n<li><code>query(i)</code>：从 i 开始，不断 <code>i-=lowbit(i)</code>，累加 <code>tree[i]</code>，直到 <code>i=0</code>。</li>\n</ul>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((n+m)\\ log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>；空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h3 id=\"代码-2\"><a class=\"markdownIt-Anchor\" href=\"#代码-2\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">5e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> tree[LEN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回最低位 1 的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;<span class=\"keyword\">return</span> x&amp;-x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单点更新：a[i]+=v</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;=n;i+=<span class=\"built_in\">lowbit</span>(i))  tree[i]+=v;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询前缀和 a[1..i]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&gt;<span class=\"number\">0</span>;i-=<span class=\"built_in\">lowbit</span>(i))  s+=tree[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(i,x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> op,x,y;</span><br><span class=\"line\">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op==<span class=\"number\">1</span>)  <span class=\"built_in\">update</span>(x,y);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  cout&lt;&lt;<span class=\"built_in\">query</span>(y)-<span class=\"built_in\">query</span>(x<span class=\"number\">-1</span>)&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"对比总结\"><a class=\"markdownIt-Anchor\" href=\"#对比总结\"></a> 对比总结</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">区间查询</th>\n<th style=\"text-align:center\">前缀/区间查询</th>\n<th style=\"text-align:center\">单点更新</th>\n<th style=\"text-align:center\">空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">线段树</td>\n<td style=\"text-align:center\">支持任意区间查询</td>\n<td style=\"text-align:center\">逻辑同区间查询，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>4</mn><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(4n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">树状数组</td>\n<td style=\"text-align:center\">不直接支持任意区间查询</td>\n<td style=\"text-align:center\">前缀和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，区间和可转化</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>若需支持区间加值、单点查询，可在树状数组中维护差分数组。</li>\n<li>若需支持区间加值、区间查询，则需要 <strong>双树状数组</strong> 或 <strong>差分 + 前缀和</strong> 技巧。</li>\n<li>对比线段树，树状数组代码更简洁，但不易扩展到区间修改和区间查询的混合场景。</li>\n</ul>\n"}],"Post":[{"title":"备战 CSP-J","date":"2025-08-13T00:40:30.000Z","katex":true,"author":"ED_Builder","_content":"\n很难很累，但还是必须去做\n\n<!-- more -->\n\n# 任务清单\n## 一轮真题\n[{% checkbox checked:true 2019 CSP-J1%}](https://ti.luogu.com.cn/problemset/1030)  \n[{% checkbox checked:true 2020 CSP-J1%}](https://ti.luogu.com.cn/problemset/1034)  \n[{% checkbox checked:true 2021 CSP-J1%}](https://ti.luogu.com.cn/problemset/1036)  \n[{% checkbox checked:true 2022 CSP-J1%}](https://ti.luogu.com.cn/problemset/1039)  \n[{% checkbox checked:true 2023 CSP-J1%}](https://ti.luogu.com.cn/problemset/1041)  \n[{% checkbox checked:true 2024 CSP-J1%}](https://ti.luogu.com.cn/problemset/1043)  \n## 二轮真题\n{% checkbox checked:true symbol:minus color:yellow 2019 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2020 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2021 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2022 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2023 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2024 CSP-J2%}\n# 题目选讲\n## 2019 CSP-J1\n### 1. 常识积累\n- T1：中国的国家顶级域名是 `.cn`\n- T3：一个 32 位整形变量占用 {% mark 4 个字节 %}\n- T5：折半查找（二分）时，找到目标最多需要 {% mark log(n) 次 %}\n- T6：链表在 {% mark 插入和删除 %} 中表现优异，在 {% mark 查询 %} 中表现较差，也不必事先估计存储空间\n- T9：100 以内的最大质数是 {% mark 97 %}\n- T15：计算机科学领域的最高奖是 {% mark 图灵奖 %}\n### 2. 数论计算\n#### T7（整数划分）\n把 $8$ 个同样的球放在 $5$ 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？\n提示：如果 $8$ 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。\n{% checkbox A. 22%}\n{% checkbox B. 24%}\n{% checkbox checked:true C. 18%}\n{% checkbox D. 20%}\n解析：直接暴力枚举，然后去重就没了\n#### T12（鸽巢原理）\n一副纸牌除掉大小王有 52 张牌，四种花色，每种花色 13 张。  \n假设从这 52 张牌中随机抽取 13 张牌，则至少（）张牌的花色一致。\n{% checkbox checked:true A. 4%}\n{% checkbox B. 2%}\n{% checkbox C. 3%}\n{% checkbox D. 5%}\n解析：设在 12 张牌中，每种花色 3 张（最坏情况），那么再多一张一定会有 4 张牌的花色一致\n#### T13（乘法原理）\n—些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。\n类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。\n请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（）\n{% checkbox A. 60%}\n{% checkbox B. 125%}\n{% checkbox checked:true C. 75%}\n{% checkbox D. 100%}\n解析：在 0,1,8,6,9 中选择，然后判断回文数（因为顺序颠倒之后还要求是原来的车牌），那么我们只需要考虑第 1，2，3 位就好了  \n但是颠倒之后 6 和 9 会互换，所以第 3 位不能是 6 和 9  \n所以第一、二位有 5 种选择，第三位有 3 种选择，根据乘法原理可得最终方案数为 $5\\times5\\times3=75$\n## 2024 CSP-J2 T2（大模拟）\n题号：[Luogu P11228](https://luogu.com.cn/problem/P11228)\n### 题意\n给出 $n$ 行 $m$ 列的地图，机器人初始位于 $(i,j)$，朝向是 $d$，每次根据当前朝向朝对应方向步进，如果下一步越界或不是空地，那就向右转。问进行 $k$ 次操作之后，机器人走过的格子数量（包括起始位置）\n### 解析\n依题意模拟，用一个集合记录走过的格子，当机器人操作数等于 $k$ 时，输出机器人走过的格子数量，然后结束跑下一组数据即可。\n### 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nbool vis[1005][1005];//走过的格子标记\nchar mp[1005][1005];//地图\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//位移\nvoid init()\n{\n    memset(vis,false,sizeof(vis));//重置为都没被访问\n    return;\n}\nvoid solve()\n{\n    int n,m,k,x,y,d,ans=0;\n    cin>>n>>m>>k>>x>>y>>d;\n    vis[x][y]=true;//起始位置已被访问\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            cin>>mp[i][j];\n    for(int i=1;i<=k;i++)\n    {\n        int nxt_x=x+dx[d],nxt_y=y+dy[d];//计算下一个点\n        if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>m||mp[nxt_x][nxt_y]=='x')\n        {\n            d=(d+1)%4;//如果越界或撞墙，就转\n            continue;\n        }\n        vis[nxt_x][nxt_y]=true;//下一个点已被访问\n        x=nxt_x,y=nxt_y;//更新到下一个点\n    }\n    for(int i=1;i<=n;i++)//统计走过的格子数量\n        for(int j=1;j<=m;j++)\n            if(vis[i][j])  ans++;\n    cout<<ans<<endl;\n    return;\n}\nint main()\n{\n    int T;\n    cin>>T;\n    while(T--)\n    {\n        init();\n        solve();\n    }\n    return 0;\n}\n```\n## 2021 CSP-J2 T3（字符串+模拟）\n### 题意\n给你 $n$ 台机器，分为服务器和客户端。  \n{% mark 难点%} 然后判断服务器和客户端的 IP（IPv4+端口）是否合法  \n然后服务器的 IP 必须保持唯一  \n然后客户端要和对应的 IP 建立连接，按题意输出就好了\n### 解析\n对于验证 IP 的正确性问题，我们可以将 IP 利用 string 存起来，然后利用 `sscanf` 这一利器  \n`sscanf` 的用法：`sscanf(源字符串,格式字符串,目标变量);`  \n下面是一个示例，从 `date` 字符串中按照 `%d/%d/%d %d:%d:%d` 的格式，分别提取到变量 `year` `month` `day` `hour` `minute` `second` 中：  \n`sscanf(date,\"%d/%d/%d %d:%d:%d\",&year,&month,&day,&hour,&minute,&second);`\n\n`sscanf` 的返回值是 **成功提取变量的数量**，例如上面那个例子中的正确返回值应该是 6，如果返回值不等于 6，就说明提取失败。  \n那么让我们带入到 IP 中，我们需要提取 5 个整数，只要返回值不是 5，立刻返回 `false` 即可  \n又看到字符串的长度 $\\le25$，所以最大的整数不超过 17 位，用 `long long` 存就可以。  \n所以我们的一条判断条件就是：\n`if(sscanf(ip.c_str(),\"%lld.%lld.%lld.%lld:%lld\",&a,&b,&c,&d,&e)!=5)  return false;`\n\n现在我们提取到了每个整数，接下来就是判断是否合法了，依照题目判断范围即可，这一步不多说了\n\n然后我们要解决前导 0 的问题。我们可以把我们提取出来的整数拼接回去，拼成一个正确的 IP 地址，然后和读入进来的 IP 进行比较，如果相同就证明没有前导 0。  \n我们可以开一个 string，然后加起来就好了。但是因为你的整数化成字符串有点麻烦，你就可以使用 `to_string()` 函数，这属于 STL 的一种，在 C++11 被引入，OI 使用没问题。\n`string now_ip=to_string(a)+'.'+to_string(b)+'.'+to_string(c)+'.'+to_string(d)+':'+to_string(e);`\n\n---\n验证 IP 解决了，下面就是连接问题。  \n连接过程中，你需要根据客户端请求的 IP 寻找服务器 IP，然后输出对应的 ID 即可。  \n这一步我们可以使用 `map` 或 `unordered_map` 来解决，这可以减少内存的占用。\n\n我们建立 `unordered_map<string,bool> server_ip_exist` 来表示服务器 IP 是否存在，`unordered_map<string,int> server_id` 来表示服务器 IP 对应的 ID。  \n然后在读入的时候先看看当前输入的 IP 是否存在，然后就可以标记存在和记录 ID 了。\n### 代码\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nunordered_map<string,bool> server_ip_exist;\nunordered_map<string,int> server_id;\nbool check_ip(string ip)\n{\n    int a,b,c,d,e;\n    if(sscanf(ip.c_str(),\"%lld.%lld.%lld.%lld:%lld\",&a,&b,&c,&d,&e)!=5)  return false;\n    if(a<0||a>255||b<0||b>255||c<0||c>255||d<0||d>255||e<0||e>65535)  return false;\n    string now;\n    now=to_string(a)+'.'+to_string(b)+'.'+to_string(c)+'.'+to_string(d)+':'+to_string(e);\n    if(now!=ip)  return false;\n    return true;\n}\nsigned main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        string type,ip;\n        cin>>type>>ip;\n        if(type==\"Server\")\n        {\n            if(server_ip_exist[ip])//服务器 IP 已存在\n            {\n                cout<<\"FAIL\"<<endl;\n                continue;\n            }\n            if(!check_ip(ip))//IP 格式错误\n            {\n                cout<<\"ERR\"<<endl;\n                continue;\n            }\n            server_ip_exist[ip]=true;//标记 IP 存在\n            server_id[ip]=i;//记录 ID\n            cout<<\"OK\"<<endl;\n        }\n        if(type==\"Client\")\n        {\n            if(!check_ip(ip))//IP 格式错误\n            {\n                cout<<\"ERR\"<<endl;\n                continue;\n            }\n            if(!server_ip_exist[ip])//服务器 IP 不存在\n            {\n                cout<<\"FAIL\"<<endl;\n                continue;\n            }\n            cout<<server_id[ip]<<endl;\n        }\n    }\n    exit(0);\n}\n```\n# 知识积累\n## 与或非运算\n这些操作都要在 **二进制下** 完成\n- 按位与：`&`：每一位都必须是 `1` 才会得到 `1`，否则是 `0`\n- 按位或：`|`：每一位只要有一个是 `1` 就会得到 `1`\n- 按位非：`~`：每一位取反\n- 按位异或：`^`：每一位相同为 `0`，不同为 `1`\n\n在数学上，$\\land$ 和 `&&` 是一样的，$\\lor$ 和 `||` 是一样的，$\\neg$ 和 `!` 是一样的  \n这是 **逻辑运算符**，不要混淆\n## （重难点）进制转换\n转换技巧：遇到 x 进制转 y 进制，可以先把 x 进制转为 10 进制，再转为 y 进制\n### x 进制转 10 进制\n{% mark 按位展开，乘权相加 %}  \n例如 $(2F)_{16}$ 转 10 进制：  \n$$\n({\\color{red}2F})_{16}={\\color{red}2}\\times16^{\\color{blue}1}+{\\color{red}15}\\times16^{\\color{blue}0}=32+15=(47)_{10}\n$$\n在上面的式子中，$F$ 其实就是十进制里面的 $15$，这不用多说\n\n如果是带小数的部分，要 {% mark 乘负权相加%}  \n例如 $(A.F)_{16}$ 转 10 进制\n$$\n({\\color{red}A.F})_{16}={\\color{red}10}\\times 16^{\\color{blue}0}+{\\color{red}15}\\times 16^{\\color{blue}-1}=10+\\frac{15}{16^1}=(10.9375)_{10}\n$$\n### 10 进制转 x 进制\n{% mark 不断除以 x，余数倒着写，商循环利用 %}   \n例如 $(47)_{10}$ 转 16 进制\n$$\n47\\div16={\\color{blue}2}\\dots 15({\\color{red}F})\\\\\n{\\color{blue}2}\\div16={\\color{green}0}\\dots {\\color{red}2}\\\\\n\\therefore (47)_{10}=({\\color{red}2F})_{16}\n$$\n\n如果是带小数的转换，整数部分还是和上面相同的，小数部分要 {% mark 不断乘以 x，商取整，顺着写，小数循环利用%}\n例如 $(114.514)_{10}$ 转 8 进制  \n那么我们先算整数部分：\n$$\n114\\div 8={\\color{blue}14}\\dots {\\color{red}2}\\\\\n{\\color{blue}14}\\div 8={\\color{blue}1}\\dots {\\color{red}6}\\\\\n{\\color{blue}1}\\div 8={\\color{green}0}\\dots {\\color{red}1}\\\\\n\\therefore (114)_{10}=({\\color{red}162})_{8}\n$$\n然后算小数部分：\n$$\n0.514\\times 8={\\color{red}4}.{\\color{blue}112}\\\\\n{0.\\color{blue}112}\\times 8={\\color{red}0}.{\\color{blue}912}\\\\\n{0.\\color{blue}912}\\times 8={\\color{red}7}.{\\color{blue}296}\\\\\n\\dots \\\\\n\\therefore (0.514)_{10}=(0.{\\color{red}407})_{8}\n$$\n最后让我们加起来，得到了 $(114.514)_{10}=(162.407)_{8}$  \n如果题目中需要更高的精度，那就继续乘以 8，直到小数部分为 0\n### 常用数字的进制转换\n|十进制|二进制|八进制|十六进制|\n|:-:|:-:|:-:|:-:|\n|0|0000|0|0|\n|1|0001|1|1|\n|2|0010|2|2|\n|...|...|...|...|\n|7|0111|17|7|\n|8|1000|10|8|\n|...|...|...|...|\n|15|1111|17|F|\n|16|10000|20|10|\n|...|...|...|...|\n## 二进制编码\n- 原码：用 {% mark 最高位%} 作为符号位，0是正数，1是负数，符号位之后是这个十进制数的绝对值的二进制，存在 -0 的问题，所以不用\n- 反码：正数和原码相同；负数符号位不变，剩余的 {% mark 在原码基础上按位取反 %}\n- 补码：正数和原码相同；负数就是反码+1（忽略符号位进位）\n## GCD 和 LCM\n- GCD：Greatest Common Divisor，最大公约数\n- LCM：Least Common Multiple，最小公倍数\n- GCD 和 LCM 之间的关系：\n$$\nGCD(a,b)\\times LCM(a,b)=a\\times b\n$$\n- 在 C++14 标准之后（OI 可用），你可以通过 `algorithm` 库中的 `std::__gcd(int,int)` 和 `std::__lcm(int,int)` 来计算 GCD 和 LCM\n- 在 CSP 一轮考场上，可以直接带入选项中的数值去尝试\n## （重难点）排列与组合\n### 排列\n概念：集合 $S$ 由 $n$个不同的元素组成，取出其中的 $r$ 个，{% mark 与顺序有关 %} 的情况数为 $A_n^r$，计算公式为：\n$$\nA_n^r=\\frac{n!}{(n-r)!}\n$$\n例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同也算另一种）  \n那么一共有\n$$\nA_5^2=\\frac{5!}{(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{3\\times2\\times1}=\\frac{120}{6}=20\n$$\n种方案\n\n当 $n=r$ 时，$A_n^r=A_n^n=n!$\n### 组合\n概念：集合 $S$ 由 $n$个不同的元素组成，取出其中的 $r$ 个，{% mark 与顺序无关 %} 的情况数为 $C_n^r$，计算公式为：\n$$\nC_n^r=\\frac{A_n^r}{r!}=\\frac{\\frac{n!}{(n-r)!}}{r!}=\\frac{n!}{r!(n-r)!}\n$$\n例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同只算做同一种）  \n那么一共有\n$$\nC_5^2=\\frac{5!}{2!(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{2\\times1\\times3\\times2\\times1}=\\frac{120}{2\\times6}=10\n$$\n种方案\n\n当 $n=r$ 时，$C_n^r=C_n^n=1$\n### 排列与组合的联系\n$$\nA_n^r=C_n^r\\times A_r^r\\\\\nC_n^r=C_n^{n-r}\\\\\nC_{n+1}^r=C_n^r+C_n^{r-1}\n$$\n### 有重复的排列\n给出具有 $n$ 个对象的集合 $S$，选出 $r$ 个，可以重复选择  \n从第 1 个位置到第 $r$ 个位置，每个位置有 $n$ 种选择，那么一共有 $n^r$ 种方案\n### 有重复的组合（插板法）\n给出具有 $n$ 个对象的集合 $S$，选出 $r$ 个，可以重复选择，与顺序无关  \n最终方案数是 $C_{n+r-1}^r$\n## （重难点）小球与盒子\n你有 $n$ 个小球，要放到 $m$ 个盒子里，每个盒子可以放多个小球，\n### 可辨别的小球与可辨别的盒子\n最终方案数是 $C_{n+m-1}^n$\n### 不可辨别的小球与可辨别的盒子\n盒子可以是空的：$C_{n+m-1}^{m-1}$\n盒子不能是空的：$C_{n-1}^{m-1}$\n\n剩下两种严重超纲，不记（涉及到第二类斯特林数和很多的分类讨论）\n## （易考）树的遍历\n给出前序遍历和中序遍历，可以唯一确定一棵二叉树  \n给出后序遍历和中序遍历，可以唯一确定一棵二叉树\n### 步骤\n1. 前序遍历的第一个元素是根节点，后序遍历的最后一个元素是根节点\n2. 在中序遍历中找到根节点，它的左边是左子树，右边是右子树\n3. 递归构建左子树和右子树\n### 示例\n前序：`ABDECFG`  \n中序：`DBEAFCG`\n\n1. 首先确定 `A` 为根节点\n2. 在中序遍历中找到 `A`，它的左边 `DBE` 是左子树，右边 `FCG` 是右子树\n3. 在前序 `BDE` 和 `CFG` 中得到后序遍历 `DBE` 和 `CFG`\n4. 接上根节点 `A`，得到后序遍历 `DBECFGA`\n\n也可以去 2019 CSP-J1 T14 练习\n## （易考）单位换算\n`M = 1e6`，`K = 1e3`  \n`1B(yte) = 8bit`\n### 二进制存储空间换算\n`1TiB = 2e10GiB = 2e20MiB = 2e30KiB = 2e40B = 2e43bit`  \n$1 TiB = 2^{10} GiB = 2^{20} MiB = 2^{30} KiB = 2^{40} B = 2^{43} bit$\n### 十进制存储空间换算\n`1TB = 1e3GB = 1e6MB = 1e9KB = 1e12B = 8*1e12bit`  \n$1 TB = 10^3 GB = 10^6 MB = 10^9 KB = 10^{12} B = 8\\times10^{12} bit$\n## 文件存储空间\n图片存储空间：$分辨率\\times 位深度(bit)$\n视频存储空间：$单张图大小\\times fps\\times 时长(bit)$\n            $(视频 bps+音频 bps)\\times 时长$（单位根据码率单位而定）\n帧率缩写 fps，码率 bps\n## NOI 历史\n- 第一届 NOI：1984，今年（NOI2025）第 41 届\n- 第一届 IOI：1989\n- 我国 2000 举办第 12 届 IOI\n- 第一届 NOIP：1995，2019 暂停一届\n- 第一届 CSP：2019\n## 网络\n### OSI 七层模型\n1. 物理层：光纤、中继器\n2. 数据链链路层：网卡、交换机、以太网\n3. 网络层：IP、ICMP\n4. 传输层：TCP、UDP\n5. 会话层：SSL、TLS\n6. 表示层：LPP\n7. 应用层：HTTP、FTP、SMTP、POP3\n### 协议\nHTTP：超文本传输协议\nFTP：文件传输协议\nSMTP：收发电子邮件\nPOP3：接收电子邮件\nTCP：三次握手(A->B 质询在线，B->A 返回在线，A->B 返回确认收到)\n### IP 地址\nIPv4：`x.x.x.x`（0<=x<=255）32bit 4B\n- A类地址：`1.0.0.1` ~ `127.255.255.254`\n- B类地址：`128.0.0.1` ~ `191.255.255.254`\n- C类地址：`192.0.0.1` ~ `223.255.255.254`\n\nIPv6：`X:X:X:X:X:X:X:X`（0000<=X<=FFFF）64bit 8B\n## 排序\n### 算法信息\nn=等待排序的个数，w=数据值域\n|算法名称|平均时间|最坏时间|是否稳定|\n|:-:|:-:|:-:|:-:|\n|冒泡排序|$O(n^2)$|$O(n^2)$|true|\n|选择排序|$O(n^2)$|$O(n^2)$|false|\n|插入排序|$O(n^2)$|$O(n^2)$|true|\n|计数排序|$O(n+w)$|$O(n+w)$|true|\n|归并排序|$\\theta(n log n)$|$\\theta(n log n)$|true|\n|快速排序|$O(n log n)$|$O(n^2)$|false|\n### 快速排序原理\n使用递归原理  \n在 a[l]~a[r] 中选择一个基准 x  \n使用双指针将所有 `a[i] < x` 交换到 x 左侧，`a[i] > x` 交换到 x 右侧  \n快速排序通过双指针交换后，将一个大的排序问题划分为了两个子区间排序的小问题  \n所以期望复杂度 $O(n log n)$  \n如果选择第一个数作为基准，序列有序，每次序列长度只减少 1  \n所以最坏复杂度 $O(n^2)$\n### std::sort\n由 algorithm 头文件提供，属于 STL  \n在数据范围较小的情况下，使用了堆排序等技术\n## 数据结构\n### 链表\n优点：插入删除 $O(1)$  \n缺点：读取 $O(n)$ n=链表元素个数\n\n示例：\n```\n[prev = NULL, id = 1, value = 114, next = 514]  \n[prev = 1, id = 514, value = 1919, next = 1919]  \n[prev = 514, id = 1919, value = 810, next = NULL]\n```\n### 图的存储\n#### 邻接矩阵\n优点：查询边权 $O(1)$\n缺点：对于稀疏图，浪费空间\n#### 邻接表\n优点：空间复杂度 $O(|E|)$\n缺点：查询边权 $O(|V|)$\n### 树\n有 $n$ 个节点 $n-1$ 条边的无向连通图\n完整二叉树：每个节点的子节点数量都是 0 或 2\n## 运算优先级\n自增/自减 执行顺序\n\n`++x` 先增加 x 的值，然后送出使用  \n`x++` 先送出使用，然后增加 x 的值  \n\n{% copy ans+=++x; = x=x+1;ans=ans+x; prefix:C++%}\n{% copy ans+=x++; = ans=ans+x;x=x+1; prefix:C++%}\n\n`x++ + ++x`  \n这属于 未定义行为（Undefined Behavior, UB），在不同的编译器上可以解释为任何值。  \n这可能导致本地通过，评测报错  \n可以通过 `-Wall` 参数找到所有的警告\n## 计算原理\n### 容斥原理/减法法则\n如果一个任务可以通过 $n_1$ 种方法执行，还可以通过 $n_2$ 种另一类方法执行，那么执行这个任务的方法数量是 $n_1+n_2-[两种方法中相同的方法]$  \n也就是说，集合 $A_1,A_2$，与并集 $A_1\\cup A_2$，满足 $|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap A_2|$  \n### 鸽巢原理\n如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 2 个或更多的物体\n### 广义鸽巢原理\n如果 $n$ 个物体放入 $k$ 个盒子，那么至少有一个盒子至少包含了 $\\lceil \\frac{n}{k}\\rceil$ 个物体\n## 高级语言分类\n- 面向过程：以函数为基本程序结构：C，Pascal，Fortran\n- 面向对象：以类为基本程序结构：C++，Java，Python\n- 编译性：执行前用连接器生成可执行文件：C++\n- 解释性：一边用解释器翻译，一边运行代码：Python，JS，Ruby\n- Java：编译 + 解释混合\n## 计算机历史\n- 第一台计算机 - ENIAC\n- 有存储功能 - EDVAC\n- 冯诺依曼 - 存储结构\n- 图灵 - 测试\n- 阿达罗福莱斯 - 计算机程序的创始人\n- 马文·明斯基、约翰·麦卡西 - 对 AI 杰出贡献\n- 香农 - 信息论\n## 哈夫曼树\n// TODO\n","source":"_posts/备战CSP-J.md","raw":"---\ntitle: 备战 CSP-J\ndate: 2025-08-13 08:40:30\ntags: ['OI', 'CSP-J']\ncategories: ['学习', '努力','备考']\nkatex: true\nauthor: ED_Builder\n---\n\n很难很累，但还是必须去做\n\n<!-- more -->\n\n# 任务清单\n## 一轮真题\n[{% checkbox checked:true 2019 CSP-J1%}](https://ti.luogu.com.cn/problemset/1030)  \n[{% checkbox checked:true 2020 CSP-J1%}](https://ti.luogu.com.cn/problemset/1034)  \n[{% checkbox checked:true 2021 CSP-J1%}](https://ti.luogu.com.cn/problemset/1036)  \n[{% checkbox checked:true 2022 CSP-J1%}](https://ti.luogu.com.cn/problemset/1039)  \n[{% checkbox checked:true 2023 CSP-J1%}](https://ti.luogu.com.cn/problemset/1041)  \n[{% checkbox checked:true 2024 CSP-J1%}](https://ti.luogu.com.cn/problemset/1043)  \n## 二轮真题\n{% checkbox checked:true symbol:minus color:yellow 2019 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2020 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2021 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2022 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2023 CSP-J2%}\n{% checkbox checked:true symbol:minus color:yellow 2024 CSP-J2%}\n# 题目选讲\n## 2019 CSP-J1\n### 1. 常识积累\n- T1：中国的国家顶级域名是 `.cn`\n- T3：一个 32 位整形变量占用 {% mark 4 个字节 %}\n- T5：折半查找（二分）时，找到目标最多需要 {% mark log(n) 次 %}\n- T6：链表在 {% mark 插入和删除 %} 中表现优异，在 {% mark 查询 %} 中表现较差，也不必事先估计存储空间\n- T9：100 以内的最大质数是 {% mark 97 %}\n- T15：计算机科学领域的最高奖是 {% mark 图灵奖 %}\n### 2. 数论计算\n#### T7（整数划分）\n把 $8$ 个同样的球放在 $5$ 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？\n提示：如果 $8$ 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。\n{% checkbox A. 22%}\n{% checkbox B. 24%}\n{% checkbox checked:true C. 18%}\n{% checkbox D. 20%}\n解析：直接暴力枚举，然后去重就没了\n#### T12（鸽巢原理）\n一副纸牌除掉大小王有 52 张牌，四种花色，每种花色 13 张。  \n假设从这 52 张牌中随机抽取 13 张牌，则至少（）张牌的花色一致。\n{% checkbox checked:true A. 4%}\n{% checkbox B. 2%}\n{% checkbox C. 3%}\n{% checkbox D. 5%}\n解析：设在 12 张牌中，每种花色 3 张（最坏情况），那么再多一张一定会有 4 张牌的花色一致\n#### T13（乘法原理）\n—些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。\n类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。\n请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（）\n{% checkbox A. 60%}\n{% checkbox B. 125%}\n{% checkbox checked:true C. 75%}\n{% checkbox D. 100%}\n解析：在 0,1,8,6,9 中选择，然后判断回文数（因为顺序颠倒之后还要求是原来的车牌），那么我们只需要考虑第 1，2，3 位就好了  \n但是颠倒之后 6 和 9 会互换，所以第 3 位不能是 6 和 9  \n所以第一、二位有 5 种选择，第三位有 3 种选择，根据乘法原理可得最终方案数为 $5\\times5\\times3=75$\n## 2024 CSP-J2 T2（大模拟）\n题号：[Luogu P11228](https://luogu.com.cn/problem/P11228)\n### 题意\n给出 $n$ 行 $m$ 列的地图，机器人初始位于 $(i,j)$，朝向是 $d$，每次根据当前朝向朝对应方向步进，如果下一步越界或不是空地，那就向右转。问进行 $k$ 次操作之后，机器人走过的格子数量（包括起始位置）\n### 解析\n依题意模拟，用一个集合记录走过的格子，当机器人操作数等于 $k$ 时，输出机器人走过的格子数量，然后结束跑下一组数据即可。\n### 代码\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nbool vis[1005][1005];//走过的格子标记\nchar mp[1005][1005];//地图\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//位移\nvoid init()\n{\n    memset(vis,false,sizeof(vis));//重置为都没被访问\n    return;\n}\nvoid solve()\n{\n    int n,m,k,x,y,d,ans=0;\n    cin>>n>>m>>k>>x>>y>>d;\n    vis[x][y]=true;//起始位置已被访问\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            cin>>mp[i][j];\n    for(int i=1;i<=k;i++)\n    {\n        int nxt_x=x+dx[d],nxt_y=y+dy[d];//计算下一个点\n        if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>m||mp[nxt_x][nxt_y]=='x')\n        {\n            d=(d+1)%4;//如果越界或撞墙，就转\n            continue;\n        }\n        vis[nxt_x][nxt_y]=true;//下一个点已被访问\n        x=nxt_x,y=nxt_y;//更新到下一个点\n    }\n    for(int i=1;i<=n;i++)//统计走过的格子数量\n        for(int j=1;j<=m;j++)\n            if(vis[i][j])  ans++;\n    cout<<ans<<endl;\n    return;\n}\nint main()\n{\n    int T;\n    cin>>T;\n    while(T--)\n    {\n        init();\n        solve();\n    }\n    return 0;\n}\n```\n## 2021 CSP-J2 T3（字符串+模拟）\n### 题意\n给你 $n$ 台机器，分为服务器和客户端。  \n{% mark 难点%} 然后判断服务器和客户端的 IP（IPv4+端口）是否合法  \n然后服务器的 IP 必须保持唯一  \n然后客户端要和对应的 IP 建立连接，按题意输出就好了\n### 解析\n对于验证 IP 的正确性问题，我们可以将 IP 利用 string 存起来，然后利用 `sscanf` 这一利器  \n`sscanf` 的用法：`sscanf(源字符串,格式字符串,目标变量);`  \n下面是一个示例，从 `date` 字符串中按照 `%d/%d/%d %d:%d:%d` 的格式，分别提取到变量 `year` `month` `day` `hour` `minute` `second` 中：  \n`sscanf(date,\"%d/%d/%d %d:%d:%d\",&year,&month,&day,&hour,&minute,&second);`\n\n`sscanf` 的返回值是 **成功提取变量的数量**，例如上面那个例子中的正确返回值应该是 6，如果返回值不等于 6，就说明提取失败。  \n那么让我们带入到 IP 中，我们需要提取 5 个整数，只要返回值不是 5，立刻返回 `false` 即可  \n又看到字符串的长度 $\\le25$，所以最大的整数不超过 17 位，用 `long long` 存就可以。  \n所以我们的一条判断条件就是：\n`if(sscanf(ip.c_str(),\"%lld.%lld.%lld.%lld:%lld\",&a,&b,&c,&d,&e)!=5)  return false;`\n\n现在我们提取到了每个整数，接下来就是判断是否合法了，依照题目判断范围即可，这一步不多说了\n\n然后我们要解决前导 0 的问题。我们可以把我们提取出来的整数拼接回去，拼成一个正确的 IP 地址，然后和读入进来的 IP 进行比较，如果相同就证明没有前导 0。  \n我们可以开一个 string，然后加起来就好了。但是因为你的整数化成字符串有点麻烦，你就可以使用 `to_string()` 函数，这属于 STL 的一种，在 C++11 被引入，OI 使用没问题。\n`string now_ip=to_string(a)+'.'+to_string(b)+'.'+to_string(c)+'.'+to_string(d)+':'+to_string(e);`\n\n---\n验证 IP 解决了，下面就是连接问题。  \n连接过程中，你需要根据客户端请求的 IP 寻找服务器 IP，然后输出对应的 ID 即可。  \n这一步我们可以使用 `map` 或 `unordered_map` 来解决，这可以减少内存的占用。\n\n我们建立 `unordered_map<string,bool> server_ip_exist` 来表示服务器 IP 是否存在，`unordered_map<string,int> server_id` 来表示服务器 IP 对应的 ID。  \n然后在读入的时候先看看当前输入的 IP 是否存在，然后就可以标记存在和记录 ID 了。\n### 代码\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nunordered_map<string,bool> server_ip_exist;\nunordered_map<string,int> server_id;\nbool check_ip(string ip)\n{\n    int a,b,c,d,e;\n    if(sscanf(ip.c_str(),\"%lld.%lld.%lld.%lld:%lld\",&a,&b,&c,&d,&e)!=5)  return false;\n    if(a<0||a>255||b<0||b>255||c<0||c>255||d<0||d>255||e<0||e>65535)  return false;\n    string now;\n    now=to_string(a)+'.'+to_string(b)+'.'+to_string(c)+'.'+to_string(d)+':'+to_string(e);\n    if(now!=ip)  return false;\n    return true;\n}\nsigned main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        string type,ip;\n        cin>>type>>ip;\n        if(type==\"Server\")\n        {\n            if(server_ip_exist[ip])//服务器 IP 已存在\n            {\n                cout<<\"FAIL\"<<endl;\n                continue;\n            }\n            if(!check_ip(ip))//IP 格式错误\n            {\n                cout<<\"ERR\"<<endl;\n                continue;\n            }\n            server_ip_exist[ip]=true;//标记 IP 存在\n            server_id[ip]=i;//记录 ID\n            cout<<\"OK\"<<endl;\n        }\n        if(type==\"Client\")\n        {\n            if(!check_ip(ip))//IP 格式错误\n            {\n                cout<<\"ERR\"<<endl;\n                continue;\n            }\n            if(!server_ip_exist[ip])//服务器 IP 不存在\n            {\n                cout<<\"FAIL\"<<endl;\n                continue;\n            }\n            cout<<server_id[ip]<<endl;\n        }\n    }\n    exit(0);\n}\n```\n# 知识积累\n## 与或非运算\n这些操作都要在 **二进制下** 完成\n- 按位与：`&`：每一位都必须是 `1` 才会得到 `1`，否则是 `0`\n- 按位或：`|`：每一位只要有一个是 `1` 就会得到 `1`\n- 按位非：`~`：每一位取反\n- 按位异或：`^`：每一位相同为 `0`，不同为 `1`\n\n在数学上，$\\land$ 和 `&&` 是一样的，$\\lor$ 和 `||` 是一样的，$\\neg$ 和 `!` 是一样的  \n这是 **逻辑运算符**，不要混淆\n## （重难点）进制转换\n转换技巧：遇到 x 进制转 y 进制，可以先把 x 进制转为 10 进制，再转为 y 进制\n### x 进制转 10 进制\n{% mark 按位展开，乘权相加 %}  \n例如 $(2F)_{16}$ 转 10 进制：  \n$$\n({\\color{red}2F})_{16}={\\color{red}2}\\times16^{\\color{blue}1}+{\\color{red}15}\\times16^{\\color{blue}0}=32+15=(47)_{10}\n$$\n在上面的式子中，$F$ 其实就是十进制里面的 $15$，这不用多说\n\n如果是带小数的部分，要 {% mark 乘负权相加%}  \n例如 $(A.F)_{16}$ 转 10 进制\n$$\n({\\color{red}A.F})_{16}={\\color{red}10}\\times 16^{\\color{blue}0}+{\\color{red}15}\\times 16^{\\color{blue}-1}=10+\\frac{15}{16^1}=(10.9375)_{10}\n$$\n### 10 进制转 x 进制\n{% mark 不断除以 x，余数倒着写，商循环利用 %}   \n例如 $(47)_{10}$ 转 16 进制\n$$\n47\\div16={\\color{blue}2}\\dots 15({\\color{red}F})\\\\\n{\\color{blue}2}\\div16={\\color{green}0}\\dots {\\color{red}2}\\\\\n\\therefore (47)_{10}=({\\color{red}2F})_{16}\n$$\n\n如果是带小数的转换，整数部分还是和上面相同的，小数部分要 {% mark 不断乘以 x，商取整，顺着写，小数循环利用%}\n例如 $(114.514)_{10}$ 转 8 进制  \n那么我们先算整数部分：\n$$\n114\\div 8={\\color{blue}14}\\dots {\\color{red}2}\\\\\n{\\color{blue}14}\\div 8={\\color{blue}1}\\dots {\\color{red}6}\\\\\n{\\color{blue}1}\\div 8={\\color{green}0}\\dots {\\color{red}1}\\\\\n\\therefore (114)_{10}=({\\color{red}162})_{8}\n$$\n然后算小数部分：\n$$\n0.514\\times 8={\\color{red}4}.{\\color{blue}112}\\\\\n{0.\\color{blue}112}\\times 8={\\color{red}0}.{\\color{blue}912}\\\\\n{0.\\color{blue}912}\\times 8={\\color{red}7}.{\\color{blue}296}\\\\\n\\dots \\\\\n\\therefore (0.514)_{10}=(0.{\\color{red}407})_{8}\n$$\n最后让我们加起来，得到了 $(114.514)_{10}=(162.407)_{8}$  \n如果题目中需要更高的精度，那就继续乘以 8，直到小数部分为 0\n### 常用数字的进制转换\n|十进制|二进制|八进制|十六进制|\n|:-:|:-:|:-:|:-:|\n|0|0000|0|0|\n|1|0001|1|1|\n|2|0010|2|2|\n|...|...|...|...|\n|7|0111|17|7|\n|8|1000|10|8|\n|...|...|...|...|\n|15|1111|17|F|\n|16|10000|20|10|\n|...|...|...|...|\n## 二进制编码\n- 原码：用 {% mark 最高位%} 作为符号位，0是正数，1是负数，符号位之后是这个十进制数的绝对值的二进制，存在 -0 的问题，所以不用\n- 反码：正数和原码相同；负数符号位不变，剩余的 {% mark 在原码基础上按位取反 %}\n- 补码：正数和原码相同；负数就是反码+1（忽略符号位进位）\n## GCD 和 LCM\n- GCD：Greatest Common Divisor，最大公约数\n- LCM：Least Common Multiple，最小公倍数\n- GCD 和 LCM 之间的关系：\n$$\nGCD(a,b)\\times LCM(a,b)=a\\times b\n$$\n- 在 C++14 标准之后（OI 可用），你可以通过 `algorithm` 库中的 `std::__gcd(int,int)` 和 `std::__lcm(int,int)` 来计算 GCD 和 LCM\n- 在 CSP 一轮考场上，可以直接带入选项中的数值去尝试\n## （重难点）排列与组合\n### 排列\n概念：集合 $S$ 由 $n$个不同的元素组成，取出其中的 $r$ 个，{% mark 与顺序有关 %} 的情况数为 $A_n^r$，计算公式为：\n$$\nA_n^r=\\frac{n!}{(n-r)!}\n$$\n例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同也算另一种）  \n那么一共有\n$$\nA_5^2=\\frac{5!}{(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{3\\times2\\times1}=\\frac{120}{6}=20\n$$\n种方案\n\n当 $n=r$ 时，$A_n^r=A_n^n=n!$\n### 组合\n概念：集合 $S$ 由 $n$个不同的元素组成，取出其中的 $r$ 个，{% mark 与顺序无关 %} 的情况数为 $C_n^r$，计算公式为：\n$$\nC_n^r=\\frac{A_n^r}{r!}=\\frac{\\frac{n!}{(n-r)!}}{r!}=\\frac{n!}{r!(n-r)!}\n$$\n例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同只算做同一种）  \n那么一共有\n$$\nC_5^2=\\frac{5!}{2!(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{2\\times1\\times3\\times2\\times1}=\\frac{120}{2\\times6}=10\n$$\n种方案\n\n当 $n=r$ 时，$C_n^r=C_n^n=1$\n### 排列与组合的联系\n$$\nA_n^r=C_n^r\\times A_r^r\\\\\nC_n^r=C_n^{n-r}\\\\\nC_{n+1}^r=C_n^r+C_n^{r-1}\n$$\n### 有重复的排列\n给出具有 $n$ 个对象的集合 $S$，选出 $r$ 个，可以重复选择  \n从第 1 个位置到第 $r$ 个位置，每个位置有 $n$ 种选择，那么一共有 $n^r$ 种方案\n### 有重复的组合（插板法）\n给出具有 $n$ 个对象的集合 $S$，选出 $r$ 个，可以重复选择，与顺序无关  \n最终方案数是 $C_{n+r-1}^r$\n## （重难点）小球与盒子\n你有 $n$ 个小球，要放到 $m$ 个盒子里，每个盒子可以放多个小球，\n### 可辨别的小球与可辨别的盒子\n最终方案数是 $C_{n+m-1}^n$\n### 不可辨别的小球与可辨别的盒子\n盒子可以是空的：$C_{n+m-1}^{m-1}$\n盒子不能是空的：$C_{n-1}^{m-1}$\n\n剩下两种严重超纲，不记（涉及到第二类斯特林数和很多的分类讨论）\n## （易考）树的遍历\n给出前序遍历和中序遍历，可以唯一确定一棵二叉树  \n给出后序遍历和中序遍历，可以唯一确定一棵二叉树\n### 步骤\n1. 前序遍历的第一个元素是根节点，后序遍历的最后一个元素是根节点\n2. 在中序遍历中找到根节点，它的左边是左子树，右边是右子树\n3. 递归构建左子树和右子树\n### 示例\n前序：`ABDECFG`  \n中序：`DBEAFCG`\n\n1. 首先确定 `A` 为根节点\n2. 在中序遍历中找到 `A`，它的左边 `DBE` 是左子树，右边 `FCG` 是右子树\n3. 在前序 `BDE` 和 `CFG` 中得到后序遍历 `DBE` 和 `CFG`\n4. 接上根节点 `A`，得到后序遍历 `DBECFGA`\n\n也可以去 2019 CSP-J1 T14 练习\n## （易考）单位换算\n`M = 1e6`，`K = 1e3`  \n`1B(yte) = 8bit`\n### 二进制存储空间换算\n`1TiB = 2e10GiB = 2e20MiB = 2e30KiB = 2e40B = 2e43bit`  \n$1 TiB = 2^{10} GiB = 2^{20} MiB = 2^{30} KiB = 2^{40} B = 2^{43} bit$\n### 十进制存储空间换算\n`1TB = 1e3GB = 1e6MB = 1e9KB = 1e12B = 8*1e12bit`  \n$1 TB = 10^3 GB = 10^6 MB = 10^9 KB = 10^{12} B = 8\\times10^{12} bit$\n## 文件存储空间\n图片存储空间：$分辨率\\times 位深度(bit)$\n视频存储空间：$单张图大小\\times fps\\times 时长(bit)$\n            $(视频 bps+音频 bps)\\times 时长$（单位根据码率单位而定）\n帧率缩写 fps，码率 bps\n## NOI 历史\n- 第一届 NOI：1984，今年（NOI2025）第 41 届\n- 第一届 IOI：1989\n- 我国 2000 举办第 12 届 IOI\n- 第一届 NOIP：1995，2019 暂停一届\n- 第一届 CSP：2019\n## 网络\n### OSI 七层模型\n1. 物理层：光纤、中继器\n2. 数据链链路层：网卡、交换机、以太网\n3. 网络层：IP、ICMP\n4. 传输层：TCP、UDP\n5. 会话层：SSL、TLS\n6. 表示层：LPP\n7. 应用层：HTTP、FTP、SMTP、POP3\n### 协议\nHTTP：超文本传输协议\nFTP：文件传输协议\nSMTP：收发电子邮件\nPOP3：接收电子邮件\nTCP：三次握手(A->B 质询在线，B->A 返回在线，A->B 返回确认收到)\n### IP 地址\nIPv4：`x.x.x.x`（0<=x<=255）32bit 4B\n- A类地址：`1.0.0.1` ~ `127.255.255.254`\n- B类地址：`128.0.0.1` ~ `191.255.255.254`\n- C类地址：`192.0.0.1` ~ `223.255.255.254`\n\nIPv6：`X:X:X:X:X:X:X:X`（0000<=X<=FFFF）64bit 8B\n## 排序\n### 算法信息\nn=等待排序的个数，w=数据值域\n|算法名称|平均时间|最坏时间|是否稳定|\n|:-:|:-:|:-:|:-:|\n|冒泡排序|$O(n^2)$|$O(n^2)$|true|\n|选择排序|$O(n^2)$|$O(n^2)$|false|\n|插入排序|$O(n^2)$|$O(n^2)$|true|\n|计数排序|$O(n+w)$|$O(n+w)$|true|\n|归并排序|$\\theta(n log n)$|$\\theta(n log n)$|true|\n|快速排序|$O(n log n)$|$O(n^2)$|false|\n### 快速排序原理\n使用递归原理  \n在 a[l]~a[r] 中选择一个基准 x  \n使用双指针将所有 `a[i] < x` 交换到 x 左侧，`a[i] > x` 交换到 x 右侧  \n快速排序通过双指针交换后，将一个大的排序问题划分为了两个子区间排序的小问题  \n所以期望复杂度 $O(n log n)$  \n如果选择第一个数作为基准，序列有序，每次序列长度只减少 1  \n所以最坏复杂度 $O(n^2)$\n### std::sort\n由 algorithm 头文件提供，属于 STL  \n在数据范围较小的情况下，使用了堆排序等技术\n## 数据结构\n### 链表\n优点：插入删除 $O(1)$  \n缺点：读取 $O(n)$ n=链表元素个数\n\n示例：\n```\n[prev = NULL, id = 1, value = 114, next = 514]  \n[prev = 1, id = 514, value = 1919, next = 1919]  \n[prev = 514, id = 1919, value = 810, next = NULL]\n```\n### 图的存储\n#### 邻接矩阵\n优点：查询边权 $O(1)$\n缺点：对于稀疏图，浪费空间\n#### 邻接表\n优点：空间复杂度 $O(|E|)$\n缺点：查询边权 $O(|V|)$\n### 树\n有 $n$ 个节点 $n-1$ 条边的无向连通图\n完整二叉树：每个节点的子节点数量都是 0 或 2\n## 运算优先级\n自增/自减 执行顺序\n\n`++x` 先增加 x 的值，然后送出使用  \n`x++` 先送出使用，然后增加 x 的值  \n\n{% copy ans+=++x; = x=x+1;ans=ans+x; prefix:C++%}\n{% copy ans+=x++; = ans=ans+x;x=x+1; prefix:C++%}\n\n`x++ + ++x`  \n这属于 未定义行为（Undefined Behavior, UB），在不同的编译器上可以解释为任何值。  \n这可能导致本地通过，评测报错  \n可以通过 `-Wall` 参数找到所有的警告\n## 计算原理\n### 容斥原理/减法法则\n如果一个任务可以通过 $n_1$ 种方法执行，还可以通过 $n_2$ 种另一类方法执行，那么执行这个任务的方法数量是 $n_1+n_2-[两种方法中相同的方法]$  \n也就是说，集合 $A_1,A_2$，与并集 $A_1\\cup A_2$，满足 $|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap A_2|$  \n### 鸽巢原理\n如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 2 个或更多的物体\n### 广义鸽巢原理\n如果 $n$ 个物体放入 $k$ 个盒子，那么至少有一个盒子至少包含了 $\\lceil \\frac{n}{k}\\rceil$ 个物体\n## 高级语言分类\n- 面向过程：以函数为基本程序结构：C，Pascal，Fortran\n- 面向对象：以类为基本程序结构：C++，Java，Python\n- 编译性：执行前用连接器生成可执行文件：C++\n- 解释性：一边用解释器翻译，一边运行代码：Python，JS，Ruby\n- Java：编译 + 解释混合\n## 计算机历史\n- 第一台计算机 - ENIAC\n- 有存储功能 - EDVAC\n- 冯诺依曼 - 存储结构\n- 图灵 - 测试\n- 阿达罗福莱斯 - 计算机程序的创始人\n- 马文·明斯基、约翰·麦卡西 - 对 AI 杰出贡献\n- 香农 - 信息论\n## 哈夫曼树\n// TODO\n","slug":"备战CSP-J","published":1,"updated":"2025-08-25T04:41:24.453Z","_id":"cmebjcsv40001c4bo0ak6hy3c","comments":1,"layout":"post","photos":[],"content":"<p>很难很累，但还是必须去做</p>\n<span id=\"more\"></span>\n<h1 id=\"任务清单\"><a class=\"markdownIt-Anchor\" href=\"#任务清单\"></a> 任务清单</h1>\n<h2 id=\"一轮真题\"><a class=\"markdownIt-Anchor\" href=\"#一轮真题\"></a> 一轮真题</h2>\n<p><a href=\"https://ti.luogu.com.cn/problemset/1030\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2019 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1034\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2020 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1036\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2021 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1039\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2022 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1041\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2023 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1043\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2024 CSP-J1</span></div></a></p>\n<h2 id=\"二轮真题\"><a class=\"markdownIt-Anchor\" href=\"#二轮真题\"></a> 二轮真题</h2>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2019 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2020 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2021 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2022 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2023 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2024 CSP-J2</span></div>\n<h1 id=\"题目选讲\"><a class=\"markdownIt-Anchor\" href=\"#题目选讲\"></a> 题目选讲</h1>\n<h2 id=\"2019-csp-j1\"><a class=\"markdownIt-Anchor\" href=\"#2019-csp-j1\"></a> 2019 CSP-J1</h2>\n<h3 id=\"1-常识积累\"><a class=\"markdownIt-Anchor\" href=\"#1-常识积累\"></a> 1. 常识积累</h3>\n<ul>\n<li>T1：中国的国家顶级域名是 <code>.cn</code></li>\n<li>T3：一个 32 位整形变量占用 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">4 个字节</mark></li>\n<li>T5：折半查找（二分）时，找到目标最多需要 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">log(n) 次</mark></li>\n<li>T6：链表在 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">插入和删除</mark> 中表现优异，在 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">查询</mark> 中表现较差，也不必事先估计存储空间</li>\n<li>T9：100 以内的最大质数是 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">97</mark></li>\n<li>T15：计算机科学领域的最高奖是 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">图灵奖</mark></li>\n</ul>\n<h3 id=\"2-数论计算\"><a class=\"markdownIt-Anchor\" href=\"#2-数论计算\"></a> 2. 数论计算</h3>\n<h4 id=\"t7整数划分\"><a class=\"markdownIt-Anchor\" href=\"#t7整数划分\"></a> T7（整数划分）</h4>\n<p>把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 个同样的球放在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？<br />\n提示：如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。</p>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>A. 22</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>B. 24</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>C. 18</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>D. 20</span></div>\n<p>解析：直接暴力枚举，然后去重就没了</p>\n<h4 id=\"t12鸽巢原理\"><a class=\"markdownIt-Anchor\" href=\"#t12鸽巢原理\"></a> T12（鸽巢原理）</h4>\n<p>一副纸牌除掉大小王有 52 张牌，四种花色，每种花色 13 张。<br />\n假设从这 52 张牌中随机抽取 13 张牌，则至少（）张牌的花色一致。</p>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>A. 4</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>B. 2</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>C. 3</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>D. 5</span></div>\n<p>解析：设在 12 张牌中，每种花色 3 张（最坏情况），那么再多一张一定会有 4 张牌的花色一致</p>\n<h4 id=\"t13乘法原理\"><a class=\"markdownIt-Anchor\" href=\"#t13乘法原理\"></a> T13（乘法原理）</h4>\n<p>—些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。<br />\n类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。<br />\n请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（）</p>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>A. 60</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>B. 125</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>C. 75</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>D. 100</span></div>\n<p>解析：在 0,1,8,6,9 中选择，然后判断回文数（因为顺序颠倒之后还要求是原来的车牌），那么我们只需要考虑第 1，2，3 位就好了<br />\n但是颠倒之后 6 和 9 会互换，所以第 3 位不能是 6 和 9<br />\n所以第一、二位有 5 种选择，第三位有 3 种选择，根据乘法原理可得最终方案数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>75</mn></mrow><annotation encoding=\"application/x-tex\">5\\times5\\times3=75</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span><span class=\"mord\">5</span></span></span></span></p>\n<h2 id=\"2024-csp-j2-t2大模拟\"><a class=\"markdownIt-Anchor\" href=\"#2024-csp-j2-t2大模拟\"></a> 2024 CSP-J2 T2（大模拟）</h2>\n<p>题号：<a href=\"https://luogu.com.cn/problem/P11228\">Luogu P11228</a></p>\n<h3 id=\"题意\"><a class=\"markdownIt-Anchor\" href=\"#题意\"></a> 题意</h3>\n<p>给出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 列的地图，机器人初始位于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>，朝向是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>，每次根据当前朝向朝对应方向步进，如果下一步越界或不是空地，那就向右转。问进行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次操作之后，机器人走过的格子数量（包括起始位置）</p>\n<h3 id=\"解析\"><a class=\"markdownIt-Anchor\" href=\"#解析\"></a> 解析</h3>\n<p>依题意模拟，用一个集合记录走过的格子，当机器人操作数等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 时，输出机器人走过的格子数量，然后结束跑下一组数据即可。</p>\n<h3 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//走过的格子标记</span></span><br><span class=\"line\"><span class=\"type\">char</span> mp[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//地图</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));<span class=\"comment\">//重置为都没被访问</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,m,k,x,y,d,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x&gt;&gt;y&gt;&gt;d;</span><br><span class=\"line\">    vis[x][y]=<span class=\"literal\">true</span>;<span class=\"comment\">//起始位置已被访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            cin&gt;&gt;mp[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nxt_x=x+dx[d],nxt_y=y+dy[d];<span class=\"comment\">//计算下一个点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;m||mp[nxt_x][nxt_y]==<span class=\"string\">&#x27;x&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            d=(d<span class=\"number\">+1</span>)%<span class=\"number\">4</span>;<span class=\"comment\">//如果越界或撞墙，就转</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vis[nxt_x][nxt_y]=<span class=\"literal\">true</span>;<span class=\"comment\">//下一个点已被访问</span></span><br><span class=\"line\">        x=nxt_x,y=nxt_y;<span class=\"comment\">//更新到下一个点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//统计走过的格子数量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j])  ans++;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">init</span>();</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2021-csp-j2-t3字符串模拟\"><a class=\"markdownIt-Anchor\" href=\"#2021-csp-j2-t3字符串模拟\"></a> 2021 CSP-J2 T3（字符串+模拟）</h2>\n<h3 id=\"题意-2\"><a class=\"markdownIt-Anchor\" href=\"#题意-2\"></a> 题意</h3>\n<p>给你 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 台机器，分为服务器和客户端。</p>\n<mark class=\"tag-plugin colorful mark\" color=\"yellow\">难点</mark> 然后判断服务器和客户端的 IP（IPv4+端口）是否合法  \n<p>然后服务器的 IP 必须保持唯一<br />\n然后客户端要和对应的 IP 建立连接，按题意输出就好了</p>\n<h3 id=\"解析-2\"><a class=\"markdownIt-Anchor\" href=\"#解析-2\"></a> 解析</h3>\n<p>对于验证 IP 的正确性问题，我们可以将 IP 利用 string 存起来，然后利用 <code>sscanf</code> 这一利器<br />\n<code>sscanf</code> 的用法：<code>sscanf(源字符串,格式字符串,目标变量);</code><br />\n下面是一个示例，从 <code>date</code> 字符串中按照 <code>%d/%d/%d %d:%d:%d</code> 的格式，分别提取到变量 <code>year</code> <code>month</code> <code>day</code> <code>hour</code> <code>minute</code> <code>second</code> 中：<br />\n<code>sscanf(date,&quot;%d/%d/%d %d:%d:%d&quot;,&amp;year,&amp;month,&amp;day,&amp;hour,&amp;minute,&amp;second);</code></p>\n<p><code>sscanf</code> 的返回值是 <strong>成功提取变量的数量</strong>，例如上面那个例子中的正确返回值应该是 6，如果返回值不等于 6，就说明提取失败。<br />\n那么让我们带入到 IP 中，我们需要提取 5 个整数，只要返回值不是 5，立刻返回 <code>false</code> 即可<br />\n又看到字符串的长度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>25</mn></mrow><annotation encoding=\"application/x-tex\">\\le25</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span></span></span></span>，所以最大的整数不超过 17 位，用 <code>long long</code> 存就可以。<br />\n所以我们的一条判断条件就是：<br />\n<code>if(sscanf(ip.c_str(),&quot;%lld.%lld.%lld.%lld:%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e)!=5)  return false;</code></p>\n<p>现在我们提取到了每个整数，接下来就是判断是否合法了，依照题目判断范围即可，这一步不多说了</p>\n<p>然后我们要解决前导 0 的问题。我们可以把我们提取出来的整数拼接回去，拼成一个正确的 IP 地址，然后和读入进来的 IP 进行比较，如果相同就证明没有前导 0。<br />\n我们可以开一个 string，然后加起来就好了。但是因为你的整数化成字符串有点麻烦，你就可以使用 <code>to_string()</code> 函数，这属于 STL 的一种，在 C++11 被引入，OI 使用没问题。<br />\n<code>string now_ip=to_string(a)+'.'+to_string(b)+'.'+to_string(c)+'.'+to_string(d)+':'+to_string(e);</code></p>\n<hr />\n<p>验证 IP 解决了，下面就是连接问题。<br />\n连接过程中，你需要根据客户端请求的 IP 寻找服务器 IP，然后输出对应的 ID 即可。<br />\n这一步我们可以使用 <code>map</code> 或 <code>unordered_map</code> 来解决，这可以减少内存的占用。</p>\n<p>我们建立 <code>unordered_map&lt;string,bool&gt; server_ip_exist</code> 来表示服务器 IP 是否存在，<code>unordered_map&lt;string,int&gt; server_id</code> 来表示服务器 IP 对应的 ID。<br />\n然后在读入的时候先看看当前输入的 IP 是否存在，然后就可以标记存在和记录 ID 了。</p>\n<h3 id=\"代码-2\"><a class=\"markdownIt-Anchor\" href=\"#代码-2\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">unordered_map&lt;string,<span class=\"type\">bool</span>&gt; server_ip_exist;</span><br><span class=\"line\">unordered_map&lt;string,<span class=\"type\">int</span>&gt; server_id;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_ip</span><span class=\"params\">(string ip)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b,c,d,e;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">sscanf</span>(ip.<span class=\"built_in\">c_str</span>(),<span class=\"string\">&quot;%lld.%lld.%lld.%lld:%lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e)!=<span class=\"number\">5</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a&lt;<span class=\"number\">0</span>||a&gt;<span class=\"number\">255</span>||b&lt;<span class=\"number\">0</span>||b&gt;<span class=\"number\">255</span>||c&lt;<span class=\"number\">0</span>||c&gt;<span class=\"number\">255</span>||d&lt;<span class=\"number\">0</span>||d&gt;<span class=\"number\">255</span>||e&lt;<span class=\"number\">0</span>||e&gt;<span class=\"number\">65535</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    string now;</span><br><span class=\"line\">    now=<span class=\"built_in\">to_string</span>(a)+<span class=\"string\">&#x27;.&#x27;</span>+<span class=\"built_in\">to_string</span>(b)+<span class=\"string\">&#x27;.&#x27;</span>+<span class=\"built_in\">to_string</span>(c)+<span class=\"string\">&#x27;.&#x27;</span>+<span class=\"built_in\">to_string</span>(d)+<span class=\"string\">&#x27;:&#x27;</span>+<span class=\"built_in\">to_string</span>(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now!=ip)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string type,ip;</span><br><span class=\"line\">        cin&gt;&gt;type&gt;&gt;ip;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type==<span class=\"string\">&quot;Server&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(server_ip_exist[ip])<span class=\"comment\">//服务器 IP 已存在</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;FAIL&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_ip</span>(ip))<span class=\"comment\">//IP 格式错误</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;ERR&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            server_ip_exist[ip]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记 IP 存在</span></span><br><span class=\"line\">            server_id[ip]=i;<span class=\"comment\">//记录 ID</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;OK&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type==<span class=\"string\">&quot;Client&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_ip</span>(ip))<span class=\"comment\">//IP 格式错误</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;ERR&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!server_ip_exist[ip])<span class=\"comment\">//服务器 IP 不存在</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;FAIL&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout&lt;&lt;server_id[ip]&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"知识积累\"><a class=\"markdownIt-Anchor\" href=\"#知识积累\"></a> 知识积累</h1>\n<h2 id=\"与或非运算\"><a class=\"markdownIt-Anchor\" href=\"#与或非运算\"></a> 与或非运算</h2>\n<p>这些操作都要在 <strong>二进制下</strong> 完成</p>\n<ul>\n<li>按位与：<code>&amp;</code>：每一位都必须是 <code>1</code> 才会得到 <code>1</code>，否则是 <code>0</code></li>\n<li>按位或：<code>|</code>：每一位只要有一个是 <code>1</code> 就会得到 <code>1</code></li>\n<li>按位非：<code>~</code>：每一位取反</li>\n<li>按位异或：<code>^</code>：每一位相同为 <code>0</code>，不同为 <code>1</code></li>\n</ul>\n<p>在数学上，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∧</mo></mrow><annotation encoding=\"application/x-tex\">\\land</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∧</span></span></span></span> 和 <code>&amp;&amp;</code> 是一样的，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∨</mo></mrow><annotation encoding=\"application/x-tex\">\\lor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∨</span></span></span></span> 和 <code>||</code> 是一样的，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi></mrow><annotation encoding=\"application/x-tex\">\\neg</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">¬</span></span></span></span> 和 <code>!</code> 是一样的<br />\n这是 <strong>逻辑运算符</strong>，不要混淆</p>\n<h2 id=\"重难点进制转换\"><a class=\"markdownIt-Anchor\" href=\"#重难点进制转换\"></a> （重难点）进制转换</h2>\n<p>转换技巧：遇到 x 进制转 y 进制，可以先把 x 进制转为 10 进制，再转为 y 进制</p>\n<h3 id=\"x-进制转-10-进制\"><a class=\"markdownIt-Anchor\" href=\"#x-进制转-10-进制\"></a> x 进制转 10 进制</h3>\n<mark class=\"tag-plugin colorful mark\" color=\"yellow\">按位展开，乘权相加</mark>  \n<p>例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>F</mi><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub></mrow><annotation encoding=\"application/x-tex\">(2F)_{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 10 进制：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mn>2</mn><mi>F</mi></mstyle><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub><mo>=</mo><mstyle mathcolor=\"red\"><mn>2</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mn>1</mn></mstyle></msup><mo>+</mo><mstyle mathcolor=\"red\"><mn>15</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mn>0</mn></mstyle></msup><mo>=</mo><mn>32</mn><mo>+</mo><mn>15</mn><mo>=</mo><mo stretchy=\"false\">(</mo><mn>47</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">({\\color{red}2F})_{16}={\\color{red}2}\\times16^{\\color{blue}1}+{\\color{red}15}\\times16^{\\color{blue}0}=32+15=(47)_{10}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9474379999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">5</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>在上面的式子中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> 其实就是十进制里面的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span>，这不用多说</p>\n<p>如果是带小数的部分，要 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">乘负权相加</mark><br />\n例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mi mathvariant=\"normal\">.</mi><mi>F</mi><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub></mrow><annotation encoding=\"application/x-tex\">(A.F)_{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 10 进制</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mi>A</mi><mi mathvariant=\"normal\">.</mi><mi>F</mi></mstyle><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub><mo>=</mo><mstyle mathcolor=\"red\"><mn>10</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mn>0</mn></mstyle></msup><mo>+</mo><mstyle mathcolor=\"red\"><mn>15</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mo>−</mo><mn>1</mn></mstyle></msup><mo>=</mo><mn>10</mn><mo>+</mo><mfrac><mn>15</mn><mrow><mn>1</mn><msup><mn>6</mn><mn>1</mn></msup></mrow></mfrac><mo>=</mo><mo stretchy=\"false\">(</mo><mn>10.9375</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">({\\color{red}A.F})_{16}={\\color{red}10}\\times 16^{\\color{blue}0}+{\\color{red}15}\\times 16^{\\color{blue}-1}=10+\\frac{15}{16^1}=(10.9375)_{10}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"color:red;\">A</span><span class=\"mord\" style=\"color:red;\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">0</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9474379999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">5</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.864108em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.864108em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">−</span><span class=\"mord mtight\" style=\"color:blue;\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.740108em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">9</span><span class=\"mord\">3</span><span class=\"mord\">7</span><span class=\"mord\">5</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"10-进制转-x-进制\"><a class=\"markdownIt-Anchor\" href=\"#10-进制转-x-进制\"></a> 10 进制转 x 进制</h3>\n<mark class=\"tag-plugin colorful mark\" color=\"yellow\">不断除以 x，余数倒着写，商循环利用</mark>   \n<p>例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>47</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">(47)_{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 16 进制</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>47</mn><mo>÷</mo><mn>16</mn><mo>=</mo><mstyle mathcolor=\"blue\"><mn>2</mn></mstyle><mo>…</mo><mn>15</mn><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mi>F</mi></mstyle><mo stretchy=\"false\">)</mo><mspace linebreak=\"newline\"></mspace><mstyle mathcolor=\"blue\"><mn>2</mn></mstyle><mo>÷</mo><mn>16</mn><mo>=</mo><mstyle mathcolor=\"green\"><mn>0</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>2</mn></mstyle><mspace linebreak=\"newline\"></mspace><mo>∴</mo><mo stretchy=\"false\">(</mo><mn>47</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mn>2</mn><mi>F</mi></mstyle><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub></mrow><annotation encoding=\"application/x-tex\">47\\div16={\\color{blue}2}\\dots 15({\\color{red}F})\\\\\n{\\color{blue}2}\\div16={\\color{green}0}\\dots {\\color{red}2}\\\\\n\\therefore (47)_{10}=({\\color{red}2F})_{16}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\">)</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:green;\">0</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69224em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>如果是带小数的转换，整数部分还是和上面相同的，小数部分要 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">不断乘以 x，商取整，顺着写，小数循环利用</mark><br />\n例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>114.514</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">(114.514)_{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 8 进制<br />\n那么我们先算整数部分：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>114</mn><mo>÷</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"blue\"><mn>14</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>2</mn></mstyle><mspace linebreak=\"newline\"></mspace><mstyle mathcolor=\"blue\"><mn>14</mn></mstyle><mo>÷</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"blue\"><mn>1</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>6</mn></mstyle><mspace linebreak=\"newline\"></mspace><mstyle mathcolor=\"blue\"><mn>1</mn></mstyle><mo>÷</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"green\"><mn>0</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>1</mn></mstyle><mspace linebreak=\"newline\"></mspace><mo>∴</mo><mo stretchy=\"false\">(</mo><mn>114</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mn>162</mn></mstyle><msub><mo stretchy=\"false\">)</mo><mn>8</mn></msub></mrow><annotation encoding=\"application/x-tex\">114\\div 8={\\color{blue}14}\\dots {\\color{red}2}\\\\\n{\\color{blue}14}\\div 8={\\color{blue}1}\\dots {\\color{red}6}\\\\\n{\\color{blue}1}\\div 8={\\color{green}0}\\dots {\\color{red}1}\\\\\n\\therefore (114)_{10}=({\\color{red}162})_{8}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">4</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">4</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">6</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:green;\">0</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69224em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">6</span><span class=\"mord\" style=\"color:red;\">2</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>然后算小数部分：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>0.514</mn><mo>×</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"red\"><mn>4</mn></mstyle><mi mathvariant=\"normal\">.</mi><mstyle mathcolor=\"blue\"><mn>112</mn></mstyle><mspace linebreak=\"newline\"></mspace><mrow><mn>0.</mn><mstyle mathcolor=\"blue\"><mn>112</mn></mstyle></mrow><mo>×</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"red\"><mn>0</mn></mstyle><mi mathvariant=\"normal\">.</mi><mstyle mathcolor=\"blue\"><mn>912</mn></mstyle><mspace linebreak=\"newline\"></mspace><mrow><mn>0.</mn><mstyle mathcolor=\"blue\"><mn>912</mn></mstyle></mrow><mo>×</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"red\"><mn>7</mn></mstyle><mi mathvariant=\"normal\">.</mi><mstyle mathcolor=\"blue\"><mn>296</mn></mstyle><mspace linebreak=\"newline\"></mspace><mo>…</mo><mspace linebreak=\"newline\"></mspace><mo>∴</mo><mo stretchy=\"false\">(</mo><mn>0.514</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0.</mn><mstyle mathcolor=\"red\"><mn>407</mn></mstyle><msub><mo stretchy=\"false\">)</mo><mn>8</mn></msub></mrow><annotation encoding=\"application/x-tex\">0.514\\times 8={\\color{red}4}.{\\color{blue}112}\\\\\n{0.\\color{blue}112}\\times 8={\\color{red}0}.{\\color{blue}912}\\\\\n{0.\\color{blue}912}\\times 8={\\color{red}7}.{\\color{blue}296}\\\\\n\\dots \\\\\n\\therefore (0.514)_{10}=(0.{\\color{red}407})_{8}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">4</span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">0</span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">9</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\" style=\"color:blue;\">9</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">7</span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">2</span><span class=\"mord\" style=\"color:blue;\">9</span><span class=\"mord\" style=\"color:blue;\">6</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.12em;vertical-align:0em;\"></span><span class=\"minner\">…</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69224em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">4</span><span class=\"mord\" style=\"color:red;\">0</span><span class=\"mord\" style=\"color:red;\">7</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>最后让我们加起来，得到了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>114.514</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mn>162.407</mn><msub><mo stretchy=\"false\">)</mo><mn>8</mn></msub></mrow><annotation encoding=\"application/x-tex\">(114.514)_{10}=(162.407)_{8}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">4</span><span class=\"mord\">0</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br />\n如果题目中需要更高的精度，那就继续乘以 8，直到小数部分为 0</p>\n<h3 id=\"常用数字的进制转换\"><a class=\"markdownIt-Anchor\" href=\"#常用数字的进制转换\"></a> 常用数字的进制转换</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">八进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0000</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0001</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">0010</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">0111</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二进制编码\"><a class=\"markdownIt-Anchor\" href=\"#二进制编码\"></a> 二进制编码</h2>\n<ul>\n<li>原码：用 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">最高位</mark> 作为符号位，0是正数，1是负数，符号位之后是这个十进制数的绝对值的二进制，存在 -0 的问题，所以不用</li>\n<li>反码：正数和原码相同；负数符号位不变，剩余的 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">在原码基础上按位取反</mark></li>\n<li>补码：正数和原码相同；负数就是反码+1（忽略符号位进位）</li>\n</ul>\n<h2 id=\"gcd-和-lcm\"><a class=\"markdownIt-Anchor\" href=\"#gcd-和-lcm\"></a> GCD 和 LCM</h2>\n<ul>\n<li>GCD：Greatest Common Divisor，最大公约数</li>\n<li>LCM：Least Common Multiple，最小公倍数</li>\n<li>GCD 和 LCM 之间的关系：</li>\n</ul>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>G</mi><mi>C</mi><mi>D</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>L</mi><mi>C</mi><mi>M</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">GCD(a,b)\\times LCM(a,b)=a\\times b\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span></p>\n<ul>\n<li>在 C++14 标准之后（OI 可用），你可以通过 <code>algorithm</code> 库中的 <code>std::__gcd(int,int)</code> 和 <code>std::__lcm(int,int)</code> 来计算 GCD 和 LCM</li>\n<li>在 CSP 一轮考场上，可以直接带入选项中的数值去尝试</li>\n</ul>\n<h2 id=\"重难点排列与组合\"><a class=\"markdownIt-Anchor\" href=\"#重难点排列与组合\"></a> （重难点）排列与组合</h2>\n<h3 id=\"排列\"><a class=\"markdownIt-Anchor\" href=\"#排列\"></a> 排列</h3>\n<p>概念：集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>个不同的元素组成，取出其中的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，<mark class=\"tag-plugin colorful mark\" color=\"yellow\">与顺序有关</mark> 的情况数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">A_n^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>，计算公式为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">A_n^r=\\frac{n!}{(n-r)!}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同也算另一种）<br />\n那么一共有</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>A</mi><mn>5</mn><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mn>5</mn><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mn>5</mn><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>5</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><mrow><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>120</mn><mn>6</mn></mfrac><mo>=</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">A_5^2=\\frac{5!}{(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{3\\times2\\times1}=\\frac{120}{6}=20\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1111079999999998em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.09077em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">6</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span></span></p>\n<p>种方案</p>\n<p>当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">n=r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>A</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">A_n^r=A_n^n=n!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span></p>\n<h3 id=\"组合\"><a class=\"markdownIt-Anchor\" href=\"#组合\"></a> 组合</h3>\n<p>概念：集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>个不同的元素组成，取出其中的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，<mark class=\"tag-plugin colorful mark\" color=\"yellow\">与顺序无关</mark> 的情况数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">C_n^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>，计算公式为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><mfrac><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mrow><mi>r</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mrow><mi>r</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><mrow><mi>r</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">C_n^r=\\frac{A_n^r}{r!}=\\frac{\\frac{n!}{(n-r)!}}{r!}=\\frac{n!}{r!(n-r)!}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.476108em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.790108em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose mtight\">)</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同只算做同一种）<br />\n那么一共有</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>C</mi><mn>5</mn><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mn>5</mn><mo stretchy=\"false\">!</mo></mrow><mrow><mn>2</mn><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>5</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>120</mn><mrow><mn>2</mn><mo>×</mo><mn>6</mn></mrow></mfrac><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">C_5^2=\\frac{5!}{2!(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{2\\times1\\times3\\times2\\times1}=\\frac{120}{2\\times6}=10\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1111079999999998em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.09077em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.09077em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">6</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span></span></p>\n<p>种方案</p>\n<p>当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">n=r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">C_n^r=C_n^n=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<h3 id=\"排列与组合的联系\"><a class=\"markdownIt-Anchor\" href=\"#排列与组合的联系\"></a> 排列与组合的联系</h3>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>×</mo><msubsup><mi>A</mi><mi>r</mi><mi>r</mi></msubsup><mspace linebreak=\"newline\"></mspace><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mrow><mi>n</mi><mo>−</mo><mi>r</mi></mrow></msubsup><mspace linebreak=\"newline\"></mspace><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>+</mo><msubsup><mi>C</mi><mi>n</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">A_n^r=C_n^r\\times A_r^r\\\\\nC_n^r=C_n^{n-r}\\\\\nC_{n+1}^r=C_n^r+C_n^{r-1}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.068331em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8213309999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1.019723em;vertical-align:-0.305331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1130000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.305331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1111079999999998em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"有重复的排列\"><a class=\"markdownIt-Anchor\" href=\"#有重复的排列\"></a> 有重复的排列</h3>\n<p>给出具有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个对象的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，选出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，可以重复选择<br />\n从第 1 个位置到第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个位置，每个位置有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 种选择，那么一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mi>r</mi></msup></mrow><annotation encoding=\"application/x-tex\">n^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span> 种方案</p>\n<h3 id=\"有重复的组合插板法\"><a class=\"markdownIt-Anchor\" href=\"#有重复的组合插板法\"></a> 有重复的组合（插板法）</h3>\n<p>给出具有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个对象的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，选出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，可以重复选择，与顺序无关<br />\n最终方案数是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><mi>r</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n+r-1}^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9897689999999999em;vertical-align:-0.30643899999999996em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6643919999999999em;\"><span style=\"top:-2.451892em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30643899999999996em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<h2 id=\"重难点小球与盒子\"><a class=\"markdownIt-Anchor\" href=\"#重难点小球与盒子\"></a> （重难点）小球与盒子</h2>\n<p>你有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个小球，要放到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个盒子里，每个盒子可以放多个小球，</p>\n<h3 id=\"可辨别的小球与可辨别的盒子\"><a class=\"markdownIt-Anchor\" href=\"#可辨别的小球与可辨别的盒子\"></a> 可辨别的小球与可辨别的盒子</h3>\n<p>最终方案数是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n+m-1}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9897689999999999em;vertical-align:-0.30643899999999996em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6643919999999999em;\"><span style=\"top:-2.451892em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30643899999999996em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"不可辨别的小球与可辨别的盒子\"><a class=\"markdownIt-Anchor\" href=\"#不可辨别的小球与可辨别的盒子\"></a> 不可辨别的小球与可辨别的盒子</h3>\n<p>盒子可以是空的：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n+m-1}^{m-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.178878em;vertical-align:-0.324639em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.324639em;\"><span></span></span></span></span></span></span></span></span></span><br />\n盒子不能是空的：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n-1}^{m-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.178878em;vertical-align:-0.324639em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.324639em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>剩下两种严重超纲，不记（涉及到第二类斯特林数和很多的分类讨论）</p>\n<h2 id=\"易考树的遍历\"><a class=\"markdownIt-Anchor\" href=\"#易考树的遍历\"></a> （易考）树的遍历</h2>\n<p>给出前序遍历和中序遍历，可以唯一确定一棵二叉树<br />\n给出后序遍历和中序遍历，可以唯一确定一棵二叉树</p>\n<h3 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"#步骤\"></a> 步骤</h3>\n<ol>\n<li>前序遍历的第一个元素是根节点，后序遍历的最后一个元素是根节点</li>\n<li>在中序遍历中找到根节点，它的左边是左子树，右边是右子树</li>\n<li>递归构建左子树和右子树</li>\n</ol>\n<h3 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\"></a> 示例</h3>\n<p>前序：<code>ABDECFG</code><br />\n中序：<code>DBEAFCG</code></p>\n<ol>\n<li>首先确定 <code>A</code> 为根节点</li>\n<li>在中序遍历中找到 <code>A</code>，它的左边 <code>DBE</code> 是左子树，右边 <code>FCG</code> 是右子树</li>\n<li>在前序 <code>BDE</code> 和 <code>CFG</code> 中得到后序遍历 <code>DBE</code> 和 <code>CFG</code></li>\n<li>接上根节点 <code>A</code>，得到后序遍历 <code>DBECFGA</code></li>\n</ol>\n<p>也可以去 2019 CSP-J1 T14 练习</p>\n<h2 id=\"易考单位换算\"><a class=\"markdownIt-Anchor\" href=\"#易考单位换算\"></a> （易考）单位换算</h2>\n<p><code>M = 1e6</code>，<code>K = 1e3</code><br />\n<code>1B(yte) = 8bit</code></p>\n<h3 id=\"二进制存储空间换算\"><a class=\"markdownIt-Anchor\" href=\"#二进制存储空间换算\"></a> 二进制存储空间换算</h3>\n<p><code>1TiB = 2e10GiB = 2e20MiB = 2e30KiB = 2e40B = 2e43bit</code><br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi>T</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>G</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup><mi>M</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>30</mn></msup><mi>K</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>40</mn></msup><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>43</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">1 TiB = 2^{10} GiB = 2^{20} MiB = 2^{30} KiB = 2^{40} B = 2^{43} bit</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span></span></span></span></p>\n<h3 id=\"十进制存储空间换算\"><a class=\"markdownIt-Anchor\" href=\"#十进制存储空间换算\"></a> 十进制存储空间换算</h3>\n<p><code>1TB = 1e3GB = 1e6MB = 1e9KB = 1e12B = 8*1e12bit</code><br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi>T</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>G</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mi>M</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mi>K</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi>B</mi><mo>=</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">1 TB = 10^3 GB = 10^6 MB = 10^9 KB = 10^{12} B = 8\\times10^{12} bit</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span></span></span></span></p>\n<h2 id=\"文件存储空间\"><a class=\"markdownIt-Anchor\" href=\"#文件存储空间\"></a> 文件存储空间</h2>\n<p>图片存储空间：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>分辨率</mtext><mo>×</mo><mtext>位深度</mtext><mo stretchy=\"false\">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">分辨率\\times 位深度(bit)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">分</span><span class=\"mord cjk_fallback\">辨</span><span class=\"mord cjk_fallback\">率</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">深</span><span class=\"mord cjk_fallback\">度</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><br />\n视频存储空间：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>单张图大小</mtext><mo>×</mo><mi>f</mi><mi>p</mi><mi>s</mi><mo>×</mo><mtext>时长</mtext><mo stretchy=\"false\">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">单张图大小\\times fps\\times 时长(bit)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">单</span><span class=\"mord cjk_fallback\">张</span><span class=\"mord cjk_fallback\">图</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">长</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mtext>视频</mtext><mi>b</mi><mi>p</mi><mi>s</mi><mo>+</mo><mtext>音频</mtext><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mtext>时长</mtext></mrow><annotation encoding=\"application/x-tex\">(视频 bps+音频 bps)\\times 时长</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">视</span><span class=\"mord cjk_fallback\">频</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">音</span><span class=\"mord cjk_fallback\">频</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">长</span></span></span></span>（单位根据码率单位而定）<br />\n帧率缩写 fps，码率 bps</p>\n<h2 id=\"noi-历史\"><a class=\"markdownIt-Anchor\" href=\"#noi-历史\"></a> NOI 历史</h2>\n<ul>\n<li>第一届 NOI：1984，今年（NOI2025）第 41 届</li>\n<li>第一届 IOI：1989</li>\n<li>我国 2000 举办第 12 届 IOI</li>\n<li>第一届 NOIP：1995，2019 暂停一届</li>\n<li>第一届 CSP：2019</li>\n</ul>\n<h2 id=\"网络\"><a class=\"markdownIt-Anchor\" href=\"#网络\"></a> 网络</h2>\n<h3 id=\"osi-七层模型\"><a class=\"markdownIt-Anchor\" href=\"#osi-七层模型\"></a> OSI 七层模型</h3>\n<ol>\n<li>物理层：光纤、中继器</li>\n<li>数据链链路层：网卡、交换机、以太网</li>\n<li>网络层：IP、ICMP</li>\n<li>传输层：TCP、UDP</li>\n<li>会话层：SSL、TLS</li>\n<li>表示层：LPP</li>\n<li>应用层：HTTP、FTP、SMTP、POP3</li>\n</ol>\n<h3 id=\"协议\"><a class=\"markdownIt-Anchor\" href=\"#协议\"></a> 协议</h3>\n<p>HTTP：超文本传输协议<br />\nFTP：文件传输协议<br />\nSMTP：收发电子邮件<br />\nPOP3：接收电子邮件<br />\nTCP：三次握手(A-&gt;B 质询在线，B-&gt;A 返回在线，A-&gt;B 返回确认收到)</p>\n<h3 id=\"ip-地址\"><a class=\"markdownIt-Anchor\" href=\"#ip-地址\"></a> IP 地址</h3>\n<p>IPv4：<code>x.x.x.x</code>（0&lt;=x&lt;=255）32bit 4B</p>\n<ul>\n<li>A类地址：<code>1.0.0.1</code> ~ <code>127.255.255.254</code></li>\n<li>B类地址：<code>128.0.0.1</code> ~ <code>191.255.255.254</code></li>\n<li>C类地址：<code>192.0.0.1</code> ~ <code>223.255.255.254</code></li>\n</ul>\n<p>IPv6：<code>X:X:X:X:X:X:X:X</code>（0000&lt;=X&lt;=FFFF）64bit 8B</p>\n<h2 id=\"排序\"><a class=\"markdownIt-Anchor\" href=\"#排序\"></a> 排序</h2>\n<h3 id=\"算法信息\"><a class=\"markdownIt-Anchor\" href=\"#算法信息\"></a> 算法信息</h3>\n<p>n=等待排序的个数，w=数据值域</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法名称</th>\n<th style=\"text-align:center\">平均时间</th>\n<th style=\"text-align:center\">最坏时间</th>\n<th style=\"text-align:center\">是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">冒泡排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">选择排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">计数排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">归并排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\theta(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\theta(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">快速排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"快速排序原理\"><a class=\"markdownIt-Anchor\" href=\"#快速排序原理\"></a> 快速排序原理</h3>\n<p>使用递归原理<br />\n在 a[l]~a[r] 中选择一个基准 x<br />\n使用双指针将所有 <code>a[i] &lt; x</code> 交换到 x 左侧，<code>a[i] &gt; x</code> 交换到 x 右侧<br />\n快速排序通过双指针交换后，将一个大的排序问题划分为了两个子区间排序的小问题<br />\n所以期望复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n如果选择第一个数作为基准，序列有序，每次序列长度只减少 1<br />\n所以最坏复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"stdsort\"><a class=\"markdownIt-Anchor\" href=\"#stdsort\"></a> std::sort</h3>\n<p>由 algorithm 头文件提供，属于 STL<br />\n在数据范围较小的情况下，使用了堆排序等技术</p>\n<h2 id=\"数据结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构\"></a> 数据结构</h2>\n<h3 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h3>\n<p>优点：插入删除 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n缺点：读取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> n=链表元素个数</p>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[prev = NULL, <span class=\"built_in\">id</span> = <span class=\"number\">1</span>, value = <span class=\"number\">114</span>, <span class=\"built_in\">next</span> = <span class=\"number\">514</span>]  </span><br><span class=\"line\">[prev = <span class=\"number\">1</span>, <span class=\"built_in\">id</span> = <span class=\"number\">514</span>, value = <span class=\"number\">1919</span>, <span class=\"built_in\">next</span> = <span class=\"number\">1919</span>]  </span><br><span class=\"line\">[prev = <span class=\"number\">514</span>, <span class=\"built_in\">id</span> = <span class=\"number\">1919</span>, value = <span class=\"number\">810</span>, <span class=\"built_in\">next</span> = NULL]</span><br></pre></td></tr></table></figure>\n<h3 id=\"图的存储\"><a class=\"markdownIt-Anchor\" href=\"#图的存储\"></a> 图的存储</h3>\n<h4 id=\"邻接矩阵\"><a class=\"markdownIt-Anchor\" href=\"#邻接矩阵\"></a> 邻接矩阵</h4>\n<p>优点：查询边权 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n缺点：对于稀疏图，浪费空间</p>\n<h4 id=\"邻接表\"><a class=\"markdownIt-Anchor\" href=\"#邻接表\"></a> 邻接表</h4>\n<p>优点：空间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span><br />\n缺点：查询边权 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"树\"><a class=\"markdownIt-Anchor\" href=\"#树\"></a> 树</h3>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边的无向连通图<br />\n完整二叉树：每个节点的子节点数量都是 0 或 2</p>\n<h2 id=\"运算优先级\"><a class=\"markdownIt-Anchor\" href=\"#运算优先级\"></a> 运算优先级</h2>\n<p>自增/自减 执行顺序</p>\n<p><code>++x</code> 先增加 x 的值，然后送出使用<br />\n<code>x++</code> 先送出使用，然后增加 x 的值</p>\n<div class=\"tag-plugin copy\"><span>C++</span><input class=\"copy-area\" id=\"copy_1\" value=\"ans+=++x; = x=x+1;ans=ans+x;\"><button class=\"copy-btn\" onclick=\"util.copy(&quot;copy_1&quot;,&quot;复制成功&quot;)\"><svg class=\"icon copy-btn\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z\"></path></svg></button></div>\n<div class=\"tag-plugin copy\"><span>C++</span><input class=\"copy-area\" id=\"copy_2\" value=\"ans+=x++; = ans=ans+x;x=x+1;\"><button class=\"copy-btn\" onclick=\"util.copy(&quot;copy_2&quot;,&quot;复制成功&quot;)\"><svg class=\"icon copy-btn\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z\"></path></svg></button></div>\n<p><code>x++ + ++x</code><br />\n这属于 未定义行为（Undefined Behavior, UB），在不同的编译器上可以解释为任何值。<br />\n这可能导致本地通过，评测报错<br />\n可以通过 <code>-Wall</code> 参数找到所有的警告</p>\n<h2 id=\"计算原理\"><a class=\"markdownIt-Anchor\" href=\"#计算原理\"></a> 计算原理</h2>\n<h3 id=\"容斥原理减法法则\"><a class=\"markdownIt-Anchor\" href=\"#容斥原理减法法则\"></a> 容斥原理/减法法则</h3>\n<p>如果一个任务可以通过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 种方法执行，还可以通过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 种另一类方法执行，那么执行这个任务的方法数量是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>−</mo><mo stretchy=\"false\">[</mo><mtext>两种方法中相同的方法</mtext><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">n_1+n_2-[两种方法中相同的方法]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord cjk_fallback\">两</span><span class=\"mord cjk_fallback\">种</span><span class=\"mord cjk_fallback\">方</span><span class=\"mord cjk_fallback\">法</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">相</span><span class=\"mord cjk_fallback\">同</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">方</span><span class=\"mord cjk_fallback\">法</span><span class=\"mclose\">]</span></span></span></span><br />\n也就是说，集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_1,A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，与并集 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_1\\cup A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>−</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap A_2|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span></p>\n<h3 id=\"鸽巢原理\"><a class=\"markdownIt-Anchor\" href=\"#鸽巢原理\"></a> 鸽巢原理</h3>\n<p>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个或更多的物体放入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个盒子，那么至少有一个盒子包含了 2 个或更多的物体</p>\n<h3 id=\"广义鸽巢原理\"><a class=\"markdownIt-Anchor\" href=\"#广义鸽巢原理\"></a> 广义鸽巢原理</h3>\n<p>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个物体放入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个盒子，那么至少有一个盒子至少包含了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mfrac><mi>n</mi><mi>k</mi></mfrac><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil \\frac{n}{k}\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌉</span></span></span></span> 个物体</p>\n<h2 id=\"高级语言分类\"><a class=\"markdownIt-Anchor\" href=\"#高级语言分类\"></a> 高级语言分类</h2>\n<ul>\n<li>面向过程：以函数为基本程序结构：C，Pascal，Fortran</li>\n<li>面向对象：以类为基本程序结构：C++，Java，Python</li>\n<li>编译性：执行前用连接器生成可执行文件：C++</li>\n<li>解释性：一边用解释器翻译，一边运行代码：Python，JS，Ruby</li>\n<li>Java：编译 + 解释混合</li>\n</ul>\n<h2 id=\"计算机历史\"><a class=\"markdownIt-Anchor\" href=\"#计算机历史\"></a> 计算机历史</h2>\n<ul>\n<li>第一台计算机 - ENIAC</li>\n<li>有存储功能 - EDVAC</li>\n<li>冯诺依曼 - 存储结构</li>\n<li>图灵 - 测试</li>\n<li>阿达罗福莱斯 - 计算机程序的创始人</li>\n<li>马文·明斯基、约翰·麦卡西 - 对 AI 杰出贡献</li>\n<li>香农 - 信息论</li>\n</ul>\n<h2 id=\"哈夫曼树\"><a class=\"markdownIt-Anchor\" href=\"#哈夫曼树\"></a> 哈夫曼树</h2>\n<p>// TODO</p>\n","excerpt":"<p>很难很累，但还是必须去做</p>","more":"<h1 id=\"任务清单\"><a class=\"markdownIt-Anchor\" href=\"#任务清单\"></a> 任务清单</h1>\n<h2 id=\"一轮真题\"><a class=\"markdownIt-Anchor\" href=\"#一轮真题\"></a> 一轮真题</h2>\n<p><a href=\"https://ti.luogu.com.cn/problemset/1030\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2019 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1034\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2020 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1036\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2021 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1039\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2022 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1041\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2023 CSP-J1</span></div></a><br />\n<a href=\"https://ti.luogu.com.cn/problemset/1043\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>2024 CSP-J1</span></div></a></p>\n<h2 id=\"二轮真题\"><a class=\"markdownIt-Anchor\" href=\"#二轮真题\"></a> 二轮真题</h2>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2019 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2020 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2021 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2022 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2023 CSP-J2</span></div>\n<div class=\"tag-plugin colorful checkbox\" color=\"yellow\" symbol=\"minus\"><input type=\"checkbox\" checked=\"true\"/><span>2024 CSP-J2</span></div>\n<h1 id=\"题目选讲\"><a class=\"markdownIt-Anchor\" href=\"#题目选讲\"></a> 题目选讲</h1>\n<h2 id=\"2019-csp-j1\"><a class=\"markdownIt-Anchor\" href=\"#2019-csp-j1\"></a> 2019 CSP-J1</h2>\n<h3 id=\"1-常识积累\"><a class=\"markdownIt-Anchor\" href=\"#1-常识积累\"></a> 1. 常识积累</h3>\n<ul>\n<li>T1：中国的国家顶级域名是 <code>.cn</code></li>\n<li>T3：一个 32 位整形变量占用 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">4 个字节</mark></li>\n<li>T5：折半查找（二分）时，找到目标最多需要 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">log(n) 次</mark></li>\n<li>T6：链表在 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">插入和删除</mark> 中表现优异，在 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">查询</mark> 中表现较差，也不必事先估计存储空间</li>\n<li>T9：100 以内的最大质数是 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">97</mark></li>\n<li>T15：计算机科学领域的最高奖是 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">图灵奖</mark></li>\n</ul>\n<h3 id=\"2-数论计算\"><a class=\"markdownIt-Anchor\" href=\"#2-数论计算\"></a> 2. 数论计算</h3>\n<h4 id=\"t7整数划分\"><a class=\"markdownIt-Anchor\" href=\"#t7整数划分\"></a> T7（整数划分）</h4>\n<p>把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 个同样的球放在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？<br />\n提示：如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span> 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。</p>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>A. 22</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>B. 24</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>C. 18</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>D. 20</span></div>\n<p>解析：直接暴力枚举，然后去重就没了</p>\n<h4 id=\"t12鸽巢原理\"><a class=\"markdownIt-Anchor\" href=\"#t12鸽巢原理\"></a> T12（鸽巢原理）</h4>\n<p>一副纸牌除掉大小王有 52 张牌，四种花色，每种花色 13 张。<br />\n假设从这 52 张牌中随机抽取 13 张牌，则至少（）张牌的花色一致。</p>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>A. 4</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>B. 2</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>C. 3</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>D. 5</span></div>\n<p>解析：设在 12 张牌中，每种花色 3 张（最坏情况），那么再多一张一定会有 4 张牌的花色一致</p>\n<h4 id=\"t13乘法原理\"><a class=\"markdownIt-Anchor\" href=\"#t13乘法原理\"></a> T13（乘法原理）</h4>\n<p>—些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。<br />\n类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。<br />\n请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（）</p>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>A. 60</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>B. 125</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\" checked=\"true\"/><span>C. 75</span></div>\n<div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>D. 100</span></div>\n<p>解析：在 0,1,8,6,9 中选择，然后判断回文数（因为顺序颠倒之后还要求是原来的车牌），那么我们只需要考虑第 1，2，3 位就好了<br />\n但是颠倒之后 6 和 9 会互换，所以第 3 位不能是 6 和 9<br />\n所以第一、二位有 5 种选择，第三位有 3 种选择，根据乘法原理可得最终方案数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>75</mn></mrow><annotation encoding=\"application/x-tex\">5\\times5\\times3=75</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span><span class=\"mord\">5</span></span></span></span></p>\n<h2 id=\"2024-csp-j2-t2大模拟\"><a class=\"markdownIt-Anchor\" href=\"#2024-csp-j2-t2大模拟\"></a> 2024 CSP-J2 T2（大模拟）</h2>\n<p>题号：<a href=\"https://luogu.com.cn/problem/P11228\">Luogu P11228</a></p>\n<h3 id=\"题意\"><a class=\"markdownIt-Anchor\" href=\"#题意\"></a> 题意</h3>\n<p>给出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 列的地图，机器人初始位于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>，朝向是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>，每次根据当前朝向朝对应方向步进，如果下一步越界或不是空地，那就向右转。问进行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 次操作之后，机器人走过的格子数量（包括起始位置）</p>\n<h3 id=\"解析\"><a class=\"markdownIt-Anchor\" href=\"#解析\"></a> 解析</h3>\n<p>依题意模拟，用一个集合记录走过的格子，当机器人操作数等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 时，输出机器人走过的格子数量，然后结束跑下一组数据即可。</p>\n<h3 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//走过的格子标记</span></span><br><span class=\"line\"><span class=\"type\">char</span> mp[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//地图</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));<span class=\"comment\">//重置为都没被访问</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,m,k,x,y,d,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x&gt;&gt;y&gt;&gt;d;</span><br><span class=\"line\">    vis[x][y]=<span class=\"literal\">true</span>;<span class=\"comment\">//起始位置已被访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            cin&gt;&gt;mp[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nxt_x=x+dx[d],nxt_y=y+dy[d];<span class=\"comment\">//计算下一个点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;m||mp[nxt_x][nxt_y]==<span class=\"string\">&#x27;x&#x27;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            d=(d<span class=\"number\">+1</span>)%<span class=\"number\">4</span>;<span class=\"comment\">//如果越界或撞墙，就转</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vis[nxt_x][nxt_y]=<span class=\"literal\">true</span>;<span class=\"comment\">//下一个点已被访问</span></span><br><span class=\"line\">        x=nxt_x,y=nxt_y;<span class=\"comment\">//更新到下一个点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//统计走过的格子数量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j])  ans++;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">init</span>();</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2021-csp-j2-t3字符串模拟\"><a class=\"markdownIt-Anchor\" href=\"#2021-csp-j2-t3字符串模拟\"></a> 2021 CSP-J2 T3（字符串+模拟）</h2>\n<h3 id=\"题意-2\"><a class=\"markdownIt-Anchor\" href=\"#题意-2\"></a> 题意</h3>\n<p>给你 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 台机器，分为服务器和客户端。</p>\n<mark class=\"tag-plugin colorful mark\" color=\"yellow\">难点</mark> 然后判断服务器和客户端的 IP（IPv4+端口）是否合法  \n<p>然后服务器的 IP 必须保持唯一<br />\n然后客户端要和对应的 IP 建立连接，按题意输出就好了</p>\n<h3 id=\"解析-2\"><a class=\"markdownIt-Anchor\" href=\"#解析-2\"></a> 解析</h3>\n<p>对于验证 IP 的正确性问题，我们可以将 IP 利用 string 存起来，然后利用 <code>sscanf</code> 这一利器<br />\n<code>sscanf</code> 的用法：<code>sscanf(源字符串,格式字符串,目标变量);</code><br />\n下面是一个示例，从 <code>date</code> 字符串中按照 <code>%d/%d/%d %d:%d:%d</code> 的格式，分别提取到变量 <code>year</code> <code>month</code> <code>day</code> <code>hour</code> <code>minute</code> <code>second</code> 中：<br />\n<code>sscanf(date,&quot;%d/%d/%d %d:%d:%d&quot;,&amp;year,&amp;month,&amp;day,&amp;hour,&amp;minute,&amp;second);</code></p>\n<p><code>sscanf</code> 的返回值是 <strong>成功提取变量的数量</strong>，例如上面那个例子中的正确返回值应该是 6，如果返回值不等于 6，就说明提取失败。<br />\n那么让我们带入到 IP 中，我们需要提取 5 个整数，只要返回值不是 5，立刻返回 <code>false</code> 即可<br />\n又看到字符串的长度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>25</mn></mrow><annotation encoding=\"application/x-tex\">\\le25</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span></span></span></span>，所以最大的整数不超过 17 位，用 <code>long long</code> 存就可以。<br />\n所以我们的一条判断条件就是：<br />\n<code>if(sscanf(ip.c_str(),&quot;%lld.%lld.%lld.%lld:%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e)!=5)  return false;</code></p>\n<p>现在我们提取到了每个整数，接下来就是判断是否合法了，依照题目判断范围即可，这一步不多说了</p>\n<p>然后我们要解决前导 0 的问题。我们可以把我们提取出来的整数拼接回去，拼成一个正确的 IP 地址，然后和读入进来的 IP 进行比较，如果相同就证明没有前导 0。<br />\n我们可以开一个 string，然后加起来就好了。但是因为你的整数化成字符串有点麻烦，你就可以使用 <code>to_string()</code> 函数，这属于 STL 的一种，在 C++11 被引入，OI 使用没问题。<br />\n<code>string now_ip=to_string(a)+'.'+to_string(b)+'.'+to_string(c)+'.'+to_string(d)+':'+to_string(e);</code></p>\n<hr />\n<p>验证 IP 解决了，下面就是连接问题。<br />\n连接过程中，你需要根据客户端请求的 IP 寻找服务器 IP，然后输出对应的 ID 即可。<br />\n这一步我们可以使用 <code>map</code> 或 <code>unordered_map</code> 来解决，这可以减少内存的占用。</p>\n<p>我们建立 <code>unordered_map&lt;string,bool&gt; server_ip_exist</code> 来表示服务器 IP 是否存在，<code>unordered_map&lt;string,int&gt; server_id</code> 来表示服务器 IP 对应的 ID。<br />\n然后在读入的时候先看看当前输入的 IP 是否存在，然后就可以标记存在和记录 ID 了。</p>\n<h3 id=\"代码-2\"><a class=\"markdownIt-Anchor\" href=\"#代码-2\"></a> 代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">unordered_map&lt;string,<span class=\"type\">bool</span>&gt; server_ip_exist;</span><br><span class=\"line\">unordered_map&lt;string,<span class=\"type\">int</span>&gt; server_id;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_ip</span><span class=\"params\">(string ip)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b,c,d,e;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">sscanf</span>(ip.<span class=\"built_in\">c_str</span>(),<span class=\"string\">&quot;%lld.%lld.%lld.%lld:%lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e)!=<span class=\"number\">5</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a&lt;<span class=\"number\">0</span>||a&gt;<span class=\"number\">255</span>||b&lt;<span class=\"number\">0</span>||b&gt;<span class=\"number\">255</span>||c&lt;<span class=\"number\">0</span>||c&gt;<span class=\"number\">255</span>||d&lt;<span class=\"number\">0</span>||d&gt;<span class=\"number\">255</span>||e&lt;<span class=\"number\">0</span>||e&gt;<span class=\"number\">65535</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    string now;</span><br><span class=\"line\">    now=<span class=\"built_in\">to_string</span>(a)+<span class=\"string\">&#x27;.&#x27;</span>+<span class=\"built_in\">to_string</span>(b)+<span class=\"string\">&#x27;.&#x27;</span>+<span class=\"built_in\">to_string</span>(c)+<span class=\"string\">&#x27;.&#x27;</span>+<span class=\"built_in\">to_string</span>(d)+<span class=\"string\">&#x27;:&#x27;</span>+<span class=\"built_in\">to_string</span>(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now!=ip)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string type,ip;</span><br><span class=\"line\">        cin&gt;&gt;type&gt;&gt;ip;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type==<span class=\"string\">&quot;Server&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(server_ip_exist[ip])<span class=\"comment\">//服务器 IP 已存在</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;FAIL&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_ip</span>(ip))<span class=\"comment\">//IP 格式错误</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;ERR&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            server_ip_exist[ip]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记 IP 存在</span></span><br><span class=\"line\">            server_id[ip]=i;<span class=\"comment\">//记录 ID</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;OK&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type==<span class=\"string\">&quot;Client&quot;</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_ip</span>(ip))<span class=\"comment\">//IP 格式错误</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;ERR&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!server_ip_exist[ip])<span class=\"comment\">//服务器 IP 不存在</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;FAIL&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout&lt;&lt;server_id[ip]&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"知识积累\"><a class=\"markdownIt-Anchor\" href=\"#知识积累\"></a> 知识积累</h1>\n<h2 id=\"与或非运算\"><a class=\"markdownIt-Anchor\" href=\"#与或非运算\"></a> 与或非运算</h2>\n<p>这些操作都要在 <strong>二进制下</strong> 完成</p>\n<ul>\n<li>按位与：<code>&amp;</code>：每一位都必须是 <code>1</code> 才会得到 <code>1</code>，否则是 <code>0</code></li>\n<li>按位或：<code>|</code>：每一位只要有一个是 <code>1</code> 就会得到 <code>1</code></li>\n<li>按位非：<code>~</code>：每一位取反</li>\n<li>按位异或：<code>^</code>：每一位相同为 <code>0</code>，不同为 <code>1</code></li>\n</ul>\n<p>在数学上，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∧</mo></mrow><annotation encoding=\"application/x-tex\">\\land</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∧</span></span></span></span> 和 <code>&amp;&amp;</code> 是一样的，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∨</mo></mrow><annotation encoding=\"application/x-tex\">\\lor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∨</span></span></span></span> 和 <code>||</code> 是一样的，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi></mrow><annotation encoding=\"application/x-tex\">\\neg</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">¬</span></span></span></span> 和 <code>!</code> 是一样的<br />\n这是 <strong>逻辑运算符</strong>，不要混淆</p>\n<h2 id=\"重难点进制转换\"><a class=\"markdownIt-Anchor\" href=\"#重难点进制转换\"></a> （重难点）进制转换</h2>\n<p>转换技巧：遇到 x 进制转 y 进制，可以先把 x 进制转为 10 进制，再转为 y 进制</p>\n<h3 id=\"x-进制转-10-进制\"><a class=\"markdownIt-Anchor\" href=\"#x-进制转-10-进制\"></a> x 进制转 10 进制</h3>\n<mark class=\"tag-plugin colorful mark\" color=\"yellow\">按位展开，乘权相加</mark>  \n<p>例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>F</mi><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub></mrow><annotation encoding=\"application/x-tex\">(2F)_{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 10 进制：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mn>2</mn><mi>F</mi></mstyle><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub><mo>=</mo><mstyle mathcolor=\"red\"><mn>2</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mn>1</mn></mstyle></msup><mo>+</mo><mstyle mathcolor=\"red\"><mn>15</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mn>0</mn></mstyle></msup><mo>=</mo><mn>32</mn><mo>+</mo><mn>15</mn><mo>=</mo><mo stretchy=\"false\">(</mo><mn>47</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">({\\color{red}2F})_{16}={\\color{red}2}\\times16^{\\color{blue}1}+{\\color{red}15}\\times16^{\\color{blue}0}=32+15=(47)_{10}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9474379999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">5</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>在上面的式子中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> 其实就是十进制里面的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span>，这不用多说</p>\n<p>如果是带小数的部分，要 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">乘负权相加</mark><br />\n例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mi mathvariant=\"normal\">.</mi><mi>F</mi><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub></mrow><annotation encoding=\"application/x-tex\">(A.F)_{16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 10 进制</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mi>A</mi><mi mathvariant=\"normal\">.</mi><mi>F</mi></mstyle><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub><mo>=</mo><mstyle mathcolor=\"red\"><mn>10</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mn>0</mn></mstyle></msup><mo>+</mo><mstyle mathcolor=\"red\"><mn>15</mn></mstyle><mo>×</mo><mn>1</mn><msup><mn>6</mn><mstyle mathcolor=\"blue\"><mo>−</mo><mn>1</mn></mstyle></msup><mo>=</mo><mn>10</mn><mo>+</mo><mfrac><mn>15</mn><mrow><mn>1</mn><msup><mn>6</mn><mn>1</mn></msup></mrow></mfrac><mo>=</mo><mo stretchy=\"false\">(</mo><mn>10.9375</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">({\\color{red}A.F})_{16}={\\color{red}10}\\times 16^{\\color{blue}0}+{\\color{red}15}\\times 16^{\\color{blue}-1}=10+\\frac{15}{16^1}=(10.9375)_{10}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"color:red;\">A</span><span class=\"mord\" style=\"color:red;\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">0</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9474379999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">5</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.864108em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.864108em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\" style=\"color:blue;\">−</span><span class=\"mord mtight\" style=\"color:blue;\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.740108em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">9</span><span class=\"mord\">3</span><span class=\"mord\">7</span><span class=\"mord\">5</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"10-进制转-x-进制\"><a class=\"markdownIt-Anchor\" href=\"#10-进制转-x-进制\"></a> 10 进制转 x 进制</h3>\n<mark class=\"tag-plugin colorful mark\" color=\"yellow\">不断除以 x，余数倒着写，商循环利用</mark>   \n<p>例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>47</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">(47)_{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 16 进制</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>47</mn><mo>÷</mo><mn>16</mn><mo>=</mo><mstyle mathcolor=\"blue\"><mn>2</mn></mstyle><mo>…</mo><mn>15</mn><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mi>F</mi></mstyle><mo stretchy=\"false\">)</mo><mspace linebreak=\"newline\"></mspace><mstyle mathcolor=\"blue\"><mn>2</mn></mstyle><mo>÷</mo><mn>16</mn><mo>=</mo><mstyle mathcolor=\"green\"><mn>0</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>2</mn></mstyle><mspace linebreak=\"newline\"></mspace><mo>∴</mo><mo stretchy=\"false\">(</mo><mn>47</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mn>2</mn><mi>F</mi></mstyle><msub><mo stretchy=\"false\">)</mo><mn>16</mn></msub></mrow><annotation encoding=\"application/x-tex\">47\\div16={\\color{blue}2}\\dots 15({\\color{red}F})\\\\\n{\\color{blue}2}\\div16={\\color{green}0}\\dots {\\color{red}2}\\\\\n\\therefore (47)_{10}=({\\color{red}2F})_{16}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\">)</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:green;\">0</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69224em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;color:red;\">F</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>如果是带小数的转换，整数部分还是和上面相同的，小数部分要 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">不断乘以 x，商取整，顺着写，小数循环利用</mark><br />\n例如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>114.514</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">(114.514)_{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 转 8 进制<br />\n那么我们先算整数部分：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>114</mn><mo>÷</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"blue\"><mn>14</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>2</mn></mstyle><mspace linebreak=\"newline\"></mspace><mstyle mathcolor=\"blue\"><mn>14</mn></mstyle><mo>÷</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"blue\"><mn>1</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>6</mn></mstyle><mspace linebreak=\"newline\"></mspace><mstyle mathcolor=\"blue\"><mn>1</mn></mstyle><mo>÷</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"green\"><mn>0</mn></mstyle><mo>…</mo><mstyle mathcolor=\"red\"><mn>1</mn></mstyle><mspace linebreak=\"newline\"></mspace><mo>∴</mo><mo stretchy=\"false\">(</mo><mn>114</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mn>162</mn></mstyle><msub><mo stretchy=\"false\">)</mo><mn>8</mn></msub></mrow><annotation encoding=\"application/x-tex\">114\\div 8={\\color{blue}14}\\dots {\\color{red}2}\\\\\n{\\color{blue}14}\\div 8={\\color{blue}1}\\dots {\\color{red}6}\\\\\n{\\color{blue}1}\\div 8={\\color{green}0}\\dots {\\color{red}1}\\\\\n\\therefore (114)_{10}=({\\color{red}162})_{8}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">4</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">4</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">6</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">÷</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:green;\">0</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69224em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">1</span><span class=\"mord\" style=\"color:red;\">6</span><span class=\"mord\" style=\"color:red;\">2</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>然后算小数部分：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>0.514</mn><mo>×</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"red\"><mn>4</mn></mstyle><mi mathvariant=\"normal\">.</mi><mstyle mathcolor=\"blue\"><mn>112</mn></mstyle><mspace linebreak=\"newline\"></mspace><mrow><mn>0.</mn><mstyle mathcolor=\"blue\"><mn>112</mn></mstyle></mrow><mo>×</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"red\"><mn>0</mn></mstyle><mi mathvariant=\"normal\">.</mi><mstyle mathcolor=\"blue\"><mn>912</mn></mstyle><mspace linebreak=\"newline\"></mspace><mrow><mn>0.</mn><mstyle mathcolor=\"blue\"><mn>912</mn></mstyle></mrow><mo>×</mo><mn>8</mn><mo>=</mo><mstyle mathcolor=\"red\"><mn>7</mn></mstyle><mi mathvariant=\"normal\">.</mi><mstyle mathcolor=\"blue\"><mn>296</mn></mstyle><mspace linebreak=\"newline\"></mspace><mo>…</mo><mspace linebreak=\"newline\"></mspace><mo>∴</mo><mo stretchy=\"false\">(</mo><mn>0.514</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0.</mn><mstyle mathcolor=\"red\"><mn>407</mn></mstyle><msub><mo stretchy=\"false\">)</mo><mn>8</mn></msub></mrow><annotation encoding=\"application/x-tex\">0.514\\times 8={\\color{red}4}.{\\color{blue}112}\\\\\n{0.\\color{blue}112}\\times 8={\\color{red}0}.{\\color{blue}912}\\\\\n{0.\\color{blue}912}\\times 8={\\color{red}7}.{\\color{blue}296}\\\\\n\\dots \\\\\n\\therefore (0.514)_{10}=(0.{\\color{red}407})_{8}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">4</span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">0</span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">9</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\" style=\"color:blue;\">9</span><span class=\"mord\" style=\"color:blue;\">1</span><span class=\"mord\" style=\"color:blue;\">2</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">7</span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:blue;\">2</span><span class=\"mord\" style=\"color:blue;\">9</span><span class=\"mord\" style=\"color:blue;\">6</span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.12em;vertical-align:0em;\"></span><span class=\"minner\">…</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69224em;vertical-align:0em;\"></span><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord\" style=\"color:red;\">4</span><span class=\"mord\" style=\"color:red;\">0</span><span class=\"mord\" style=\"color:red;\">7</span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>最后让我们加起来，得到了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>114.514</mn><msub><mo stretchy=\"false\">)</mo><mn>10</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mn>162.407</mn><msub><mo stretchy=\"false\">)</mo><mn>8</mn></msub></mrow><annotation encoding=\"application/x-tex\">(114.514)_{10}=(162.407)_{8}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mord\">.</span><span class=\"mord\">5</span><span class=\"mord\">1</span><span class=\"mord\">4</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">4</span><span class=\"mord\">0</span><span class=\"mord\">7</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br />\n如果题目中需要更高的精度，那就继续乘以 8，直到小数部分为 0</p>\n<h3 id=\"常用数字的进制转换\"><a class=\"markdownIt-Anchor\" href=\"#常用数字的进制转换\"></a> 常用数字的进制转换</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">八进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0000</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0001</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">0010</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">0111</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二进制编码\"><a class=\"markdownIt-Anchor\" href=\"#二进制编码\"></a> 二进制编码</h2>\n<ul>\n<li>原码：用 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">最高位</mark> 作为符号位，0是正数，1是负数，符号位之后是这个十进制数的绝对值的二进制，存在 -0 的问题，所以不用</li>\n<li>反码：正数和原码相同；负数符号位不变，剩余的 <mark class=\"tag-plugin colorful mark\" color=\"yellow\">在原码基础上按位取反</mark></li>\n<li>补码：正数和原码相同；负数就是反码+1（忽略符号位进位）</li>\n</ul>\n<h2 id=\"gcd-和-lcm\"><a class=\"markdownIt-Anchor\" href=\"#gcd-和-lcm\"></a> GCD 和 LCM</h2>\n<ul>\n<li>GCD：Greatest Common Divisor，最大公约数</li>\n<li>LCM：Least Common Multiple，最小公倍数</li>\n<li>GCD 和 LCM 之间的关系：</li>\n</ul>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>G</mi><mi>C</mi><mi>D</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>L</mi><mi>C</mi><mi>M</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">GCD(a,b)\\times LCM(a,b)=a\\times b\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span></p>\n<ul>\n<li>在 C++14 标准之后（OI 可用），你可以通过 <code>algorithm</code> 库中的 <code>std::__gcd(int,int)</code> 和 <code>std::__lcm(int,int)</code> 来计算 GCD 和 LCM</li>\n<li>在 CSP 一轮考场上，可以直接带入选项中的数值去尝试</li>\n</ul>\n<h2 id=\"重难点排列与组合\"><a class=\"markdownIt-Anchor\" href=\"#重难点排列与组合\"></a> （重难点）排列与组合</h2>\n<h3 id=\"排列\"><a class=\"markdownIt-Anchor\" href=\"#排列\"></a> 排列</h3>\n<p>概念：集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>个不同的元素组成，取出其中的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，<mark class=\"tag-plugin colorful mark\" color=\"yellow\">与顺序有关</mark> 的情况数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">A_n^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>，计算公式为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">A_n^r=\\frac{n!}{(n-r)!}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同也算另一种）<br />\n那么一共有</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>A</mi><mn>5</mn><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mn>5</mn><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mn>5</mn><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>5</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><mrow><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>120</mn><mn>6</mn></mfrac><mo>=</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">A_5^2=\\frac{5!}{(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{3\\times2\\times1}=\\frac{120}{6}=20\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1111079999999998em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.09077em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">6</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span></span></p>\n<p>种方案</p>\n<p>当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">n=r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>A</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">A_n^r=A_n^n=n!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span></p>\n<h3 id=\"组合\"><a class=\"markdownIt-Anchor\" href=\"#组合\"></a> 组合</h3>\n<p>概念：集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>个不同的元素组成，取出其中的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，<mark class=\"tag-plugin colorful mark\" color=\"yellow\">与顺序无关</mark> 的情况数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">C_n^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span>，计算公式为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><mfrac><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mrow><mi>r</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mrow><mi>r</mi><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><mrow><mi>r</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">C_n^r=\\frac{A_n^r}{r!}=\\frac{\\frac{n!}{(n-r)!}}{r!}=\\frac{n!}{r!(n-r)!}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.476108em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.790108em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose mtight\">)</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同只算做同一种）<br />\n那么一共有</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>C</mi><mn>5</mn><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mn>5</mn><mo stretchy=\"false\">!</mo></mrow><mrow><mn>2</mn><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>5</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mn>120</mn><mrow><mn>2</mn><mo>×</mo><mn>6</mn></mrow></mfrac><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">C_5^2=\\frac{5!}{2!(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{2\\times1\\times3\\times2\\times1}=\\frac{120}{2\\times6}=10\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1111079999999998em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.30744em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.09077em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.09077em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">6</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span></span></span></span></span></p>\n<p>种方案</p>\n<p>当 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">n=r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">C_n^r=C_n^n=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.93033em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<h3 id=\"排列与组合的联系\"><a class=\"markdownIt-Anchor\" href=\"#排列与组合的联系\"></a> 排列与组合的联系</h3>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>A</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>×</mo><msubsup><mi>A</mi><mi>r</mi><mi>r</mi></msubsup><mspace linebreak=\"newline\"></mspace><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mrow><mi>n</mi><mo>−</mo><mi>r</mi></mrow></msubsup><mspace linebreak=\"newline\"></mspace><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>r</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mi>r</mi></msubsup><mo>+</mo><msubsup><mi>C</mi><mi>n</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">A_n^r=C_n^r\\times A_r^r\\\\\nC_n^r=C_n^{n-r}\\\\\nC_{n+1}^r=C_n^r+C_n^{r-1}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.068331em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8213309999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1.019723em;vertical-align:-0.305331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714392em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1130000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.305331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9613919999999999em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1111079999999998em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"有重复的排列\"><a class=\"markdownIt-Anchor\" href=\"#有重复的排列\"></a> 有重复的排列</h3>\n<p>给出具有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个对象的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，选出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，可以重复选择<br />\n从第 1 个位置到第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个位置，每个位置有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 种选择，那么一共有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mi>r</mi></msup></mrow><annotation encoding=\"application/x-tex\">n^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span> 种方案</p>\n<h3 id=\"有重复的组合插板法\"><a class=\"markdownIt-Anchor\" href=\"#有重复的组合插板法\"></a> 有重复的组合（插板法）</h3>\n<p>给出具有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个对象的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，选出 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 个，可以重复选择，与顺序无关<br />\n最终方案数是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><mi>r</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n+r-1}^r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9897689999999999em;vertical-align:-0.30643899999999996em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6643919999999999em;\"><span style=\"top:-2.451892em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30643899999999996em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<h2 id=\"重难点小球与盒子\"><a class=\"markdownIt-Anchor\" href=\"#重难点小球与盒子\"></a> （重难点）小球与盒子</h2>\n<p>你有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个小球，要放到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个盒子里，每个盒子可以放多个小球，</p>\n<h3 id=\"可辨别的小球与可辨别的盒子\"><a class=\"markdownIt-Anchor\" href=\"#可辨别的小球与可辨别的盒子\"></a> 可辨别的小球与可辨别的盒子</h3>\n<p>最终方案数是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n+m-1}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9897689999999999em;vertical-align:-0.30643899999999996em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6643919999999999em;\"><span style=\"top:-2.451892em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30643899999999996em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"不可辨别的小球与可辨别的盒子\"><a class=\"markdownIt-Anchor\" href=\"#不可辨别的小球与可辨别的盒子\"></a> 不可辨别的小球与可辨别的盒子</h3>\n<p>盒子可以是空的：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n+m-1}^{m-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.178878em;vertical-align:-0.324639em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.324639em;\"><span></span></span></span></span></span></span></span></span></span><br />\n盒子不能是空的：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">C_{n-1}^{m-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.178878em;vertical-align:-0.324639em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.854239em;\"><span style=\"top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1031310000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.324639em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>剩下两种严重超纲，不记（涉及到第二类斯特林数和很多的分类讨论）</p>\n<h2 id=\"易考树的遍历\"><a class=\"markdownIt-Anchor\" href=\"#易考树的遍历\"></a> （易考）树的遍历</h2>\n<p>给出前序遍历和中序遍历，可以唯一确定一棵二叉树<br />\n给出后序遍历和中序遍历，可以唯一确定一棵二叉树</p>\n<h3 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"#步骤\"></a> 步骤</h3>\n<ol>\n<li>前序遍历的第一个元素是根节点，后序遍历的最后一个元素是根节点</li>\n<li>在中序遍历中找到根节点，它的左边是左子树，右边是右子树</li>\n<li>递归构建左子树和右子树</li>\n</ol>\n<h3 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\"></a> 示例</h3>\n<p>前序：<code>ABDECFG</code><br />\n中序：<code>DBEAFCG</code></p>\n<ol>\n<li>首先确定 <code>A</code> 为根节点</li>\n<li>在中序遍历中找到 <code>A</code>，它的左边 <code>DBE</code> 是左子树，右边 <code>FCG</code> 是右子树</li>\n<li>在前序 <code>BDE</code> 和 <code>CFG</code> 中得到后序遍历 <code>DBE</code> 和 <code>CFG</code></li>\n<li>接上根节点 <code>A</code>，得到后序遍历 <code>DBECFGA</code></li>\n</ol>\n<p>也可以去 2019 CSP-J1 T14 练习</p>\n<h2 id=\"易考单位换算\"><a class=\"markdownIt-Anchor\" href=\"#易考单位换算\"></a> （易考）单位换算</h2>\n<p><code>M = 1e6</code>，<code>K = 1e3</code><br />\n<code>1B(yte) = 8bit</code></p>\n<h3 id=\"二进制存储空间换算\"><a class=\"markdownIt-Anchor\" href=\"#二进制存储空间换算\"></a> 二进制存储空间换算</h3>\n<p><code>1TiB = 2e10GiB = 2e20MiB = 2e30KiB = 2e40B = 2e43bit</code><br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi>T</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi>G</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup><mi>M</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>30</mn></msup><mi>K</mi><mi>i</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>40</mn></msup><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>43</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">1 TiB = 2^{10} GiB = 2^{20} MiB = 2^{30} KiB = 2^{40} B = 2^{43} bit</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span></span></span></span></p>\n<h3 id=\"十进制存储空间换算\"><a class=\"markdownIt-Anchor\" href=\"#十进制存储空间换算\"></a> 十进制存储空间换算</h3>\n<p><code>1TB = 1e3GB = 1e6MB = 1e9KB = 1e12B = 8*1e12bit</code><br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi>T</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>G</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mi>M</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mi>K</mi><mi>B</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi>B</mi><mo>=</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">1 TB = 10^3 GB = 10^6 MB = 10^9 KB = 10^{12} B = 8\\times10^{12} bit</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span></span></span></span></p>\n<h2 id=\"文件存储空间\"><a class=\"markdownIt-Anchor\" href=\"#文件存储空间\"></a> 文件存储空间</h2>\n<p>图片存储空间：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>分辨率</mtext><mo>×</mo><mtext>位深度</mtext><mo stretchy=\"false\">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">分辨率\\times 位深度(bit)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">分</span><span class=\"mord cjk_fallback\">辨</span><span class=\"mord cjk_fallback\">率</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">深</span><span class=\"mord cjk_fallback\">度</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><br />\n视频存储空间：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>单张图大小</mtext><mo>×</mo><mi>f</mi><mi>p</mi><mi>s</mi><mo>×</mo><mtext>时长</mtext><mo stretchy=\"false\">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">单张图大小\\times fps\\times 时长(bit)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">单</span><span class=\"mord cjk_fallback\">张</span><span class=\"mord cjk_fallback\">图</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">长</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mtext>视频</mtext><mi>b</mi><mi>p</mi><mi>s</mi><mo>+</mo><mtext>音频</mtext><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mtext>时长</mtext></mrow><annotation encoding=\"application/x-tex\">(视频 bps+音频 bps)\\times 时长</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">视</span><span class=\"mord cjk_fallback\">频</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">音</span><span class=\"mord cjk_fallback\">频</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">长</span></span></span></span>（单位根据码率单位而定）<br />\n帧率缩写 fps，码率 bps</p>\n<h2 id=\"noi-历史\"><a class=\"markdownIt-Anchor\" href=\"#noi-历史\"></a> NOI 历史</h2>\n<ul>\n<li>第一届 NOI：1984，今年（NOI2025）第 41 届</li>\n<li>第一届 IOI：1989</li>\n<li>我国 2000 举办第 12 届 IOI</li>\n<li>第一届 NOIP：1995，2019 暂停一届</li>\n<li>第一届 CSP：2019</li>\n</ul>\n<h2 id=\"网络\"><a class=\"markdownIt-Anchor\" href=\"#网络\"></a> 网络</h2>\n<h3 id=\"osi-七层模型\"><a class=\"markdownIt-Anchor\" href=\"#osi-七层模型\"></a> OSI 七层模型</h3>\n<ol>\n<li>物理层：光纤、中继器</li>\n<li>数据链链路层：网卡、交换机、以太网</li>\n<li>网络层：IP、ICMP</li>\n<li>传输层：TCP、UDP</li>\n<li>会话层：SSL、TLS</li>\n<li>表示层：LPP</li>\n<li>应用层：HTTP、FTP、SMTP、POP3</li>\n</ol>\n<h3 id=\"协议\"><a class=\"markdownIt-Anchor\" href=\"#协议\"></a> 协议</h3>\n<p>HTTP：超文本传输协议<br />\nFTP：文件传输协议<br />\nSMTP：收发电子邮件<br />\nPOP3：接收电子邮件<br />\nTCP：三次握手(A-&gt;B 质询在线，B-&gt;A 返回在线，A-&gt;B 返回确认收到)</p>\n<h3 id=\"ip-地址\"><a class=\"markdownIt-Anchor\" href=\"#ip-地址\"></a> IP 地址</h3>\n<p>IPv4：<code>x.x.x.x</code>（0&lt;=x&lt;=255）32bit 4B</p>\n<ul>\n<li>A类地址：<code>1.0.0.1</code> ~ <code>127.255.255.254</code></li>\n<li>B类地址：<code>128.0.0.1</code> ~ <code>191.255.255.254</code></li>\n<li>C类地址：<code>192.0.0.1</code> ~ <code>223.255.255.254</code></li>\n</ul>\n<p>IPv6：<code>X:X:X:X:X:X:X:X</code>（0000&lt;=X&lt;=FFFF）64bit 8B</p>\n<h2 id=\"排序\"><a class=\"markdownIt-Anchor\" href=\"#排序\"></a> 排序</h2>\n<h3 id=\"算法信息\"><a class=\"markdownIt-Anchor\" href=\"#算法信息\"></a> 算法信息</h3>\n<p>n=等待排序的个数，w=数据值域</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法名称</th>\n<th style=\"text-align:center\">平均时间</th>\n<th style=\"text-align:center\">最坏时间</th>\n<th style=\"text-align:center\">是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">冒泡排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">选择排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">计数排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">归并排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\theta(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\theta(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">快速排序</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"快速排序原理\"><a class=\"markdownIt-Anchor\" href=\"#快速排序原理\"></a> 快速排序原理</h3>\n<p>使用递归原理<br />\n在 a[l]~a[r] 中选择一个基准 x<br />\n使用双指针将所有 <code>a[i] &lt; x</code> 交换到 x 左侧，<code>a[i] &gt; x</code> 交换到 x 右侧<br />\n快速排序通过双指针交换后，将一个大的排序问题划分为了两个子区间排序的小问题<br />\n所以期望复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n如果选择第一个数作为基准，序列有序，每次序列长度只减少 1<br />\n所以最坏复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"stdsort\"><a class=\"markdownIt-Anchor\" href=\"#stdsort\"></a> std::sort</h3>\n<p>由 algorithm 头文件提供，属于 STL<br />\n在数据范围较小的情况下，使用了堆排序等技术</p>\n<h2 id=\"数据结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构\"></a> 数据结构</h2>\n<h3 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h3>\n<p>优点：插入删除 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n缺点：读取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> n=链表元素个数</p>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[prev = NULL, <span class=\"built_in\">id</span> = <span class=\"number\">1</span>, value = <span class=\"number\">114</span>, <span class=\"built_in\">next</span> = <span class=\"number\">514</span>]  </span><br><span class=\"line\">[prev = <span class=\"number\">1</span>, <span class=\"built_in\">id</span> = <span class=\"number\">514</span>, value = <span class=\"number\">1919</span>, <span class=\"built_in\">next</span> = <span class=\"number\">1919</span>]  </span><br><span class=\"line\">[prev = <span class=\"number\">514</span>, <span class=\"built_in\">id</span> = <span class=\"number\">1919</span>, value = <span class=\"number\">810</span>, <span class=\"built_in\">next</span> = NULL]</span><br></pre></td></tr></table></figure>\n<h3 id=\"图的存储\"><a class=\"markdownIt-Anchor\" href=\"#图的存储\"></a> 图的存储</h3>\n<h4 id=\"邻接矩阵\"><a class=\"markdownIt-Anchor\" href=\"#邻接矩阵\"></a> 邻接矩阵</h4>\n<p>优点：查询边权 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n缺点：对于稀疏图，浪费空间</p>\n<h4 id=\"邻接表\"><a class=\"markdownIt-Anchor\" href=\"#邻接表\"></a> 邻接表</h4>\n<p>优点：空间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span><br />\n缺点：查询边权 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"树\"><a class=\"markdownIt-Anchor\" href=\"#树\"></a> 树</h3>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边的无向连通图<br />\n完整二叉树：每个节点的子节点数量都是 0 或 2</p>\n<h2 id=\"运算优先级\"><a class=\"markdownIt-Anchor\" href=\"#运算优先级\"></a> 运算优先级</h2>\n<p>自增/自减 执行顺序</p>\n<p><code>++x</code> 先增加 x 的值，然后送出使用<br />\n<code>x++</code> 先送出使用，然后增加 x 的值</p>\n<div class=\"tag-plugin copy\"><span>C++</span><input class=\"copy-area\" id=\"copy_1\" value=\"ans+=++x; = x=x+1;ans=ans+x;\"><button class=\"copy-btn\" onclick=\"util.copy(&quot;copy_1&quot;,&quot;复制成功&quot;)\"><svg class=\"icon copy-btn\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z\"></path></svg></button></div>\n<div class=\"tag-plugin copy\"><span>C++</span><input class=\"copy-area\" id=\"copy_2\" value=\"ans+=x++; = ans=ans+x;x=x+1;\"><button class=\"copy-btn\" onclick=\"util.copy(&quot;copy_2&quot;,&quot;复制成功&quot;)\"><svg class=\"icon copy-btn\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z\"></path></svg></button></div>\n<p><code>x++ + ++x</code><br />\n这属于 未定义行为（Undefined Behavior, UB），在不同的编译器上可以解释为任何值。<br />\n这可能导致本地通过，评测报错<br />\n可以通过 <code>-Wall</code> 参数找到所有的警告</p>\n<h2 id=\"计算原理\"><a class=\"markdownIt-Anchor\" href=\"#计算原理\"></a> 计算原理</h2>\n<h3 id=\"容斥原理减法法则\"><a class=\"markdownIt-Anchor\" href=\"#容斥原理减法法则\"></a> 容斥原理/减法法则</h3>\n<p>如果一个任务可以通过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 种方法执行，还可以通过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 种另一类方法执行，那么执行这个任务的方法数量是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>−</mo><mo stretchy=\"false\">[</mo><mtext>两种方法中相同的方法</mtext><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">n_1+n_2-[两种方法中相同的方法]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord cjk_fallback\">两</span><span class=\"mord cjk_fallback\">种</span><span class=\"mord cjk_fallback\">方</span><span class=\"mord cjk_fallback\">法</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">相</span><span class=\"mord cjk_fallback\">同</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">方</span><span class=\"mord cjk_fallback\">法</span><span class=\"mclose\">]</span></span></span></span><br />\n也就是说，集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_1,A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，与并集 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_1\\cup A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi><mo>−</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>A</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap A_2|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span></p>\n<h3 id=\"鸽巢原理\"><a class=\"markdownIt-Anchor\" href=\"#鸽巢原理\"></a> 鸽巢原理</h3>\n<p>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个或更多的物体放入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个盒子，那么至少有一个盒子包含了 2 个或更多的物体</p>\n<h3 id=\"广义鸽巢原理\"><a class=\"markdownIt-Anchor\" href=\"#广义鸽巢原理\"></a> 广义鸽巢原理</h3>\n<p>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个物体放入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个盒子，那么至少有一个盒子至少包含了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mfrac><mi>n</mi><mi>k</mi></mfrac><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil \\frac{n}{k}\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌉</span></span></span></span> 个物体</p>\n<h2 id=\"高级语言分类\"><a class=\"markdownIt-Anchor\" href=\"#高级语言分类\"></a> 高级语言分类</h2>\n<ul>\n<li>面向过程：以函数为基本程序结构：C，Pascal，Fortran</li>\n<li>面向对象：以类为基本程序结构：C++，Java，Python</li>\n<li>编译性：执行前用连接器生成可执行文件：C++</li>\n<li>解释性：一边用解释器翻译，一边运行代码：Python，JS，Ruby</li>\n<li>Java：编译 + 解释混合</li>\n</ul>\n<h2 id=\"计算机历史\"><a class=\"markdownIt-Anchor\" href=\"#计算机历史\"></a> 计算机历史</h2>\n<ul>\n<li>第一台计算机 - ENIAC</li>\n<li>有存储功能 - EDVAC</li>\n<li>冯诺依曼 - 存储结构</li>\n<li>图灵 - 测试</li>\n<li>阿达罗福莱斯 - 计算机程序的创始人</li>\n<li>马文·明斯基、约翰·麦卡西 - 对 AI 杰出贡献</li>\n<li>香农 - 信息论</li>\n</ul>\n<h2 id=\"哈夫曼树\"><a class=\"markdownIt-Anchor\" href=\"#哈夫曼树\"></a> 哈夫曼树</h2>\n<p>// TODO</p>"},{"title":"快读快写模板","date":"2025-07-12T07:36:30.000Z","poster":{"headline":"快读快写模板","topic":"持续更新中..."},"katex":true,"author":"ED_Builder","_content":"\n本文整理了在 OI 中可以提升读写速度的模板，持续更新中...\n\n<!-- more -->\n\n### 整型快读快写模板\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline void read(int& a)\n{\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n        if(ch=='-')  w=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n        s=s*10+ch-'0';\n        ch=getchar();\n    }\n    a=s*w;\n    return;\n}\ninline void write(int x)\n{\n    static int sta[10];\n    int top=0;\n    do\n    {\n        sta[top++]=x%10;\n        x/=10;\n    }while(x);\n    while(top)  putchar(sta[--top]+'0');\n    //putchar(' '); //可选的行末空格\n    //putchar('\\n'); //可选的行末换行\n    return;\n}\nsigned main()\n{\n    int a,b;\n    read(a);\n    read(b);\n    write(a+b);\n    return 0;\n}\n```","source":"_posts/快读快写模板.md","raw":"---\ntitle: 快读快写模板\ndate: 2025-07-12 15:36:30\ntags: ['OI', '模板']\ncategories: ['学习', '分享']\nposter:\n    headline: 快读快写模板\n    topic: 持续更新中...\nkatex: true\nauthor: ED_Builder\n---\n\n本文整理了在 OI 中可以提升读写速度的模板，持续更新中...\n\n<!-- more -->\n\n### 整型快读快写模板\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline void read(int& a)\n{\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n        if(ch=='-')  w=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n        s=s*10+ch-'0';\n        ch=getchar();\n    }\n    a=s*w;\n    return;\n}\ninline void write(int x)\n{\n    static int sta[10];\n    int top=0;\n    do\n    {\n        sta[top++]=x%10;\n        x/=10;\n    }while(x);\n    while(top)  putchar(sta[--top]+'0');\n    //putchar(' '); //可选的行末空格\n    //putchar('\\n'); //可选的行末换行\n    return;\n}\nsigned main()\n{\n    int a,b;\n    read(a);\n    read(b);\n    write(a+b);\n    return 0;\n}\n```","slug":"快读快写模板","published":1,"updated":"2025-08-25T04:41:24.453Z","_id":"cmebjcsvv0003c4boe06ybo0o","comments":1,"layout":"post","photos":[],"content":"<p>本文整理了在 OI 中可以提升读写速度的模板，持续更新中…</p>\n<span id=\"more\"></span>\n<h3 id=\"整型快读快写模板\"><a class=\"markdownIt-Anchor\" href=\"#整型快读快写模板\"></a> 整型快读快写模板</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s=<span class=\"number\">0</span>,w=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">&#x27;0&#x27;</span>||ch&gt;<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch==<span class=\"string\">&#x27;-&#x27;</span>)  w=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+ch-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a=s*w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> sta[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> top=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sta[top++]=x%<span class=\"number\">10</span>;</span><br><span class=\"line\">        x/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top)  <span class=\"built_in\">putchar</span>(sta[--top]+<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27; &#x27;); //可选的行末空格</span></span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27;\\n&#x27;); //可选的行末换行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(a);</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(b);</span><br><span class=\"line\">    <span class=\"built_in\">write</span>(a+b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>本文整理了在 OI 中可以提升读写速度的模板，持续更新中…</p>","more":"<h3 id=\"整型快读快写模板\"><a class=\"markdownIt-Anchor\" href=\"#整型快读快写模板\"></a> 整型快读快写模板</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s=<span class=\"number\">0</span>,w=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">&#x27;0&#x27;</span>||ch&gt;<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch==<span class=\"string\">&#x27;-&#x27;</span>)  w=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+ch-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a=s*w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> sta[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> top=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sta[top++]=x%<span class=\"number\">10</span>;</span><br><span class=\"line\">        x/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top)  <span class=\"built_in\">putchar</span>(sta[--top]+<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27; &#x27;); //可选的行末空格</span></span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27;\\n&#x27;); //可选的行末换行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(a);</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(b);</span><br><span class=\"line\">    <span class=\"built_in\">write</span>(a+b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"搜索题目整理","date":"2025-07-12T07:36:30.000Z","banner":"https://imghub.ed-builder.top/file/2JkPK8tN.jpeg","cover":"https://imghub.ed-builder.top/file/2JkPK8tN.jpeg","poster":{"headline":"搜索题目整理","topic":"只是基础的搜索而已，没有什么图上搜索之类的高阶算法"},"katex":true,"author":"ED_Builder","_content":"\n本文整理了 ED_Builder 在初学搜索算法时做的题目\n\n<!-- more -->\n\n# DFS\n## [P1219](https://luogu.com.cn/problem/P1219) 八皇后\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20],ans;//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案\nbool vis_lie[30],vis_l[30],vis_r[30];//记录当前列(|),左斜(/),右斜(\\)是否被访问\nvoid print()//输出答案\n{\n    if(ans>3)  return;//由题可得,只需要输出 3 种排列\n    for(int i=1;i<=n;i++)  cout<<a[i]<<' ';\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)//形参 x :当前是第 x 个皇后\n{\n    if(x>n)//一种可行的方案达成\n    {\n        ans++;//方案数++\n        print();//输出答案\n        return;\n    }\n    for(int i=1;i<=n;i++)//枚举所有答案\n    {\n        if(!vis_lie[i]&&!vis_l[x-i+n]&&!vis_r[x+i])//是否被访问过(规律见 L40 )\n        {\n            vis_lie[i]=true,vis_l[x-i+n]=true,vis_r[x+i]=true;//标记\n            a[x]=i;//存答案\n            dfs(x+1);//继续递归\n            vis_lie[i]=false,vis_l[x-i+n]=false,vis_r[x+i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n\n/*\n对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界\n对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等\n*/\n```\n## [P1706](https://luogu.com.cn/problem/P1706) 全排列问题\n### P1 - DFS\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20];//枚举 n 个数字,可行的答案存放在 a 中\nbool vis[20];//已经被访问过的\nvoid print()//输出答案\n{\n    for(int i=1;i<=n;i++)  cout<<setw(5)<<a[i];\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)\n{\n    if(x>n)//已经有了一个方案\n    {\n        print();\n        return;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i])//没被访问\n        {\n            a[x]=i;//记录答案\n            vis[i]=true;//标记\n            dfs(x+1);//继续递归\n            vis[i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);//从 1 开始\n    return 0;\n}\n```\n### P2 - 枚举优化\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint num[n];\n\tfor(int i=1;i<=n;i++)  num[i]=i;\n\tdo\n\t{\n\t\tfor(int i=1;i<=n;i++)  cout<<setw(5)<<num[i];\n\t\tcout<<endl;\n\t}while(next_permutation(num+1,num+1+n));\n\treturn 0;\n}\n```\n## [P1605](https://luogu.com.cn/problem/P1605) 迷宫\n```cpp\n#include<iostream>\n#include<cstring>//这里不用万能头是因为想用 map 当变量名\nusing namespace std;\nint n,m,t,sx,sy,fx,fy,ans;\n//地图长宽,障碍数量,起点坐标,终点坐标,答案\nint dx[5]={1,0,-1,0},dy[5]={0,-1,0,1};//位移\nbool map[10][10];//地图\nvoid dfs(int x,int y)\n{\n    if(x==fx&&y==fy)//到达终点\n    {\n        ans++;\n        return;\n    }\n    for(int i=0;i<4;i++)//枚举位移\n    {\n        int tmp_x=dx[i]+x,tmp_y=dy[i]+y;//移动\n        if(tmp_x>=1&&tmp_x<=n&&tmp_y>=1&&tmp_y<=m&&map[tmp_x][tmp_y])\n        //合法判断:坐标未越界,位置可用(没有障碍且没被访问)\n        {\n            map[tmp_x][tmp_y]=false;//标记访问\n            dfs(tmp_x,tmp_y);//继续递归\n            map[tmp_x][tmp_y]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(map,true,sizeof(map));//初始化\n    cin>>n>>m>>t>>sx>>sy>>fx>>fy;\n    for(int i=1;i<=t;i++)//读入障碍\n    {\n        int x,y;\n        cin>>x>>y;\n        map[x][y]=false;//不能走\n    }\n    map[sx][sy]=false;//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!\n    dfs(sx,sy);\n    cout<<ans;\n    return 0;\n}\n```\n## [P1036](https://luogu.com.cn/problem/P1036) 选数\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k,x[25],ans;//共有 n 个数,要选 k 个数,答案\nbool vis[25];//是否已经被选择\nbool check_prime(int n)//判断质数\n{\n    if(n<=1)  return false;\n    for(int i=2;i<=sqrt(n);i++)\n        if(n%i==0)  return false;\n    return true;\n}\nvoid dfs(int pos,int cnt,int sum)\n{\n    if(cnt>=k)//选完了\n    {\n        if(check_prime(sum))  ans++;//判断质数,然后答案自增\n        return;\n    }\n    for(int i=pos;i<=n;i++)\n    {\n        if(vis[i])//没被选\n        {\n            vis[i]=false;//标记\n            dfs(i+1,cnt+1,sum+x[i]);//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数\n            vis[i]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(vis,true,sizeof(vis));//初始化\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>x[i];\n    dfs(1,0,0);//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0\n    cout<<ans;\n    return 0;\n}\n```\n## [P1238](https://luogu.com.cn/problem/P1238) 走迷宫\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint m,n;// m 行 n 列 \nint mp[20][20],vis[20][20],have_solution=false;//地图,是否被访问,是否有解 \nint begin_x,begin_y,end_x,end_y;//起点和终点 \nint dx[5]={0,-1,0,1},dy[5]={-1,0,1,0};//偏移\nint ans[100000][3],k;\n//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 \n\nvoid print()//输出一种答案 \n{\n\tif(have_solution==false)  have_solution=true;//更新为有解 \n\tfor(int i=0;i<k;i++)  cout<<'('<<ans[i][1]<<','<<ans[i][2]<<')'<<\"->\";\n\tcout<<'('<<end_x<<','<<end_y<<')'<<endl;\n\t//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 \n}\n\nvoid dfs(int x,int y)\n{\n\tif(x==end_x&&y==end_y)//到达终点 \n\t{\n\t\tprint();//输出答案 \n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++)//枚举偏移 \n\t{\n\t\tint nxt_x=x+dx[i],nxt_y=y+dy[i];//定位下一步 \n\t\tif(mp[nxt_x][nxt_y]==1&&vis[nxt_x][nxt_y]==0)\n\t\t//下一步可以走并且没被访问 \n\t\t{\n\t\t\tvis[x][y]=1;//标记上一步被访问 \n\t\t\tans[k][1]=x,ans[k][2]=y;//记录可行的一步 \n\t\t\tk++;//增加指针 \n\t\t\tdfs(nxt_x,nxt_y);//继续找下一步 \n\t\t\tvis[x][y]=0;//回溯,设为未访问 \n\t\t\tk--;//倒回去 \n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tcin>>m>>n;\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcin>>mp[i][j];//读入地图 \n\tcin>>begin_x>>begin_y>>end_x>>end_y;//读入起点和终点 \n\tdfs(begin_x,begin_y);\n\tif(!have_solution)  cout<<-1;//没有解 \n\treturn 0;//结束 :) \n}\n```\n# BFS\n注意: **BFS 不能用于加权图**,因为 BFS 只会查找**边数最少**的路径  \n例如 100 -> 100 和 1 -> 1 -> 1 -> 1  \nBFS 会选择 100 -> 100\n\n当数据范围较小（ $\\le20$ ）时，用 DFS 也不是不可以\n## [P1746](https://luogu.com.cn/problem/P1746) 离开中山路\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point//单个点的坐标\n{\n    int x,y;\n};\nint n;\nchar map[1005][1005];\nint dis[1005][1005];//到起点的距离\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};//位移\nint start_x,start_y,final_x,final_y;//由题可得,起点和终点\nqueue<Point> q;//等待处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//压入当前点\n    dis[x][y]=0;//起点\n    while(!q.empty())//只要队列非空\n    {\n        Point t=q.front();//读取当前队头\n        q.pop();//弹出\n        for(int i=0;i<4;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//下一个点\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>n||map[nxt_x][nxt_y]=='1'||dis[nxt_x][nxt_y]>0)  continue;\n            //判断:越界+有障碍+被访问\n\n            q.push((Point){nxt_x,nxt_y});//压入下一个点\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//增加 1 段距离\n        }\n    }\n    return;\n}\nint main()\n{\n\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>map[i][j];\n    cin>>start_x>>start_y>>final_x>>final_y;\n    bfs(start_x,start_y);\n    cout<<dis[final_x][final_y];\n    return 0;\n}\n```\n## [P1443](https://luogu.com.cn/problem/P1443) 马的遍历\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Point//当前马位于的坐标\n{\n    int x,y;\n};\nint n,m,x,y,dis[405][405];//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步\nint dx[]={2,1,-2,1,-1,2,-2,-1};\nint dy[]={1,2,1,-2,2,-1,-1,-2};//位移\nqueue<Point> q;//当前需要处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//入队处理起点\n    dis[x][y]=0;//起点已经有一个马了\n    while(!q.empty())\n    {\n        Point t=q.front();//取队头处理\n        q.pop();//弹出\n        for(int i=0;i<8;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//生成新坐标\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>m||dis[nxt_x][nxt_y]!=-1)  continue;\n            //检查:越界+被访问\n\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//更新步数为上一个点+1\n            q.push((Point){nxt_x,nxt_y});//继续压入新的点继续处理\n        }\n    }\n    return;\n}\nint main()\n{\n    memset(dis,-1,sizeof(dis));//初始化\n    cin>>n>>m>>x>>y;\n    bfs(x,y);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)  cout<<setw(5)<<dis[i][j];\n        cout<<endl;\n    }\n    return 0;\n}\n```\n## [P2895](https://luogu.com.cn/problem/P2895) Meteor Shower S\n耗时 2 个月的巅峰对决，但最终还是我赢了！\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=305;\nstruct Point//存储坐标的点 \n{\n    int x,y;\n};\nint m;\nint mp[LEN][LEN],dis[LEN][LEN];//地图,距离 \nint dx[]={-1,0,1,0},dy[]={0,1,0,-1};//偏移 \nqueue<Point> q;\nint bfs()\n{\n    q.push((Point){0,0});//第一个位置是 (0,0) \n    dis[0][0]=0;//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 \n    while(!q.empty())\n    {\n        Point now=q.front();//找到当前点 \n        q.pop();\n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];//得到下一个点的位置\n            if(nxt_x<0||nxt_y<0)  continue;//越界 \n            if(dis[nxt_x][nxt_y])  continue;//被访问\n            if(dis[now.x][now.y]+1>=mp[nxt_x][nxt_y])  continue;\n            //剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较\n            dis[nxt_x][nxt_y]=dis[now.x][now.y]+1;//更新距离 \n            q.push((Point){nxt_x,nxt_y});//压入下一个点 \n            if(mp[nxt_x][nxt_y]>1e9)  return dis[nxt_x][nxt_y];//没有流行砸到,答案就是当前点的距离 \n        }\n    }\n    return -1;\n}\nsigned main()\n{\n    memset(mp,0x3f,sizeof(mp));//初始化一个足够大的数,为了在下面取到最小值 \n    cin>>m;\n    while(m--)\n    {\n        int x,y,time;//坐标,流星砸下来的时间 \n        cin>>x>>y>>time;\n        mp[x][y]=min(mp[x][y],time);//取砸下来的最小值 \n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=x+dx[d],nxt_y=y+dy[d];//得到即将蔓延的点 \n            if(nxt_x<0||nxt_x>301||nxt_y<0||nxt_y>301)  continue;//越界 \n            mp[nxt_x][nxt_y]=min(mp[nxt_x][nxt_y],time);//继续取最小值 \n        }\n    }\n    cout<<bfs();\n    exit(0);\n}\n```","source":"_posts/搜索题目整理.md","raw":"---\ntitle: 搜索题目整理\ndate: 2025-07-12 15:36:30\nbanner: https://imghub.ed-builder.top/file/2JkPK8tN.jpeg\ncover: https://imghub.ed-builder.top/file/2JkPK8tN.jpeg\ntags: ['搜索', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 搜索题目整理\n    topic: 只是基础的搜索而已，没有什么图上搜索之类的高阶算法\nkatex: true\nauthor: ED_Builder\n---\n\n本文整理了 ED_Builder 在初学搜索算法时做的题目\n\n<!-- more -->\n\n# DFS\n## [P1219](https://luogu.com.cn/problem/P1219) 八皇后\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20],ans;//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案\nbool vis_lie[30],vis_l[30],vis_r[30];//记录当前列(|),左斜(/),右斜(\\)是否被访问\nvoid print()//输出答案\n{\n    if(ans>3)  return;//由题可得,只需要输出 3 种排列\n    for(int i=1;i<=n;i++)  cout<<a[i]<<' ';\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)//形参 x :当前是第 x 个皇后\n{\n    if(x>n)//一种可行的方案达成\n    {\n        ans++;//方案数++\n        print();//输出答案\n        return;\n    }\n    for(int i=1;i<=n;i++)//枚举所有答案\n    {\n        if(!vis_lie[i]&&!vis_l[x-i+n]&&!vis_r[x+i])//是否被访问过(规律见 L40 )\n        {\n            vis_lie[i]=true,vis_l[x-i+n]=true,vis_r[x+i]=true;//标记\n            a[x]=i;//存答案\n            dfs(x+1);//继续递归\n            vis_lie[i]=false,vis_l[x-i+n]=false,vis_r[x+i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n\n/*\n对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界\n对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等\n*/\n```\n## [P1706](https://luogu.com.cn/problem/P1706) 全排列问题\n### P1 - DFS\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20];//枚举 n 个数字,可行的答案存放在 a 中\nbool vis[20];//已经被访问过的\nvoid print()//输出答案\n{\n    for(int i=1;i<=n;i++)  cout<<setw(5)<<a[i];\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)\n{\n    if(x>n)//已经有了一个方案\n    {\n        print();\n        return;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i])//没被访问\n        {\n            a[x]=i;//记录答案\n            vis[i]=true;//标记\n            dfs(x+1);//继续递归\n            vis[i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);//从 1 开始\n    return 0;\n}\n```\n### P2 - 枚举优化\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint num[n];\n\tfor(int i=1;i<=n;i++)  num[i]=i;\n\tdo\n\t{\n\t\tfor(int i=1;i<=n;i++)  cout<<setw(5)<<num[i];\n\t\tcout<<endl;\n\t}while(next_permutation(num+1,num+1+n));\n\treturn 0;\n}\n```\n## [P1605](https://luogu.com.cn/problem/P1605) 迷宫\n```cpp\n#include<iostream>\n#include<cstring>//这里不用万能头是因为想用 map 当变量名\nusing namespace std;\nint n,m,t,sx,sy,fx,fy,ans;\n//地图长宽,障碍数量,起点坐标,终点坐标,答案\nint dx[5]={1,0,-1,0},dy[5]={0,-1,0,1};//位移\nbool map[10][10];//地图\nvoid dfs(int x,int y)\n{\n    if(x==fx&&y==fy)//到达终点\n    {\n        ans++;\n        return;\n    }\n    for(int i=0;i<4;i++)//枚举位移\n    {\n        int tmp_x=dx[i]+x,tmp_y=dy[i]+y;//移动\n        if(tmp_x>=1&&tmp_x<=n&&tmp_y>=1&&tmp_y<=m&&map[tmp_x][tmp_y])\n        //合法判断:坐标未越界,位置可用(没有障碍且没被访问)\n        {\n            map[tmp_x][tmp_y]=false;//标记访问\n            dfs(tmp_x,tmp_y);//继续递归\n            map[tmp_x][tmp_y]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(map,true,sizeof(map));//初始化\n    cin>>n>>m>>t>>sx>>sy>>fx>>fy;\n    for(int i=1;i<=t;i++)//读入障碍\n    {\n        int x,y;\n        cin>>x>>y;\n        map[x][y]=false;//不能走\n    }\n    map[sx][sy]=false;//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!\n    dfs(sx,sy);\n    cout<<ans;\n    return 0;\n}\n```\n## [P1036](https://luogu.com.cn/problem/P1036) 选数\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k,x[25],ans;//共有 n 个数,要选 k 个数,答案\nbool vis[25];//是否已经被选择\nbool check_prime(int n)//判断质数\n{\n    if(n<=1)  return false;\n    for(int i=2;i<=sqrt(n);i++)\n        if(n%i==0)  return false;\n    return true;\n}\nvoid dfs(int pos,int cnt,int sum)\n{\n    if(cnt>=k)//选完了\n    {\n        if(check_prime(sum))  ans++;//判断质数,然后答案自增\n        return;\n    }\n    for(int i=pos;i<=n;i++)\n    {\n        if(vis[i])//没被选\n        {\n            vis[i]=false;//标记\n            dfs(i+1,cnt+1,sum+x[i]);//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数\n            vis[i]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(vis,true,sizeof(vis));//初始化\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>x[i];\n    dfs(1,0,0);//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0\n    cout<<ans;\n    return 0;\n}\n```\n## [P1238](https://luogu.com.cn/problem/P1238) 走迷宫\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint m,n;// m 行 n 列 \nint mp[20][20],vis[20][20],have_solution=false;//地图,是否被访问,是否有解 \nint begin_x,begin_y,end_x,end_y;//起点和终点 \nint dx[5]={0,-1,0,1},dy[5]={-1,0,1,0};//偏移\nint ans[100000][3],k;\n//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 \n\nvoid print()//输出一种答案 \n{\n\tif(have_solution==false)  have_solution=true;//更新为有解 \n\tfor(int i=0;i<k;i++)  cout<<'('<<ans[i][1]<<','<<ans[i][2]<<')'<<\"->\";\n\tcout<<'('<<end_x<<','<<end_y<<')'<<endl;\n\t//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 \n}\n\nvoid dfs(int x,int y)\n{\n\tif(x==end_x&&y==end_y)//到达终点 \n\t{\n\t\tprint();//输出答案 \n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++)//枚举偏移 \n\t{\n\t\tint nxt_x=x+dx[i],nxt_y=y+dy[i];//定位下一步 \n\t\tif(mp[nxt_x][nxt_y]==1&&vis[nxt_x][nxt_y]==0)\n\t\t//下一步可以走并且没被访问 \n\t\t{\n\t\t\tvis[x][y]=1;//标记上一步被访问 \n\t\t\tans[k][1]=x,ans[k][2]=y;//记录可行的一步 \n\t\t\tk++;//增加指针 \n\t\t\tdfs(nxt_x,nxt_y);//继续找下一步 \n\t\t\tvis[x][y]=0;//回溯,设为未访问 \n\t\t\tk--;//倒回去 \n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tcin>>m>>n;\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcin>>mp[i][j];//读入地图 \n\tcin>>begin_x>>begin_y>>end_x>>end_y;//读入起点和终点 \n\tdfs(begin_x,begin_y);\n\tif(!have_solution)  cout<<-1;//没有解 \n\treturn 0;//结束 :) \n}\n```\n# BFS\n注意: **BFS 不能用于加权图**,因为 BFS 只会查找**边数最少**的路径  \n例如 100 -> 100 和 1 -> 1 -> 1 -> 1  \nBFS 会选择 100 -> 100\n\n当数据范围较小（ $\\le20$ ）时，用 DFS 也不是不可以\n## [P1746](https://luogu.com.cn/problem/P1746) 离开中山路\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point//单个点的坐标\n{\n    int x,y;\n};\nint n;\nchar map[1005][1005];\nint dis[1005][1005];//到起点的距离\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};//位移\nint start_x,start_y,final_x,final_y;//由题可得,起点和终点\nqueue<Point> q;//等待处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//压入当前点\n    dis[x][y]=0;//起点\n    while(!q.empty())//只要队列非空\n    {\n        Point t=q.front();//读取当前队头\n        q.pop();//弹出\n        for(int i=0;i<4;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//下一个点\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>n||map[nxt_x][nxt_y]=='1'||dis[nxt_x][nxt_y]>0)  continue;\n            //判断:越界+有障碍+被访问\n\n            q.push((Point){nxt_x,nxt_y});//压入下一个点\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//增加 1 段距离\n        }\n    }\n    return;\n}\nint main()\n{\n\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>map[i][j];\n    cin>>start_x>>start_y>>final_x>>final_y;\n    bfs(start_x,start_y);\n    cout<<dis[final_x][final_y];\n    return 0;\n}\n```\n## [P1443](https://luogu.com.cn/problem/P1443) 马的遍历\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Point//当前马位于的坐标\n{\n    int x,y;\n};\nint n,m,x,y,dis[405][405];//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步\nint dx[]={2,1,-2,1,-1,2,-2,-1};\nint dy[]={1,2,1,-2,2,-1,-1,-2};//位移\nqueue<Point> q;//当前需要处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//入队处理起点\n    dis[x][y]=0;//起点已经有一个马了\n    while(!q.empty())\n    {\n        Point t=q.front();//取队头处理\n        q.pop();//弹出\n        for(int i=0;i<8;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//生成新坐标\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>m||dis[nxt_x][nxt_y]!=-1)  continue;\n            //检查:越界+被访问\n\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//更新步数为上一个点+1\n            q.push((Point){nxt_x,nxt_y});//继续压入新的点继续处理\n        }\n    }\n    return;\n}\nint main()\n{\n    memset(dis,-1,sizeof(dis));//初始化\n    cin>>n>>m>>x>>y;\n    bfs(x,y);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)  cout<<setw(5)<<dis[i][j];\n        cout<<endl;\n    }\n    return 0;\n}\n```\n## [P2895](https://luogu.com.cn/problem/P2895) Meteor Shower S\n耗时 2 个月的巅峰对决，但最终还是我赢了！\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=305;\nstruct Point//存储坐标的点 \n{\n    int x,y;\n};\nint m;\nint mp[LEN][LEN],dis[LEN][LEN];//地图,距离 \nint dx[]={-1,0,1,0},dy[]={0,1,0,-1};//偏移 \nqueue<Point> q;\nint bfs()\n{\n    q.push((Point){0,0});//第一个位置是 (0,0) \n    dis[0][0]=0;//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 \n    while(!q.empty())\n    {\n        Point now=q.front();//找到当前点 \n        q.pop();\n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];//得到下一个点的位置\n            if(nxt_x<0||nxt_y<0)  continue;//越界 \n            if(dis[nxt_x][nxt_y])  continue;//被访问\n            if(dis[now.x][now.y]+1>=mp[nxt_x][nxt_y])  continue;\n            //剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较\n            dis[nxt_x][nxt_y]=dis[now.x][now.y]+1;//更新距离 \n            q.push((Point){nxt_x,nxt_y});//压入下一个点 \n            if(mp[nxt_x][nxt_y]>1e9)  return dis[nxt_x][nxt_y];//没有流行砸到,答案就是当前点的距离 \n        }\n    }\n    return -1;\n}\nsigned main()\n{\n    memset(mp,0x3f,sizeof(mp));//初始化一个足够大的数,为了在下面取到最小值 \n    cin>>m;\n    while(m--)\n    {\n        int x,y,time;//坐标,流星砸下来的时间 \n        cin>>x>>y>>time;\n        mp[x][y]=min(mp[x][y],time);//取砸下来的最小值 \n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=x+dx[d],nxt_y=y+dy[d];//得到即将蔓延的点 \n            if(nxt_x<0||nxt_x>301||nxt_y<0||nxt_y>301)  continue;//越界 \n            mp[nxt_x][nxt_y]=min(mp[nxt_x][nxt_y],time);//继续取最小值 \n        }\n    }\n    cout<<bfs();\n    exit(0);\n}\n```","slug":"搜索题目整理","published":1,"updated":"2025-08-25T04:41:24.453Z","_id":"cmebjcswo0007c4bo1z1ifvr7","comments":1,"layout":"post","photos":[],"content":"<p>本文整理了 ED_Builder 在初学搜索算法时做的题目</p>\n<span id=\"more\"></span>\n<h1 id=\"dfs\"><a class=\"markdownIt-Anchor\" href=\"#dfs\"></a> DFS</h1>\n<h2 id=\"p1219\"><a class=\"markdownIt-Anchor\" href=\"#p1219\"></a> <a href=\"https://luogu.com.cn/problem/P1219\">P1219</a> 八皇后</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>],ans;<span class=\"comment\">//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis_lie[<span class=\"number\">30</span>],vis_l[<span class=\"number\">30</span>],vis_r[<span class=\"number\">30</span>];<span class=\"comment\">//记录当前列(|),左斜(/),右斜(\\)是否被访问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans&gt;<span class=\"number\">3</span>)  <span class=\"keyword\">return</span>;<span class=\"comment\">//由题可得,只需要输出 3 种排列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//形参 x :当前是第 x 个皇后</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//一种可行的方案达成</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;<span class=\"comment\">//方案数++</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//枚举所有答案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis_lie[i]&amp;&amp;!vis_l[x-i+n]&amp;&amp;!vis_r[x+i])<span class=\"comment\">//是否被访问过(规律见 L40 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">true</span>,vis_l[x-i+n]=<span class=\"literal\">true</span>,vis_r[x+i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//存答案</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">false</span>,vis_l[x-i+n]=<span class=\"literal\">false</span>,vis_r[x+i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"p1706\"><a class=\"markdownIt-Anchor\" href=\"#p1706\"></a> <a href=\"https://luogu.com.cn/problem/P1706\">P1706</a> 全排列问题</h2>\n<h3 id=\"p1-dfs\"><a class=\"markdownIt-Anchor\" href=\"#p1-dfs\"></a> P1 - DFS</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>];<span class=\"comment\">//枚举 n 个数字,可行的答案存放在 a 中</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">20</span>];<span class=\"comment\">//已经被访问过的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;a[i];</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//已经有了一个方案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i])<span class=\"comment\">//没被访问</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//记录答案</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);<span class=\"comment\">//从 1 开始</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"p2-枚举优化\"><a class=\"markdownIt-Anchor\" href=\"#p2-枚举优化\"></a> P2 - 枚举优化</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> num[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  num[i]=i;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;num[i];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(num<span class=\"number\">+1</span>,num<span class=\"number\">+1</span>+n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1605\"><a class=\"markdownIt-Anchor\" href=\"#p1605\"></a> <a href=\"https://luogu.com.cn/problem/P1605\">P1605</a> 迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span><span class=\"comment\">//这里不用万能头是因为想用 map 当变量名</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,t,sx,sy,fx,fy,ans;</span><br><span class=\"line\"><span class=\"comment\">//地图长宽,障碍数量,起点坐标,终点坐标,答案</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">bool</span> map[<span class=\"number\">10</span>][<span class=\"number\">10</span>];<span class=\"comment\">//地图</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==fx&amp;&amp;y==fy)<span class=\"comment\">//到达终点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp_x=dx[i]+x,tmp_y=dy[i]+y;<span class=\"comment\">//移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp_x&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_x&lt;=n&amp;&amp;tmp_y&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_y&lt;=m&amp;&amp;map[tmp_x][tmp_y])</span><br><span class=\"line\">        <span class=\"comment\">//合法判断:坐标未越界,位置可用(没有障碍且没被访问)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记访问</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(tmp_x,tmp_y);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(map,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(map));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)<span class=\"comment\">//读入障碍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        map[x][y]=<span class=\"literal\">false</span>;<span class=\"comment\">//不能走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map[sx][sy]=<span class=\"literal\">false</span>;<span class=\"comment\">//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(sx,sy);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1036\"><a class=\"markdownIt-Anchor\" href=\"#p1036\"></a> <a href=\"https://luogu.com.cn/problem/P1036\">P1036</a> 选数</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,x[<span class=\"number\">25</span>],ans;<span class=\"comment\">//共有 n 个数,要选 k 个数,答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">25</span>];<span class=\"comment\">//是否已经被选择</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_prime</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//判断质数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"built_in\">sqrt</span>(n);i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> pos,<span class=\"type\">int</span> cnt,<span class=\"type\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt&gt;=k)<span class=\"comment\">//选完了</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check_prime</span>(sum))  ans++;<span class=\"comment\">//判断质数,然后答案自增</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[i])<span class=\"comment\">//没被选</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i<span class=\"number\">+1</span>,cnt<span class=\"number\">+1</span>,sum+x[i]);<span class=\"comment\">//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;x[i];</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0</span></span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1238\"><a class=\"markdownIt-Anchor\" href=\"#p1238\"></a> <a href=\"https://luogu.com.cn/problem/P1238\">P1238</a> 走迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m,n;<span class=\"comment\">// m 行 n 列 </span></span><br><span class=\"line\"><span class=\"type\">int</span> mp[<span class=\"number\">20</span>][<span class=\"number\">20</span>],vis[<span class=\"number\">20</span>][<span class=\"number\">20</span>],have_solution=<span class=\"literal\">false</span>;<span class=\"comment\">//地图,是否被访问,是否有解 </span></span><br><span class=\"line\"><span class=\"type\">int</span> begin_x,begin_y,end_x,end_y;<span class=\"comment\">//起点和终点 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;;<span class=\"comment\">//偏移</span></span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">100000</span>][<span class=\"number\">3</span>],k;</span><br><span class=\"line\"><span class=\"comment\">//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出一种答案 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(have_solution==<span class=\"literal\">false</span>)  have_solution=<span class=\"literal\">true</span>;<span class=\"comment\">//更新为有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)  cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">2</span>]&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;<span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;end_x&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;end_y&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==end_x&amp;&amp;y==end_y)<span class=\"comment\">//到达终点 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nxt_x=x+dx[i],nxt_y=y+dy[i];<span class=\"comment\">//定位下一步 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]==<span class=\"number\">1</span>&amp;&amp;vis[nxt_x][nxt_y]==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">//下一步可以走并且没被访问 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">1</span>;<span class=\"comment\">//标记上一步被访问 </span></span><br><span class=\"line\">            ans[k][<span class=\"number\">1</span>]=x,ans[k][<span class=\"number\">2</span>]=y;<span class=\"comment\">//记录可行的一步 </span></span><br><span class=\"line\">            k++;<span class=\"comment\">//增加指针 </span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(nxt_x,nxt_y);<span class=\"comment\">//继续找下一步 </span></span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//回溯,设为未访问 </span></span><br><span class=\"line\">            k--;<span class=\"comment\">//倒回去 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;mp[i][j];<span class=\"comment\">//读入地图 </span></span><br><span class=\"line\">    cin&gt;&gt;begin_x&gt;&gt;begin_y&gt;&gt;end_x&gt;&gt;end_y;<span class=\"comment\">//读入起点和终点 </span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(begin_x,begin_y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!have_solution)  cout&lt;&lt;<span class=\"number\">-1</span>;<span class=\"comment\">//没有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束 :) </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"bfs\"><a class=\"markdownIt-Anchor\" href=\"#bfs\"></a> BFS</h1>\n<p>注意: <strong>BFS 不能用于加权图</strong>,因为 BFS 只会查找<strong>边数最少</strong>的路径<br />\n例如 100 -&gt; 100 和 1 -&gt; 1 -&gt; 1 -&gt; 1<br />\nBFS 会选择 100 -&gt; 100</p>\n<p>当数据范围较小（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\le20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span> ）时，用 DFS 也不是不可以</p>\n<h2 id=\"p1746\"><a class=\"markdownIt-Anchor\" href=\"#p1746\"></a> <a href=\"https://luogu.com.cn/problem/P1746\">P1746</a> 离开中山路</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//单个点的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">char</span> map[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dis[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//到起点的距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">int</span> start_x,start_y,final_x,final_y;<span class=\"comment\">//由题可得,起点和终点</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//等待处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//压入当前点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())<span class=\"comment\">//只要队列非空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//读取当前队头</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//下一个点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;n||map[nxt_x][nxt_y]==<span class=\"string\">&#x27;1&#x27;</span>||dis[nxt_x][nxt_y]&gt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//判断:越界+有障碍+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//增加 1 段距离</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">    cin&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;final_x&gt;&gt;final_y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(start_x,start_y);</span><br><span class=\"line\">    cout&lt;&lt;dis[final_x][final_y];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1443\"><a class=\"markdownIt-Anchor\" href=\"#p1443\"></a> <a href=\"https://luogu.com.cn/problem/P1443\">P1443</a> 马的遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//当前马位于的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,x,y,dis[<span class=\"number\">405</span>][<span class=\"number\">405</span>];<span class=\"comment\">//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//当前需要处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//入队处理起点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点已经有一个马了</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//取队头处理</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//生成新坐标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;m||dis[nxt_x][nxt_y]!=<span class=\"number\">-1</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//检查:越界+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新步数为上一个点+1</span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//继续压入新的点继续处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(dis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;dis[i][j];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p2895\"><a class=\"markdownIt-Anchor\" href=\"#p2895\"></a> <a href=\"https://luogu.com.cn/problem/P2895\">P2895</a> Meteor Shower S</h2>\n<p>耗时 2 个月的巅峰对决，但最终还是我赢了！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">305</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//存储坐标的点 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> m;</span><br><span class=\"line\"><span class=\"type\">int</span> mp[LEN][LEN],dis[LEN][LEN];<span class=\"comment\">//地图,距离 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//偏移 </span></span><br><span class=\"line\">queue&lt;Point&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;);<span class=\"comment\">//第一个位置是 (0,0) </span></span><br><span class=\"line\">    dis[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;<span class=\"comment\">//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point now=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//找到当前点 </span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];<span class=\"comment\">//得到下一个点的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_y&lt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//被访问</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[now.x][now.y]<span class=\"number\">+1</span>&gt;=mp[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[now.x][now.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新距离 </span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]&gt;<span class=\"number\">1e9</span>)  <span class=\"keyword\">return</span> dis[nxt_x][nxt_y];<span class=\"comment\">//没有流行砸到,答案就是当前点的距离 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mp,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(mp));<span class=\"comment\">//初始化一个足够大的数,为了在下面取到最小值 </span></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y,time;<span class=\"comment\">//坐标,流星砸下来的时间 </span></span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;time;</span><br><span class=\"line\">        mp[x][y]=<span class=\"built_in\">min</span>(mp[x][y],time);<span class=\"comment\">//取砸下来的最小值 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=x+dx[d],nxt_y=y+dy[d];<span class=\"comment\">//得到即将蔓延的点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_x&gt;<span class=\"number\">301</span>||nxt_y&lt;<span class=\"number\">0</span>||nxt_y&gt;<span class=\"number\">301</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            mp[nxt_x][nxt_y]=<span class=\"built_in\">min</span>(mp[nxt_x][nxt_y],time);<span class=\"comment\">//继续取最小值 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">bfs</span>();</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>本文整理了 ED_Builder 在初学搜索算法时做的题目</p>","more":"<h1 id=\"dfs\"><a class=\"markdownIt-Anchor\" href=\"#dfs\"></a> DFS</h1>\n<h2 id=\"p1219\"><a class=\"markdownIt-Anchor\" href=\"#p1219\"></a> <a href=\"https://luogu.com.cn/problem/P1219\">P1219</a> 八皇后</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>],ans;<span class=\"comment\">//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis_lie[<span class=\"number\">30</span>],vis_l[<span class=\"number\">30</span>],vis_r[<span class=\"number\">30</span>];<span class=\"comment\">//记录当前列(|),左斜(/),右斜(\\)是否被访问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans&gt;<span class=\"number\">3</span>)  <span class=\"keyword\">return</span>;<span class=\"comment\">//由题可得,只需要输出 3 种排列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//形参 x :当前是第 x 个皇后</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//一种可行的方案达成</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;<span class=\"comment\">//方案数++</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//枚举所有答案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis_lie[i]&amp;&amp;!vis_l[x-i+n]&amp;&amp;!vis_r[x+i])<span class=\"comment\">//是否被访问过(规律见 L40 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">true</span>,vis_l[x-i+n]=<span class=\"literal\">true</span>,vis_r[x+i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//存答案</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">false</span>,vis_l[x-i+n]=<span class=\"literal\">false</span>,vis_r[x+i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"p1706\"><a class=\"markdownIt-Anchor\" href=\"#p1706\"></a> <a href=\"https://luogu.com.cn/problem/P1706\">P1706</a> 全排列问题</h2>\n<h3 id=\"p1-dfs\"><a class=\"markdownIt-Anchor\" href=\"#p1-dfs\"></a> P1 - DFS</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>];<span class=\"comment\">//枚举 n 个数字,可行的答案存放在 a 中</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">20</span>];<span class=\"comment\">//已经被访问过的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;a[i];</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//已经有了一个方案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i])<span class=\"comment\">//没被访问</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//记录答案</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);<span class=\"comment\">//从 1 开始</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"p2-枚举优化\"><a class=\"markdownIt-Anchor\" href=\"#p2-枚举优化\"></a> P2 - 枚举优化</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> num[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  num[i]=i;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;num[i];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(num<span class=\"number\">+1</span>,num<span class=\"number\">+1</span>+n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1605\"><a class=\"markdownIt-Anchor\" href=\"#p1605\"></a> <a href=\"https://luogu.com.cn/problem/P1605\">P1605</a> 迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span><span class=\"comment\">//这里不用万能头是因为想用 map 当变量名</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,t,sx,sy,fx,fy,ans;</span><br><span class=\"line\"><span class=\"comment\">//地图长宽,障碍数量,起点坐标,终点坐标,答案</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">bool</span> map[<span class=\"number\">10</span>][<span class=\"number\">10</span>];<span class=\"comment\">//地图</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==fx&amp;&amp;y==fy)<span class=\"comment\">//到达终点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp_x=dx[i]+x,tmp_y=dy[i]+y;<span class=\"comment\">//移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp_x&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_x&lt;=n&amp;&amp;tmp_y&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_y&lt;=m&amp;&amp;map[tmp_x][tmp_y])</span><br><span class=\"line\">        <span class=\"comment\">//合法判断:坐标未越界,位置可用(没有障碍且没被访问)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记访问</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(tmp_x,tmp_y);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(map,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(map));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)<span class=\"comment\">//读入障碍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        map[x][y]=<span class=\"literal\">false</span>;<span class=\"comment\">//不能走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map[sx][sy]=<span class=\"literal\">false</span>;<span class=\"comment\">//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(sx,sy);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1036\"><a class=\"markdownIt-Anchor\" href=\"#p1036\"></a> <a href=\"https://luogu.com.cn/problem/P1036\">P1036</a> 选数</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,x[<span class=\"number\">25</span>],ans;<span class=\"comment\">//共有 n 个数,要选 k 个数,答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">25</span>];<span class=\"comment\">//是否已经被选择</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_prime</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//判断质数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"built_in\">sqrt</span>(n);i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> pos,<span class=\"type\">int</span> cnt,<span class=\"type\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt&gt;=k)<span class=\"comment\">//选完了</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check_prime</span>(sum))  ans++;<span class=\"comment\">//判断质数,然后答案自增</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[i])<span class=\"comment\">//没被选</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i<span class=\"number\">+1</span>,cnt<span class=\"number\">+1</span>,sum+x[i]);<span class=\"comment\">//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;x[i];</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0</span></span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1238\"><a class=\"markdownIt-Anchor\" href=\"#p1238\"></a> <a href=\"https://luogu.com.cn/problem/P1238\">P1238</a> 走迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m,n;<span class=\"comment\">// m 行 n 列 </span></span><br><span class=\"line\"><span class=\"type\">int</span> mp[<span class=\"number\">20</span>][<span class=\"number\">20</span>],vis[<span class=\"number\">20</span>][<span class=\"number\">20</span>],have_solution=<span class=\"literal\">false</span>;<span class=\"comment\">//地图,是否被访问,是否有解 </span></span><br><span class=\"line\"><span class=\"type\">int</span> begin_x,begin_y,end_x,end_y;<span class=\"comment\">//起点和终点 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;;<span class=\"comment\">//偏移</span></span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">100000</span>][<span class=\"number\">3</span>],k;</span><br><span class=\"line\"><span class=\"comment\">//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出一种答案 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(have_solution==<span class=\"literal\">false</span>)  have_solution=<span class=\"literal\">true</span>;<span class=\"comment\">//更新为有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)  cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">2</span>]&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;<span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;end_x&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;end_y&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==end_x&amp;&amp;y==end_y)<span class=\"comment\">//到达终点 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nxt_x=x+dx[i],nxt_y=y+dy[i];<span class=\"comment\">//定位下一步 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]==<span class=\"number\">1</span>&amp;&amp;vis[nxt_x][nxt_y]==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">//下一步可以走并且没被访问 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">1</span>;<span class=\"comment\">//标记上一步被访问 </span></span><br><span class=\"line\">            ans[k][<span class=\"number\">1</span>]=x,ans[k][<span class=\"number\">2</span>]=y;<span class=\"comment\">//记录可行的一步 </span></span><br><span class=\"line\">            k++;<span class=\"comment\">//增加指针 </span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(nxt_x,nxt_y);<span class=\"comment\">//继续找下一步 </span></span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//回溯,设为未访问 </span></span><br><span class=\"line\">            k--;<span class=\"comment\">//倒回去 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;mp[i][j];<span class=\"comment\">//读入地图 </span></span><br><span class=\"line\">    cin&gt;&gt;begin_x&gt;&gt;begin_y&gt;&gt;end_x&gt;&gt;end_y;<span class=\"comment\">//读入起点和终点 </span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(begin_x,begin_y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!have_solution)  cout&lt;&lt;<span class=\"number\">-1</span>;<span class=\"comment\">//没有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束 :) </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"bfs\"><a class=\"markdownIt-Anchor\" href=\"#bfs\"></a> BFS</h1>\n<p>注意: <strong>BFS 不能用于加权图</strong>,因为 BFS 只会查找<strong>边数最少</strong>的路径<br />\n例如 100 -&gt; 100 和 1 -&gt; 1 -&gt; 1 -&gt; 1<br />\nBFS 会选择 100 -&gt; 100</p>\n<p>当数据范围较小（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\le20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span> ）时，用 DFS 也不是不可以</p>\n<h2 id=\"p1746\"><a class=\"markdownIt-Anchor\" href=\"#p1746\"></a> <a href=\"https://luogu.com.cn/problem/P1746\">P1746</a> 离开中山路</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//单个点的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">char</span> map[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dis[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//到起点的距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">int</span> start_x,start_y,final_x,final_y;<span class=\"comment\">//由题可得,起点和终点</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//等待处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//压入当前点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())<span class=\"comment\">//只要队列非空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//读取当前队头</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//下一个点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;n||map[nxt_x][nxt_y]==<span class=\"string\">&#x27;1&#x27;</span>||dis[nxt_x][nxt_y]&gt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//判断:越界+有障碍+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//增加 1 段距离</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">    cin&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;final_x&gt;&gt;final_y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(start_x,start_y);</span><br><span class=\"line\">    cout&lt;&lt;dis[final_x][final_y];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1443\"><a class=\"markdownIt-Anchor\" href=\"#p1443\"></a> <a href=\"https://luogu.com.cn/problem/P1443\">P1443</a> 马的遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//当前马位于的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,x,y,dis[<span class=\"number\">405</span>][<span class=\"number\">405</span>];<span class=\"comment\">//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//当前需要处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//入队处理起点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点已经有一个马了</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//取队头处理</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//生成新坐标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;m||dis[nxt_x][nxt_y]!=<span class=\"number\">-1</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//检查:越界+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新步数为上一个点+1</span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//继续压入新的点继续处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(dis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;dis[i][j];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p2895\"><a class=\"markdownIt-Anchor\" href=\"#p2895\"></a> <a href=\"https://luogu.com.cn/problem/P2895\">P2895</a> Meteor Shower S</h2>\n<p>耗时 2 个月的巅峰对决，但最终还是我赢了！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">305</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//存储坐标的点 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> m;</span><br><span class=\"line\"><span class=\"type\">int</span> mp[LEN][LEN],dis[LEN][LEN];<span class=\"comment\">//地图,距离 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//偏移 </span></span><br><span class=\"line\">queue&lt;Point&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;);<span class=\"comment\">//第一个位置是 (0,0) </span></span><br><span class=\"line\">    dis[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;<span class=\"comment\">//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point now=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//找到当前点 </span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];<span class=\"comment\">//得到下一个点的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_y&lt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//被访问</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[now.x][now.y]<span class=\"number\">+1</span>&gt;=mp[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[now.x][now.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新距离 </span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]&gt;<span class=\"number\">1e9</span>)  <span class=\"keyword\">return</span> dis[nxt_x][nxt_y];<span class=\"comment\">//没有流行砸到,答案就是当前点的距离 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mp,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(mp));<span class=\"comment\">//初始化一个足够大的数,为了在下面取到最小值 </span></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y,time;<span class=\"comment\">//坐标,流星砸下来的时间 </span></span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;time;</span><br><span class=\"line\">        mp[x][y]=<span class=\"built_in\">min</span>(mp[x][y],time);<span class=\"comment\">//取砸下来的最小值 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=x+dx[d],nxt_y=y+dy[d];<span class=\"comment\">//得到即将蔓延的点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_x&gt;<span class=\"number\">301</span>||nxt_y&lt;<span class=\"number\">0</span>||nxt_y&gt;<span class=\"number\">301</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            mp[nxt_x][nxt_y]=<span class=\"built_in\">min</span>(mp[nxt_x][nxt_y],time);<span class=\"comment\">//继续取最小值 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">bfs</span>();</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"图论 - 最小生成树","date":"2025-07-10T12:01:47.000Z","banner":"https://imghub.ed-builder.top/file/1751761219115_5.png","cover":"https://imghub.ed-builder.top/file/1751761219115_5.png","poster":{"headline":"图论 - 最小生成树","topic":"大多适用于连接各种节点"},"katex":true,"author":"ED_Builder","_content":"\n本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal\n\n<!-- more -->\n\n# Prim（加点法）\n## 基本信息\n每次迭代选择边权最小的边对应的点，加入到最小生成树中。  \n算法从某个顶点 $start$ 开始，逐渐延伸覆盖整个连通网的所有顶点\n![pic-solution](https://imghub.ed-builder.top/file/1751761219115_5.png)\n\n时间复杂度：$O(n^2)$\n## 算法思想\n蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。  \n每次循环都将一个蓝点 $u$ 变为白点，并且这个蓝点 $u$ 与白点相连的最小边权 `min(weight[u])` 还是当前所有蓝点中最小的。  \n这样相当于向生成树中添加了 $n-1$ 次最小的边，最后得到的一定是最小生成树\n## 算法描述\n以 $1$ 为起点生成最小生成树，`min[v]` 表示蓝点 `v` 与白点相连的最小边权，`mst` 表示最小生成树的权值之和\n1. 初始化：`min[v]=INF`$(v\\ne 1)$ &nbsp; `min[1]=0` &nbsp; `mst=0`\n2.   \n```cpp\nfor(int i=1;i<=n;i++)\n{\n\t1. 寻找 min[u] 最小的蓝点 u\n\t2. 将 u 标记为白点\n\t3. mst+=min[u];\n\t4. for(与白点 u 相连的所有蓝点 v)\n\t\tif(weight[u][v]<min[v])\n\t\t\tmin[v]=weight[u][v];\n}\n```\n3. 算法结束，`mst` 即为最小生成树的权值之和\n## 例题 - [YBT 1349](https://ybt.ssoier.cn/problem_show.php?pid=1349)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN];\nint minn[LEN];\nbool vis[LEN];\nint n,mst=0;\nvoid init()\n{\n    memset(minn,INF,sizeof(minn));\n    minn[1]=0;\n    memset(vis,true,sizeof(vis));\n}\nint main()\n{\n    cin>>n;\n\tinit();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>graph[i][j];\n    for(int i=1;i<=n;i++)\n    {\n        int k=0;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(minn[j]<minn[k]))\n                k=j;\n        vis[k]=false;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(graph[k][j]<minn[j]))\n                minn[j]=graph[k][j];\n    }\n    for(int i=1;i<=n;i++)  mst+=minn[i];\n    cout<<mst;\n    return 0;\n}\n```\n# Kruskal\n## 基本信息\n- Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。\n- Kruskal 算法将一个连通块当做一个集合。\n\n时间复杂度为 $O(E\\ log(E))$，E为边数。\n## 算法思想\n1. 首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 $n$ 个独立的集合。\n2. 然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。\n3. 直到选取了 $n-1$ 条边为止。\n\n通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的\n边，一张 $n$ 个顶点的图总共选取 $n-1$ 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 $n$ 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 $n-1$ 条边，连接着 $n$ 个顶点的最小生成树。\n## 算法描述\n1. 初始化并查集：`fa[x]=x`，初始化总权值和：`mst=0`\n2. 将所有边用快排 **从小到大** 排序\n3. 计数器 `k=0`\n4.   \n```cpp\nfor(int i=1;i<=m;i++)\n{\n    if(这是一条 u,v 不属于同一集合的边 u->v)\n    {\n        1. 合并 u,v 所在的集合，相当于把 u->v 加入最小生成树\n        2. mst+=weight[u][v]\n        3. k++;\n        4. if(k==n-1)  break; 最小生成树已经生成，跳出循环\n    }\n}\n```\n5. 算法结束，`mst` 即为最小生成树的总权值之和\n## 例题 - [Luogu P3366](https://luogu.com.cn/problem/P3366)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=2e5+5;\nstruct Edge\n{\n    int u,v,w;\n}edge[LEN];\nint cnt;\nint fa[5005];\nint n,m,mst=0,edges_cnt=0;\nint find(int x)\n{\n    if(fa[x]!=x)  fa[x]=find(fa[x]);\n    return fa[x];\n}\nvoid merge(int x,int y)\n{\n    int fx=find(x);\n    int fy=find(y);\n    if(fx!=fy)  fa[fx]=fy;\n    return;\n}\nvoid addedge(int u,int v,int w)\n{\n    cnt+=1;\n    edge[cnt].u=u;\n    edge[cnt].v=v;\n    edge[cnt].w=w;\n    return;\n}\nbool cmp(Edge a,Edge b){return a.w<b.w;}\nsigned main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        addedge(u,v,w);\n    }\n    for(int i=1;i<=n;i++)  fa[i]=i;\n    stable_sort(edge+1,edge+cnt+1,cmp);\n    for(int i=1;i<=cnt;i++)\n    {\n        if(find(edge[i].u)!=find(edge[i].v))\n        {\n            merge(edge[i].u,edge[i].v);\n            mst+=edge[i].w;\n            edges_cnt++;\n        }\n        if(edges_cnt==m)  break;\n    }\n    if(edges_cnt<n-1)  cout<<\"orz\";\n    else  cout<<mst;\n    return 0;\n}\n```","source":"_posts/最小生成树.md","raw":"---\ntitle: 图论 - 最小生成树\ndate: 2025-07-10 20:01:47\nbanner: https://imghub.ed-builder.top/file/1751761219115_5.png\ncover: https://imghub.ed-builder.top/file/1751761219115_5.png\ntags: ['图论', '最小生成树', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 图论 - 最小生成树\n    topic: 大多适用于连接各种节点\nkatex: true\nauthor: ED_Builder\n---\n\n本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal\n\n<!-- more -->\n\n# Prim（加点法）\n## 基本信息\n每次迭代选择边权最小的边对应的点，加入到最小生成树中。  \n算法从某个顶点 $start$ 开始，逐渐延伸覆盖整个连通网的所有顶点\n![pic-solution](https://imghub.ed-builder.top/file/1751761219115_5.png)\n\n时间复杂度：$O(n^2)$\n## 算法思想\n蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。  \n每次循环都将一个蓝点 $u$ 变为白点，并且这个蓝点 $u$ 与白点相连的最小边权 `min(weight[u])` 还是当前所有蓝点中最小的。  \n这样相当于向生成树中添加了 $n-1$ 次最小的边，最后得到的一定是最小生成树\n## 算法描述\n以 $1$ 为起点生成最小生成树，`min[v]` 表示蓝点 `v` 与白点相连的最小边权，`mst` 表示最小生成树的权值之和\n1. 初始化：`min[v]=INF`$(v\\ne 1)$ &nbsp; `min[1]=0` &nbsp; `mst=0`\n2.   \n```cpp\nfor(int i=1;i<=n;i++)\n{\n\t1. 寻找 min[u] 最小的蓝点 u\n\t2. 将 u 标记为白点\n\t3. mst+=min[u];\n\t4. for(与白点 u 相连的所有蓝点 v)\n\t\tif(weight[u][v]<min[v])\n\t\t\tmin[v]=weight[u][v];\n}\n```\n3. 算法结束，`mst` 即为最小生成树的权值之和\n## 例题 - [YBT 1349](https://ybt.ssoier.cn/problem_show.php?pid=1349)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN];\nint minn[LEN];\nbool vis[LEN];\nint n,mst=0;\nvoid init()\n{\n    memset(minn,INF,sizeof(minn));\n    minn[1]=0;\n    memset(vis,true,sizeof(vis));\n}\nint main()\n{\n    cin>>n;\n\tinit();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>graph[i][j];\n    for(int i=1;i<=n;i++)\n    {\n        int k=0;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(minn[j]<minn[k]))\n                k=j;\n        vis[k]=false;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(graph[k][j]<minn[j]))\n                minn[j]=graph[k][j];\n    }\n    for(int i=1;i<=n;i++)  mst+=minn[i];\n    cout<<mst;\n    return 0;\n}\n```\n# Kruskal\n## 基本信息\n- Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。\n- Kruskal 算法将一个连通块当做一个集合。\n\n时间复杂度为 $O(E\\ log(E))$，E为边数。\n## 算法思想\n1. 首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 $n$ 个独立的集合。\n2. 然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。\n3. 直到选取了 $n-1$ 条边为止。\n\n通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的\n边，一张 $n$ 个顶点的图总共选取 $n-1$ 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 $n$ 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 $n-1$ 条边，连接着 $n$ 个顶点的最小生成树。\n## 算法描述\n1. 初始化并查集：`fa[x]=x`，初始化总权值和：`mst=0`\n2. 将所有边用快排 **从小到大** 排序\n3. 计数器 `k=0`\n4.   \n```cpp\nfor(int i=1;i<=m;i++)\n{\n    if(这是一条 u,v 不属于同一集合的边 u->v)\n    {\n        1. 合并 u,v 所在的集合，相当于把 u->v 加入最小生成树\n        2. mst+=weight[u][v]\n        3. k++;\n        4. if(k==n-1)  break; 最小生成树已经生成，跳出循环\n    }\n}\n```\n5. 算法结束，`mst` 即为最小生成树的总权值之和\n## 例题 - [Luogu P3366](https://luogu.com.cn/problem/P3366)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=2e5+5;\nstruct Edge\n{\n    int u,v,w;\n}edge[LEN];\nint cnt;\nint fa[5005];\nint n,m,mst=0,edges_cnt=0;\nint find(int x)\n{\n    if(fa[x]!=x)  fa[x]=find(fa[x]);\n    return fa[x];\n}\nvoid merge(int x,int y)\n{\n    int fx=find(x);\n    int fy=find(y);\n    if(fx!=fy)  fa[fx]=fy;\n    return;\n}\nvoid addedge(int u,int v,int w)\n{\n    cnt+=1;\n    edge[cnt].u=u;\n    edge[cnt].v=v;\n    edge[cnt].w=w;\n    return;\n}\nbool cmp(Edge a,Edge b){return a.w<b.w;}\nsigned main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        addedge(u,v,w);\n    }\n    for(int i=1;i<=n;i++)  fa[i]=i;\n    stable_sort(edge+1,edge+cnt+1,cmp);\n    for(int i=1;i<=cnt;i++)\n    {\n        if(find(edge[i].u)!=find(edge[i].v))\n        {\n            merge(edge[i].u,edge[i].v);\n            mst+=edge[i].w;\n            edges_cnt++;\n        }\n        if(edges_cnt==m)  break;\n    }\n    if(edges_cnt<n-1)  cout<<\"orz\";\n    else  cout<<mst;\n    return 0;\n}\n```","slug":"最小生成树","published":1,"updated":"2025-08-25T04:41:24.453Z","_id":"cmebjcswz0009c4bo7syg4cxf","comments":1,"layout":"post","photos":[],"content":"<p>本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal</p>\n<span id=\"more\"></span>\n<h1 id=\"prim加点法\"><a class=\"markdownIt-Anchor\" href=\"#prim加点法\"></a> Prim（加点法）</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>每次迭代选择边权最小的边对应的点，加入到最小生成树中。<br />\n算法从某个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">start</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span></span></span></span> 开始，逐渐延伸覆盖整个连通网的所有顶点<br />\n<img src=\"https://imghub.ed-builder.top/file/1751761219115_5.png\" alt=\"pic-solution\" /></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法思想\"><a class=\"markdownIt-Anchor\" href=\"#算法思想\"></a> 算法思想</h2>\n<p>蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。<br />\n每次循环都将一个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 变为白点，并且这个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与白点相连的最小边权 <code>min(weight[u])</code> 还是当前所有蓝点中最小的。<br />\n这样相当于向生成树中添加了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次最小的边，最后得到的一定是最小生成树</p>\n<h2 id=\"算法描述\"><a class=\"markdownIt-Anchor\" href=\"#算法描述\"></a> 算法描述</h2>\n<p>以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为起点生成最小生成树，<code>min[v]</code> 表示蓝点 <code>v</code> 与白点相连的最小边权，<code>mst</code> 表示最小生成树的权值之和</p>\n<ol>\n<li>初始化：<code>min[v]=INF</code><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo mathvariant=\"normal\">≠</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(v\\ne 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>   <code>min[1]=0</code>   <code>mst=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">1.</span> 寻找 min[u] 最小的蓝点 u</span><br><span class=\"line\">    <span class=\"number\">2.</span> 将 u 标记为白点</span><br><span class=\"line\">    <span class=\"number\">3.</span> mst+=min[u];</span><br><span class=\"line\">    <span class=\"number\">4.</span> <span class=\"keyword\">for</span>(与白点 u 相连的所有蓝点 v)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(weight[u][v]&lt;min[v])</span><br><span class=\"line\">            min[v]=weight[u][v];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>算法结束，<code>mst</code> 即为最小生成树的权值之和</li>\n</ol>\n<h2 id=\"例题-ybt-1349\"><a class=\"markdownIt-Anchor\" href=\"#例题-ybt-1349\"></a> 例题 - <a href=\"https://ybt.ssoier.cn/problem_show.php?pid=1349\">YBT 1349</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> minn[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,mst=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(minn,INF,<span class=\"built_in\">sizeof</span>(minn));</span><br><span class=\"line\">    minn[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;graph[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(minn[j]&lt;minn[k]))</span><br><span class=\"line\">                k=j;</span><br><span class=\"line\">        vis[k]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(graph[k][j]&lt;minn[j]))</span><br><span class=\"line\">                minn[j]=graph[k][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  mst+=minn[i];</span><br><span class=\"line\">    cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"kruskal\"><a class=\"markdownIt-Anchor\" href=\"#kruskal\"></a> Kruskal</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<ul>\n<li>Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。</li>\n<li>Kruskal 算法将一个连通块当做一个集合。</li>\n</ul>\n<p>时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(E\\ log(E))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，E为边数。</p>\n<h2 id=\"算法思想-2\"><a class=\"markdownIt-Anchor\" href=\"#算法思想-2\"></a> 算法思想</h2>\n<ol>\n<li>首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个独立的集合。</li>\n<li>然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。</li>\n<li>直到选取了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边为止。</li>\n</ol>\n<p>通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的<br />\n边，一张 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的图总共选取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边，连接着 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最小生成树。</p>\n<h2 id=\"算法描述-2\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-2\"></a> 算法描述</h2>\n<ol>\n<li>初始化并查集：<code>fa[x]=x</code>，初始化总权值和：<code>mst=0</code></li>\n<li>将所有边用快排 <strong>从小到大</strong> 排序</li>\n<li>计数器 <code>k=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(这是一条 u,v 不属于同一集合的边 u-&gt;v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"number\">1.</span> 合并 u,v 所在的集合，相当于把 u-&gt;v 加入最小生成树</span><br><span class=\"line\">        <span class=\"number\">2.</span> mst+=weight[u][v]</span><br><span class=\"line\">        <span class=\"number\">3.</span> k++;</span><br><span class=\"line\">        <span class=\"number\">4.</span> <span class=\"keyword\">if</span>(k==n<span class=\"number\">-1</span>)  <span class=\"keyword\">break</span>; 最小生成树已经生成，跳出循环</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>算法结束，<code>mst</code> 即为最小生成树的总权值之和</li>\n</ol>\n<h2 id=\"例题-luogu-p3366\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3366\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3366\">Luogu P3366</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> fa[<span class=\"number\">5005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,mst=<span class=\"number\">0</span>,edges_cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fa[x]!=x)  fa[x]=<span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fa[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fx=<span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">    <span class=\"type\">int</span> fy=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fx!=fy)  fa[fx]=fy;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    edge[cnt].u=u;</span><br><span class=\"line\">    edge[cnt].v=v;</span><br><span class=\"line\">    edge[cnt].w=w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge a,Edge b)</span></span>&#123;<span class=\"keyword\">return</span> a.w&lt;b.w;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  fa[i]=i;</span><br><span class=\"line\">    <span class=\"built_in\">stable_sort</span>(edge<span class=\"number\">+1</span>,edge+cnt<span class=\"number\">+1</span>,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(edge[i].u)!=<span class=\"built_in\">find</span>(edge[i].v))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">merge</span>(edge[i].u,edge[i].v);</span><br><span class=\"line\">            mst+=edge[i].w;</span><br><span class=\"line\">            edges_cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges_cnt==m)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(edges_cnt&lt;n<span class=\"number\">-1</span>)  cout&lt;&lt;<span class=\"string\">&quot;orz&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal</p>","more":"<h1 id=\"prim加点法\"><a class=\"markdownIt-Anchor\" href=\"#prim加点法\"></a> Prim（加点法）</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>每次迭代选择边权最小的边对应的点，加入到最小生成树中。<br />\n算法从某个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">start</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span></span></span></span> 开始，逐渐延伸覆盖整个连通网的所有顶点<br />\n<img src=\"https://imghub.ed-builder.top/file/1751761219115_5.png\" alt=\"pic-solution\" /></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法思想\"><a class=\"markdownIt-Anchor\" href=\"#算法思想\"></a> 算法思想</h2>\n<p>蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。<br />\n每次循环都将一个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 变为白点，并且这个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与白点相连的最小边权 <code>min(weight[u])</code> 还是当前所有蓝点中最小的。<br />\n这样相当于向生成树中添加了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次最小的边，最后得到的一定是最小生成树</p>\n<h2 id=\"算法描述\"><a class=\"markdownIt-Anchor\" href=\"#算法描述\"></a> 算法描述</h2>\n<p>以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为起点生成最小生成树，<code>min[v]</code> 表示蓝点 <code>v</code> 与白点相连的最小边权，<code>mst</code> 表示最小生成树的权值之和</p>\n<ol>\n<li>初始化：<code>min[v]=INF</code><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo mathvariant=\"normal\">≠</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(v\\ne 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>   <code>min[1]=0</code>   <code>mst=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">1.</span> 寻找 min[u] 最小的蓝点 u</span><br><span class=\"line\">    <span class=\"number\">2.</span> 将 u 标记为白点</span><br><span class=\"line\">    <span class=\"number\">3.</span> mst+=min[u];</span><br><span class=\"line\">    <span class=\"number\">4.</span> <span class=\"keyword\">for</span>(与白点 u 相连的所有蓝点 v)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(weight[u][v]&lt;min[v])</span><br><span class=\"line\">            min[v]=weight[u][v];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>算法结束，<code>mst</code> 即为最小生成树的权值之和</li>\n</ol>\n<h2 id=\"例题-ybt-1349\"><a class=\"markdownIt-Anchor\" href=\"#例题-ybt-1349\"></a> 例题 - <a href=\"https://ybt.ssoier.cn/problem_show.php?pid=1349\">YBT 1349</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> minn[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,mst=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(minn,INF,<span class=\"built_in\">sizeof</span>(minn));</span><br><span class=\"line\">    minn[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;graph[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(minn[j]&lt;minn[k]))</span><br><span class=\"line\">                k=j;</span><br><span class=\"line\">        vis[k]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(graph[k][j]&lt;minn[j]))</span><br><span class=\"line\">                minn[j]=graph[k][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  mst+=minn[i];</span><br><span class=\"line\">    cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"kruskal\"><a class=\"markdownIt-Anchor\" href=\"#kruskal\"></a> Kruskal</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<ul>\n<li>Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。</li>\n<li>Kruskal 算法将一个连通块当做一个集合。</li>\n</ul>\n<p>时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(E\\ log(E))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，E为边数。</p>\n<h2 id=\"算法思想-2\"><a class=\"markdownIt-Anchor\" href=\"#算法思想-2\"></a> 算法思想</h2>\n<ol>\n<li>首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个独立的集合。</li>\n<li>然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。</li>\n<li>直到选取了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边为止。</li>\n</ol>\n<p>通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的<br />\n边，一张 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的图总共选取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边，连接着 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最小生成树。</p>\n<h2 id=\"算法描述-2\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-2\"></a> 算法描述</h2>\n<ol>\n<li>初始化并查集：<code>fa[x]=x</code>，初始化总权值和：<code>mst=0</code></li>\n<li>将所有边用快排 <strong>从小到大</strong> 排序</li>\n<li>计数器 <code>k=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(这是一条 u,v 不属于同一集合的边 u-&gt;v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"number\">1.</span> 合并 u,v 所在的集合，相当于把 u-&gt;v 加入最小生成树</span><br><span class=\"line\">        <span class=\"number\">2.</span> mst+=weight[u][v]</span><br><span class=\"line\">        <span class=\"number\">3.</span> k++;</span><br><span class=\"line\">        <span class=\"number\">4.</span> <span class=\"keyword\">if</span>(k==n<span class=\"number\">-1</span>)  <span class=\"keyword\">break</span>; 最小生成树已经生成，跳出循环</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>算法结束，<code>mst</code> 即为最小生成树的总权值之和</li>\n</ol>\n<h2 id=\"例题-luogu-p3366\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3366\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3366\">Luogu P3366</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> fa[<span class=\"number\">5005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,mst=<span class=\"number\">0</span>,edges_cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fa[x]!=x)  fa[x]=<span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fa[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fx=<span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">    <span class=\"type\">int</span> fy=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fx!=fy)  fa[fx]=fy;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    edge[cnt].u=u;</span><br><span class=\"line\">    edge[cnt].v=v;</span><br><span class=\"line\">    edge[cnt].w=w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge a,Edge b)</span></span>&#123;<span class=\"keyword\">return</span> a.w&lt;b.w;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  fa[i]=i;</span><br><span class=\"line\">    <span class=\"built_in\">stable_sort</span>(edge<span class=\"number\">+1</span>,edge+cnt<span class=\"number\">+1</span>,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(edge[i].u)!=<span class=\"built_in\">find</span>(edge[i].v))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">merge</span>(edge[i].u,edge[i].v);</span><br><span class=\"line\">            mst+=edge[i].w;</span><br><span class=\"line\">            edges_cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges_cnt==m)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(edges_cnt&lt;n<span class=\"number\">-1</span>)  cout&lt;&lt;<span class=\"string\">&quot;orz&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"图的存储 - 链式前向星","date":"2025-07-15T08:23:05.000Z","poster":{"headline":"图的存储 - 链式前向星","topic":"应用场景非常广泛，很多算法都可用到！"},"katex":true,"author":"ED_Builder","_content":"\n其实本质上就是用链表实现的邻接表\n\n<!-- more -->\n\n## 基本信息\n链式前向星是图论中一种 ~~牛逼~~ 高效的存储结构\n\n时间复杂度：  \n- 添加边：$O(1)$  \n  和邻接矩阵的复杂度一样，但是我们要在 `head` 数组的末尾添加新边，并更新头指针\n- 遍历节点的出边：$O(k)$  \n  其中：$k$ 为这个节点的出边数量。直接通过头指针开始遍历链表即可\n- 断边：最坏情况 $O(m)$  \n  需要遍历 `edges` 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星\n- 删除节点：$O(n)$  \n  需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）\n\n空间复杂度：$O(n+m)$，其中：$n$ 为节点数，$m$ 为边数\n## 添加与遍历\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int NODE_LEN=1e5+5;\nconst int EDGE_LEN=2e5+5;\n//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边\n\n//定义边，存储指向的目标节点和下一条边的索引，以及边权\nstruct Edge\n{\n    int to,nxt,weight;\n}edges[EDGE_LEN];//图中的所有边\n\nint head[NODE_LEN];//对于每一条边，记录第一条边在 edges 数组中的下标\nint cnt_edge=0;//边的数量\n\nvoid add_edge(int u,int v,int w)//添加一条边，由出发节点 u 到目标节点 v ，边权为 w\n{\n    edges[cnt_edge].to=v;\n    //当前计数边（也就是目前输入的第几个边）将会指向目标节点 v\n\n    edges[cnt_edge].nxt=head[u];\n    head[u]=cnt_edge;\n    //下一条边\n    edges[cnt_edge].weight=w;//由出发节点伸出的边的权值\n    cnt_edge++;//存完一个啦！提前准备好下一个！\n    cout<<\"添加边：( \"<<u<<\" -> \"<<v<<\" ) 成功！且权值为 \"<<w<<endl;\n    return;\n}\n\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //由于下面就是示例了，所以就用局部变量了\n    int n;//共计 n 个节点\n    cin>>n;\n    for(int i=1;i<=n;i++)//读入节点\n    {\n        int u,v,w;//出发节点和目标节点\n        cin>>u>>v>>w;\n        add_edge(u,v,w);\n        //add_edge(v,u,w);\n        //请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！\n    }\n    for(int i=1;i<=n;i++)  traverse_nodes(i);//遍历节点 i\n    exit(0);\n}\n```\n提示：学到这里已经足够应对大部分算法了，链式前向星 **非常不适合删除操作**\n\n---\n## 断边\n下面介绍如何在链式前向星数据结构上增加删除边的功能。\n\n需要注意的是，链式前向星本质上是一种一边 **只增不减** 的“静态”存储方式  \n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。  \n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。\n\n{% note color:red\n注意： \n1. 如果你的图中 **经常需要删除边** ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。\n%}\n\n### 1. 增加删除边所需要的代码\n假设我们在前面的加权图结构基础上（包括 `to`、`weight` 和 `nxt` 字段）进行扩展。我们给出一个 `delete_edge` 函数，函数参数为起点 `u` 和目标 `v` ，表示删除一条从 `u` 到 `v` 的边（如果存在多条，则只删除第一个碰到的）。\n\n我们来逐步说明删除边的思路，再给出代码：\n1. **找到目标边所在的链表位置**  \n   对于某个起点 `u` ，其边链表保存在从 `head[u]` 开始的一条单链表中。我们用两个变量：  \n   - `cur` 用于遍历链表，初始设为 `head[u]` 。  \n   - `pre` 记录前驱节点的索引，初始为 `-1`（表示当前边是链表的第一个）。\n2. **遍历链表，搜索符合条件的边**  \n   从 `cur` 开始，遍历链表：如果发现 `edges[cur].to==v`（满足目标条件），则说明找到了要删除的边。\n3. **更新指针实现删除**  \n   - 如果 `pre` 为 `-1`，说明要删除的边正好位于链表头部，此时更新 `head[u]=edges[cur].nxt`；  \n   - 否则，将前驱边的 `nxt` 指针更新为 `edges[cur].nxt`，这样跳过了当前边。\n4. **结束遍历**  \n   找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。\n\n下面是完整的删除边函数代码：\n```cpp\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n```\n\n### 2. 遍历节点，验证删除功能\n为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。  \n（其实这已经在 添加与遍历 演示了）\n```cpp\n// 遍历并输出结点 u 的所有出边（包括边的终点和权值）\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n```\n### 3. 示例\n下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：\n```cpp\n/*\n省略，真的太长了...\n可以翻到上面看看 添加与遍历\n*/\n\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //这是张 **无向图** \n    add_edge(1,2,5);add_edge(2,1,5);\n    add_edge(1,3,10);add_edge(3,1,10);\n    add_edge(1,4,3);add_edge(4,1,3);\n    add_edge(2,3,7);add_edge(3,2,7);\n    cout<<\"建边后的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    delete_edge(1,3);\n    cout<<\"现在的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    exit(0);\n}\n```\n示例中的初始图长这样：  \n![graph](https://imghub.ed-builder.top/file/1746946383810_graph.png)\n#### 程序执行过程说明\n1. **添加边阶段：**  \n   - 对于结点 1，经过多次调用 `add_edge(1, ...)`，其边链表可能为（头插法的结果是最新添加的边在链表头）：  \n     - 头部指向边：1 -> 4  \n     - 通过 `nxt` 链到边：1 -> 3  \n     - 再通过 `nxt` 链到边：1 -> 2  \n   - 结点 2 拥有边：2 -> 3。\n\n2. **删除操作：**  \n   - 调用 `delete_edge(1,3)` 后，会遍历结点 1 的边链。  \n   - 当遍历到边记录 `edges[i].to==3` 时，将其从链表中“删除”：  \n     - 如果该边不是头部，就把前一个边的 `nxt` 指向当前边的 `nxt`。  \n   - 此后，遍历结点 1 时，1 -> 3 就不会再被输出。\n\n3. **遍历验证：**  \n   - 调用 `traverse_node` 验证删除后，结点 1 的链表中只剩下 1 -> 4 和 1 -> 2。\n### 4. ASCII 图示辅助理解删除操作\n\n假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 1]\n           [index 1: (1 -> 3), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除 1->3 的过程：\n\n- 遍历时，`cur` 先指向 index 2 (边 1->4)，不匹配；  \n- 然后 `cur` 指向 index 1 (边 1->3)，匹配目标。此时 `pre` 指向 index 2。  \n- 更新 `edges[pre].nxt`，即 `edges[2].nxt = edges[1].nxt`（即 index 0）。  \n- 结果链表变为：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除后的遍历顺序即输出 1->4 和 1->2。\n\n---\n### 5. 小结\n- **删除边的思路：**  \n  - 在链表中找到目标边的位置。  \n  - 通过修改上一节点的 `nxt` 指针或更新 `head[u]`，跳过目标边，令其不参与后续遍历。\n\n- **局限性：**  \n  - 这种删除操作只更新了指针，并没有真正回收数组中的空间。  \n  - 如果后续还需要添加边，可以继续使用 `add_edge`，但是删除的空间不会被重用（除非重新构造数据结构）。\n\n- **扩展思考：**  \n  - 如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。\n\n通过以上代码和说明，你可以在链式前向星上实现边的删除功能。\n\n---\n## 删除节点\n下面讨论如何在链式前向星中实现“删除节点”的功能。  \n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：\n1. **删除该节点的所有出边（从该节点出发的边），** 这部分比较简单；\n2. **删除其他节点中所有指向该节点的入边，** 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。\n\n因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：\n\n---\n### 方法 1：物理删除（实际修改链表结构）\n\n在物理删除时，我们需要同时删除：\n- 节点 **u** 的出边（即把 `head[u]` 置为 -1 或清空整个链表），\n- 其他所有节点链表中指向 **u** 的边。\n\n这种方法的基本思路如下：\n1. **删除 u 的出边**  \n   直接将 `head[u]` 设为 -1，相当于断开了 u 对外的所有边。\n\n2. **删除所有指向 u 的入边**  \n   遍历图中所有其他节点 v 的边链表，在每个链表中查找边：  \n   ```cpp\n   if (edges[cur].to == u)\n   ```\n   找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 `nxt` 指针或更新 `head[v]`）。\n\n由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：  \n```cpp\n// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边\nvoid delete_node(int u,int n)//n 表示图中总的节点数\n{ \n    // 1. 删除 u 的所有出边：直接断开该链表\n    head[u]=-1;\n    \n    // 2. 删除其他节点中指向 u 的入边\n    for(int v=1;v<=n;v++)\n    {\n        if(v==u)  continue;//已经处理了 u 的出边\n        int cur=head[v];\n        int pre=-1;\n        while(cur!=-1)\n        {\n            if(edges[cur].to==u)//找到边 v->u，需要删除\n            {\n                if(pre==-1)\n                {\n                    //被删除的边在链表头，更新 head[v]\n                    head[v]=edges[cur].nxt;\n                    //更新 cur 为新的头节点\n                    cur=head[v];\n                }\n                else\n                {\n                    // 跳过当前边\n                    edges[pre].nxt=edges[cur].nxt;\n                    cur=edges[cur].nxt;\n                }\n                // 注意：如果存在多条边指向 u，此处可以继续遍历删除\n            }\n            else\n            {\n                pre=cur;\n                cur=edges[cur].nxt;\n            }\n        }\n    }\n    cout<<\"节点 \"<<u<<\" 删除完成 (出边和入边均已移除）。\"<<endl;\n    return;\n}\n```\n\n#### 注意事项\n- 这种物理删除不会真正回收 `edges[]` 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。\n- 删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。\n\n---\n### 方法 2：懒删除（逻辑删除）\n\n在很多实际场景下，动态删除节点（或边）时，我们可以采用 **懒删除** 的策略，而不是立即修改链表结构。方法是：\n1. 为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 `nodeExist[N]`。\n2. 当需要删除节点 **u** 时，只需将 `nodeExist[u]` 标记为 `false`\n3. 在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。\n\n这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。\n\n示例代码（仅思路）：\n\n```cpp\nbool nodeExist[N];\n\n// 初始化时，将所有节点设为存在\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)  nodeExist[i]=true;\n    return;\n}\n\n// 懒删除节点 u，标记为不存在\nvoid lazy_delete_node(int u)\n{\n    nodeExist[u]=false;\n    cout<<\"节点 \"<<u<<\" 已被标记为删除。\"<<endl;\n    return;\n}\n\n// 在遍历时，检查目标节点是否存在\nvoid process_edges(int u)\n{\n    if(!nodeExist[u])  return;//该节点已经被删除，则不处理\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        int v=edges[i].to;\n        if(!nodeExist[v])  continue;//如果终点已删除，则跳过该边\n        // 此处对边 (u -> v) 做处理\n    }\n    return;\n}\n```\n\n---\n### 小结\n- **物理删除节点：**  \n  - 将该节点的所有出边置为空（如 `head[u]=-1`），  \n  - 遍历其他所有节点的边链表，删除所有指向该节点的入边。  \n  - 需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。\n\n- **懒删除（逻辑删除）：**  \n  - 通过维护一个节点存在标志，在删除节点时仅做标记。  \n  - 在遍历和处理时跳过被删除的节点及其相关边。  \n  - 简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。\n\n根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。","source":"_posts/链式前向星.md","raw":"---\ntitle: 图的存储 - 链式前向星\ndate: 2025-07-15 16:23:05\ntags: ['图论', '存储', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 图的存储 - 链式前向星\n    topic: 应用场景非常广泛，很多算法都可用到！\nkatex: true\nauthor: ED_Builder\n---\n\n其实本质上就是用链表实现的邻接表\n\n<!-- more -->\n\n## 基本信息\n链式前向星是图论中一种 ~~牛逼~~ 高效的存储结构\n\n时间复杂度：  \n- 添加边：$O(1)$  \n  和邻接矩阵的复杂度一样，但是我们要在 `head` 数组的末尾添加新边，并更新头指针\n- 遍历节点的出边：$O(k)$  \n  其中：$k$ 为这个节点的出边数量。直接通过头指针开始遍历链表即可\n- 断边：最坏情况 $O(m)$  \n  需要遍历 `edges` 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星\n- 删除节点：$O(n)$  \n  需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）\n\n空间复杂度：$O(n+m)$，其中：$n$ 为节点数，$m$ 为边数\n## 添加与遍历\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int NODE_LEN=1e5+5;\nconst int EDGE_LEN=2e5+5;\n//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边\n\n//定义边，存储指向的目标节点和下一条边的索引，以及边权\nstruct Edge\n{\n    int to,nxt,weight;\n}edges[EDGE_LEN];//图中的所有边\n\nint head[NODE_LEN];//对于每一条边，记录第一条边在 edges 数组中的下标\nint cnt_edge=0;//边的数量\n\nvoid add_edge(int u,int v,int w)//添加一条边，由出发节点 u 到目标节点 v ，边权为 w\n{\n    edges[cnt_edge].to=v;\n    //当前计数边（也就是目前输入的第几个边）将会指向目标节点 v\n\n    edges[cnt_edge].nxt=head[u];\n    head[u]=cnt_edge;\n    //下一条边\n    edges[cnt_edge].weight=w;//由出发节点伸出的边的权值\n    cnt_edge++;//存完一个啦！提前准备好下一个！\n    cout<<\"添加边：( \"<<u<<\" -> \"<<v<<\" ) 成功！且权值为 \"<<w<<endl;\n    return;\n}\n\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //由于下面就是示例了，所以就用局部变量了\n    int n;//共计 n 个节点\n    cin>>n;\n    for(int i=1;i<=n;i++)//读入节点\n    {\n        int u,v,w;//出发节点和目标节点\n        cin>>u>>v>>w;\n        add_edge(u,v,w);\n        //add_edge(v,u,w);\n        //请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！\n    }\n    for(int i=1;i<=n;i++)  traverse_nodes(i);//遍历节点 i\n    exit(0);\n}\n```\n提示：学到这里已经足够应对大部分算法了，链式前向星 **非常不适合删除操作**\n\n---\n## 断边\n下面介绍如何在链式前向星数据结构上增加删除边的功能。\n\n需要注意的是，链式前向星本质上是一种一边 **只增不减** 的“静态”存储方式  \n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。  \n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。\n\n{% note color:red\n注意： \n1. 如果你的图中 **经常需要删除边** ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。\n%}\n\n### 1. 增加删除边所需要的代码\n假设我们在前面的加权图结构基础上（包括 `to`、`weight` 和 `nxt` 字段）进行扩展。我们给出一个 `delete_edge` 函数，函数参数为起点 `u` 和目标 `v` ，表示删除一条从 `u` 到 `v` 的边（如果存在多条，则只删除第一个碰到的）。\n\n我们来逐步说明删除边的思路，再给出代码：\n1. **找到目标边所在的链表位置**  \n   对于某个起点 `u` ，其边链表保存在从 `head[u]` 开始的一条单链表中。我们用两个变量：  \n   - `cur` 用于遍历链表，初始设为 `head[u]` 。  \n   - `pre` 记录前驱节点的索引，初始为 `-1`（表示当前边是链表的第一个）。\n2. **遍历链表，搜索符合条件的边**  \n   从 `cur` 开始，遍历链表：如果发现 `edges[cur].to==v`（满足目标条件），则说明找到了要删除的边。\n3. **更新指针实现删除**  \n   - 如果 `pre` 为 `-1`，说明要删除的边正好位于链表头部，此时更新 `head[u]=edges[cur].nxt`；  \n   - 否则，将前驱边的 `nxt` 指针更新为 `edges[cur].nxt`，这样跳过了当前边。\n4. **结束遍历**  \n   找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。\n\n下面是完整的删除边函数代码：\n```cpp\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n```\n\n### 2. 遍历节点，验证删除功能\n为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。  \n（其实这已经在 添加与遍历 演示了）\n```cpp\n// 遍历并输出结点 u 的所有出边（包括边的终点和权值）\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n```\n### 3. 示例\n下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：\n```cpp\n/*\n省略，真的太长了...\n可以翻到上面看看 添加与遍历\n*/\n\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //这是张 **无向图** \n    add_edge(1,2,5);add_edge(2,1,5);\n    add_edge(1,3,10);add_edge(3,1,10);\n    add_edge(1,4,3);add_edge(4,1,3);\n    add_edge(2,3,7);add_edge(3,2,7);\n    cout<<\"建边后的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    delete_edge(1,3);\n    cout<<\"现在的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    exit(0);\n}\n```\n示例中的初始图长这样：  \n![graph](https://imghub.ed-builder.top/file/1746946383810_graph.png)\n#### 程序执行过程说明\n1. **添加边阶段：**  \n   - 对于结点 1，经过多次调用 `add_edge(1, ...)`，其边链表可能为（头插法的结果是最新添加的边在链表头）：  \n     - 头部指向边：1 -> 4  \n     - 通过 `nxt` 链到边：1 -> 3  \n     - 再通过 `nxt` 链到边：1 -> 2  \n   - 结点 2 拥有边：2 -> 3。\n\n2. **删除操作：**  \n   - 调用 `delete_edge(1,3)` 后，会遍历结点 1 的边链。  \n   - 当遍历到边记录 `edges[i].to==3` 时，将其从链表中“删除”：  \n     - 如果该边不是头部，就把前一个边的 `nxt` 指向当前边的 `nxt`。  \n   - 此后，遍历结点 1 时，1 -> 3 就不会再被输出。\n\n3. **遍历验证：**  \n   - 调用 `traverse_node` 验证删除后，结点 1 的链表中只剩下 1 -> 4 和 1 -> 2。\n### 4. ASCII 图示辅助理解删除操作\n\n假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 1]\n           [index 1: (1 -> 3), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除 1->3 的过程：\n\n- 遍历时，`cur` 先指向 index 2 (边 1->4)，不匹配；  \n- 然后 `cur` 指向 index 1 (边 1->3)，匹配目标。此时 `pre` 指向 index 2。  \n- 更新 `edges[pre].nxt`，即 `edges[2].nxt = edges[1].nxt`（即 index 0）。  \n- 结果链表变为：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除后的遍历顺序即输出 1->4 和 1->2。\n\n---\n### 5. 小结\n- **删除边的思路：**  \n  - 在链表中找到目标边的位置。  \n  - 通过修改上一节点的 `nxt` 指针或更新 `head[u]`，跳过目标边，令其不参与后续遍历。\n\n- **局限性：**  \n  - 这种删除操作只更新了指针，并没有真正回收数组中的空间。  \n  - 如果后续还需要添加边，可以继续使用 `add_edge`，但是删除的空间不会被重用（除非重新构造数据结构）。\n\n- **扩展思考：**  \n  - 如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。\n\n通过以上代码和说明，你可以在链式前向星上实现边的删除功能。\n\n---\n## 删除节点\n下面讨论如何在链式前向星中实现“删除节点”的功能。  \n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：\n1. **删除该节点的所有出边（从该节点出发的边），** 这部分比较简单；\n2. **删除其他节点中所有指向该节点的入边，** 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。\n\n因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：\n\n---\n### 方法 1：物理删除（实际修改链表结构）\n\n在物理删除时，我们需要同时删除：\n- 节点 **u** 的出边（即把 `head[u]` 置为 -1 或清空整个链表），\n- 其他所有节点链表中指向 **u** 的边。\n\n这种方法的基本思路如下：\n1. **删除 u 的出边**  \n   直接将 `head[u]` 设为 -1，相当于断开了 u 对外的所有边。\n\n2. **删除所有指向 u 的入边**  \n   遍历图中所有其他节点 v 的边链表，在每个链表中查找边：  \n   ```cpp\n   if (edges[cur].to == u)\n   ```\n   找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 `nxt` 指针或更新 `head[v]`）。\n\n由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：  \n```cpp\n// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边\nvoid delete_node(int u,int n)//n 表示图中总的节点数\n{ \n    // 1. 删除 u 的所有出边：直接断开该链表\n    head[u]=-1;\n    \n    // 2. 删除其他节点中指向 u 的入边\n    for(int v=1;v<=n;v++)\n    {\n        if(v==u)  continue;//已经处理了 u 的出边\n        int cur=head[v];\n        int pre=-1;\n        while(cur!=-1)\n        {\n            if(edges[cur].to==u)//找到边 v->u，需要删除\n            {\n                if(pre==-1)\n                {\n                    //被删除的边在链表头，更新 head[v]\n                    head[v]=edges[cur].nxt;\n                    //更新 cur 为新的头节点\n                    cur=head[v];\n                }\n                else\n                {\n                    // 跳过当前边\n                    edges[pre].nxt=edges[cur].nxt;\n                    cur=edges[cur].nxt;\n                }\n                // 注意：如果存在多条边指向 u，此处可以继续遍历删除\n            }\n            else\n            {\n                pre=cur;\n                cur=edges[cur].nxt;\n            }\n        }\n    }\n    cout<<\"节点 \"<<u<<\" 删除完成 (出边和入边均已移除）。\"<<endl;\n    return;\n}\n```\n\n#### 注意事项\n- 这种物理删除不会真正回收 `edges[]` 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。\n- 删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。\n\n---\n### 方法 2：懒删除（逻辑删除）\n\n在很多实际场景下，动态删除节点（或边）时，我们可以采用 **懒删除** 的策略，而不是立即修改链表结构。方法是：\n1. 为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 `nodeExist[N]`。\n2. 当需要删除节点 **u** 时，只需将 `nodeExist[u]` 标记为 `false`\n3. 在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。\n\n这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。\n\n示例代码（仅思路）：\n\n```cpp\nbool nodeExist[N];\n\n// 初始化时，将所有节点设为存在\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)  nodeExist[i]=true;\n    return;\n}\n\n// 懒删除节点 u，标记为不存在\nvoid lazy_delete_node(int u)\n{\n    nodeExist[u]=false;\n    cout<<\"节点 \"<<u<<\" 已被标记为删除。\"<<endl;\n    return;\n}\n\n// 在遍历时，检查目标节点是否存在\nvoid process_edges(int u)\n{\n    if(!nodeExist[u])  return;//该节点已经被删除，则不处理\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        int v=edges[i].to;\n        if(!nodeExist[v])  continue;//如果终点已删除，则跳过该边\n        // 此处对边 (u -> v) 做处理\n    }\n    return;\n}\n```\n\n---\n### 小结\n- **物理删除节点：**  \n  - 将该节点的所有出边置为空（如 `head[u]=-1`），  \n  - 遍历其他所有节点的边链表，删除所有指向该节点的入边。  \n  - 需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。\n\n- **懒删除（逻辑删除）：**  \n  - 通过维护一个节点存在标志，在删除节点时仅做标记。  \n  - 在遍历和处理时跳过被删除的节点及其相关边。  \n  - 简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。\n\n根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。","slug":"链式前向星","published":1,"updated":"2025-08-25T04:41:24.453Z","_id":"cmebjcsx9000bc4bo54w870s6","comments":1,"layout":"post","photos":[],"content":"<p>其实本质上就是用链表实现的邻接表</p>\n<span id=\"more\"></span>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>链式前向星是图论中一种 <s>牛逼</s> 高效的存储结构</p>\n<p>时间复杂度：</p>\n<ul>\n<li>添加边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n和邻接矩阵的复杂度一样，但是我们要在 <code>head</code> 数组的末尾添加新边，并更新头指针</li>\n<li>遍历节点的出边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span><br />\n其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为这个节点的出边数量。直接通过头指针开始遍历链表即可</li>\n<li>断边：最坏情况 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历 <code>edges</code> 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星</li>\n<li>删除节点：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）</li>\n</ul>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为节点数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 为边数</p>\n<h2 id=\"添加与遍历\"><a class=\"markdownIt-Anchor\" href=\"#添加与遍历\"></a> 添加与遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> NODE_LEN=<span class=\"number\">1e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> EDGE_LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"comment\">//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义边，存储指向的目标节点和下一条边的索引，以及边权</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edges[EDGE_LEN];<span class=\"comment\">//图中的所有边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> head[NODE_LEN];<span class=\"comment\">//对于每一条边，记录第一条边在 edges 数组中的下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> cnt_edge=<span class=\"number\">0</span>;<span class=\"comment\">//边的数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span><span class=\"comment\">//添加一条边，由出发节点 u 到目标节点 v ，边权为 w</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edges[cnt_edge].to=v;</span><br><span class=\"line\">    <span class=\"comment\">//当前计数边（也就是目前输入的第几个边）将会指向目标节点 v</span></span><br><span class=\"line\"></span><br><span class=\"line\">    edges[cnt_edge].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt_edge;</span><br><span class=\"line\">    <span class=\"comment\">//下一条边</span></span><br><span class=\"line\">    edges[cnt_edge].weight=w;<span class=\"comment\">//由出发节点伸出的边的权值</span></span><br><span class=\"line\">    cnt_edge++;<span class=\"comment\">//存完一个啦！提前准备好下一个！</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;添加边：( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot; ) 成功！且权值为 &quot;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//由于下面就是示例了，所以就用局部变量了</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;<span class=\"comment\">//共计 n 个节点</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//读入节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;<span class=\"comment\">//出发节点和目标节点</span></span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">add_edge</span>(u,v,w);</span><br><span class=\"line\">        <span class=\"comment\">//add_edge(v,u,w);</span></span><br><span class=\"line\">        <span class=\"comment\">//请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  <span class=\"built_in\">traverse_nodes</span>(i);<span class=\"comment\">//遍历节点 i</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>提示：学到这里已经足够应对大部分算法了，链式前向星 <strong>非常不适合删除操作</strong></p>\n<hr />\n<h2 id=\"断边\"><a class=\"markdownIt-Anchor\" href=\"#断边\"></a> 断边</h2>\n<p>下面介绍如何在链式前向星数据结构上增加删除边的功能。</p>\n<p>需要注意的是，链式前向星本质上是一种一边 <strong>只增不减</strong> 的“静态”存储方式<br />\n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。<br />\n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。</p>\n<div class=\"tag-plugin colorful note\" color=\"red\"><div class=\"title\">注意：</div><div class=\"body\"><ol><li>如果你的图中 <strong>经常需要删除边</strong> ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。</li></ol></div></div>\n<h3 id=\"1-增加删除边所需要的代码\"><a class=\"markdownIt-Anchor\" href=\"#1-增加删除边所需要的代码\"></a> 1. 增加删除边所需要的代码</h3>\n<p>假设我们在前面的加权图结构基础上（包括 <code>to</code>、<code>weight</code> 和 <code>nxt</code> 字段）进行扩展。我们给出一个 <code>delete_edge</code> 函数，函数参数为起点 <code>u</code> 和目标 <code>v</code> ，表示删除一条从 <code>u</code> 到 <code>v</code> 的边（如果存在多条，则只删除第一个碰到的）。</p>\n<p>我们来逐步说明删除边的思路，再给出代码：</p>\n<ol>\n<li><strong>找到目标边所在的链表位置</strong><br />\n对于某个起点 <code>u</code> ，其边链表保存在从 <code>head[u]</code> 开始的一条单链表中。我们用两个变量：\n<ul>\n<li><code>cur</code> 用于遍历链表，初始设为 <code>head[u]</code> 。</li>\n<li><code>pre</code> 记录前驱节点的索引，初始为 <code>-1</code>（表示当前边是链表的第一个）。</li>\n</ul>\n</li>\n<li><strong>遍历链表，搜索符合条件的边</strong><br />\n从 <code>cur</code> 开始，遍历链表：如果发现 <code>edges[cur].to==v</code>（满足目标条件），则说明找到了要删除的边。</li>\n<li><strong>更新指针实现删除</strong>\n<ul>\n<li>如果 <code>pre</code> 为 <code>-1</code>，说明要删除的边正好位于链表头部，此时更新 <code>head[u]=edges[cur].nxt</code>；</li>\n<li>否则，将前驱边的 <code>nxt</code> 指针更新为 <code>edges[cur].nxt</code>，这样跳过了当前边。</li>\n</ul>\n</li>\n<li><strong>结束遍历</strong><br />\n找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。</li>\n</ol>\n<p>下面是完整的删除边函数代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-遍历节点验证删除功能\"><a class=\"markdownIt-Anchor\" href=\"#2-遍历节点验证删除功能\"></a> 2. 遍历节点，验证删除功能</h3>\n<p>为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。<br />\n（其实这已经在 添加与遍历 演示了）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历并输出结点 u 的所有出边（包括边的终点和权值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-示例\"><a class=\"markdownIt-Anchor\" href=\"#3-示例\"></a> 3. 示例</h3>\n<p>下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">省略，真的太长了...</span></span><br><span class=\"line\"><span class=\"comment\">可以翻到上面看看 添加与遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这是张 **无向图** </span></span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;建边后的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">delete_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;现在的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例中的初始图长这样：<br />\n<img src=\"https://imghub.ed-builder.top/file/1746946383810_graph.png\" alt=\"graph\" /></p>\n<h4 id=\"程序执行过程说明\"><a class=\"markdownIt-Anchor\" href=\"#程序执行过程说明\"></a> 程序执行过程说明</h4>\n<ol>\n<li>\n<p><strong>添加边阶段：</strong></p>\n<ul>\n<li>对于结点 1，经过多次调用 <code>add_edge(1, ...)</code>，其边链表可能为（头插法的结果是最新添加的边在链表头）：\n<ul>\n<li>头部指向边：1 -&gt; 4</li>\n<li>通过 <code>nxt</code> 链到边：1 -&gt; 3</li>\n<li>再通过 <code>nxt</code> 链到边：1 -&gt; 2</li>\n</ul>\n</li>\n<li>结点 2 拥有边：2 -&gt; 3。</li>\n</ul>\n</li>\n<li>\n<p><strong>删除操作：</strong></p>\n<ul>\n<li>调用 <code>delete_edge(1,3)</code> 后，会遍历结点 1 的边链。</li>\n<li>当遍历到边记录 <code>edges[i].to==3</code> 时，将其从链表中“删除”：\n<ul>\n<li>如果该边不是头部，就把前一个边的 <code>nxt</code> 指向当前边的 <code>nxt</code>。</li>\n</ul>\n</li>\n<li>此后，遍历结点 1 时，1 -&gt; 3 就不会再被输出。</li>\n</ul>\n</li>\n<li>\n<p><strong>遍历验证：</strong></p>\n<ul>\n<li>调用 <code>traverse_node</code> 验证删除后，结点 1 的链表中只剩下 1 -&gt; 4 和 1 -&gt; 2。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-ascii-图示辅助理解删除操作\"><a class=\"markdownIt-Anchor\" href=\"#4-ascii-图示辅助理解删除操作\"></a> 4. ASCII 图示辅助理解删除操作</h3>\n<p>假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">1</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 1: (1 -&gt;</span> <span class=\"number\">3</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除 1-&gt;3 的过程：</p>\n<ul>\n<li>遍历时，<code>cur</code> 先指向 index 2 (边 1-&gt;4)，不匹配；</li>\n<li>然后 <code>cur</code> 指向 index 1 (边 1-&gt;3)，匹配目标。此时 <code>pre</code> 指向 index 2。</li>\n<li>更新 <code>edges[pre].nxt</code>，即 <code>edges[2].nxt = edges[1].nxt</code>（即 index 0）。</li>\n<li>结果链表变为：</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除后的遍历顺序即输出 1-&gt;4 和 1-&gt;2。</p>\n<hr />\n<h3 id=\"5-小结\"><a class=\"markdownIt-Anchor\" href=\"#5-小结\"></a> 5. 小结</h3>\n<ul>\n<li>\n<p><strong>删除边的思路：</strong></p>\n<ul>\n<li>在链表中找到目标边的位置。</li>\n<li>通过修改上一节点的 <code>nxt</code> 指针或更新 <code>head[u]</code>，跳过目标边，令其不参与后续遍历。</li>\n</ul>\n</li>\n<li>\n<p><strong>局限性：</strong></p>\n<ul>\n<li>这种删除操作只更新了指针，并没有真正回收数组中的空间。</li>\n<li>如果后续还需要添加边，可以继续使用 <code>add_edge</code>，但是删除的空间不会被重用（除非重新构造数据结构）。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩展思考：</strong></p>\n<ul>\n<li>如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。</li>\n</ul>\n</li>\n</ul>\n<p>通过以上代码和说明，你可以在链式前向星上实现边的删除功能。</p>\n<hr />\n<h2 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\"></a> 删除节点</h2>\n<p>下面讨论如何在链式前向星中实现“删除节点”的功能。<br />\n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：</p>\n<ol>\n<li><strong>删除该节点的所有出边（从该节点出发的边），</strong> 这部分比较简单；</li>\n<li><strong>删除其他节点中所有指向该节点的入边，</strong> 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。</li>\n</ol>\n<p>因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：</p>\n<hr />\n<h3 id=\"方法-1物理删除实际修改链表结构\"><a class=\"markdownIt-Anchor\" href=\"#方法-1物理删除实际修改链表结构\"></a> 方法 1：物理删除（实际修改链表结构）</h3>\n<p>在物理删除时，我们需要同时删除：</p>\n<ul>\n<li>节点 <strong>u</strong> 的出边（即把 <code>head[u]</code> 置为 -1 或清空整个链表），</li>\n<li>其他所有节点链表中指向 <strong>u</strong> 的边。</li>\n</ul>\n<p>这种方法的基本思路如下：</p>\n<ol>\n<li>\n<p><strong>删除 u 的出边</strong><br />\n直接将 <code>head[u]</code> 设为 -1，相当于断开了 u 对外的所有边。</p>\n</li>\n<li>\n<p><strong>删除所有指向 u 的入边</strong><br />\n遍历图中所有其他节点 v 的边链表，在每个链表中查找边：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (edges[cur].to == u)</span><br></pre></td></tr></table></figure>\n<p>找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 <code>nxt</code> 指针或更新 <code>head[v]</code>）。</p>\n</li>\n</ol>\n<p>由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> n)</span><span class=\"comment\">//n 表示图中总的节点数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 1. 删除 u 的所有出边：直接断开该链表</span></span><br><span class=\"line\">    head[u]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 删除其他节点中指向 u 的入边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=<span class=\"number\">1</span>;v&lt;=n;v++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==u)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//已经处理了 u 的出边</span></span><br><span class=\"line\">        <span class=\"type\">int</span> cur=head[v];</span><br><span class=\"line\">        <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edges[cur].to==u)<span class=\"comment\">//找到边 v-&gt;u，需要删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pre==<span class=\"number\">-1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//被删除的边在链表头，更新 head[v]</span></span><br><span class=\"line\">                    head[v]=edges[cur].nxt;</span><br><span class=\"line\">                    <span class=\"comment\">//更新 cur 为新的头节点</span></span><br><span class=\"line\">                    cur=head[v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跳过当前边</span></span><br><span class=\"line\">                    edges[pre].nxt=edges[cur].nxt;</span><br><span class=\"line\">                    cur=edges[cur].nxt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 注意：如果存在多条边指向 u，此处可以继续遍历删除</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pre=cur;</span><br><span class=\"line\">                cur=edges[cur].nxt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 删除完成 (出边和入边均已移除）。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h4>\n<ul>\n<li>这种物理删除不会真正回收 <code>edges[]</code> 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。</li>\n<li>删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。</li>\n</ul>\n<hr />\n<h3 id=\"方法-2懒删除逻辑删除\"><a class=\"markdownIt-Anchor\" href=\"#方法-2懒删除逻辑删除\"></a> 方法 2：懒删除（逻辑删除）</h3>\n<p>在很多实际场景下，动态删除节点（或边）时，我们可以采用 <strong>懒删除</strong> 的策略，而不是立即修改链表结构。方法是：</p>\n<ol>\n<li>为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 <code>nodeExist[N]</code>。</li>\n<li>当需要删除节点 <strong>u</strong> 时，只需将 <code>nodeExist[u]</code> 标记为 <code>false</code></li>\n<li>在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。</li>\n</ol>\n<p>这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。</p>\n<p>示例代码（仅思路）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> nodeExist[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化时，将所有节点设为存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  nodeExist[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒删除节点 u，标记为不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lazy_delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    nodeExist[u]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 已被标记为删除。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在遍历时，检查目标节点是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_edges</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!nodeExist[u])  <span class=\"keyword\">return</span>;<span class=\"comment\">//该节点已经被删除，则不处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v=edges[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!nodeExist[v])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//如果终点已删除，则跳过该边</span></span><br><span class=\"line\">        <span class=\"comment\">// 此处对边 (u -&gt; v) 做处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h3 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h3>\n<ul>\n<li>\n<p><strong>物理删除节点：</strong></p>\n<ul>\n<li>将该节点的所有出边置为空（如 <code>head[u]=-1</code>），</li>\n<li>遍历其他所有节点的边链表，删除所有指向该节点的入边。</li>\n<li>需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。</li>\n</ul>\n</li>\n<li>\n<p><strong>懒删除（逻辑删除）：</strong></p>\n<ul>\n<li>通过维护一个节点存在标志，在删除节点时仅做标记。</li>\n<li>在遍历和处理时跳过被删除的节点及其相关边。</li>\n<li>简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。</li>\n</ul>\n</li>\n</ul>\n<p>根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。</p>\n","excerpt":"<p>其实本质上就是用链表实现的邻接表</p>","more":"<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>链式前向星是图论中一种 <s>牛逼</s> 高效的存储结构</p>\n<p>时间复杂度：</p>\n<ul>\n<li>添加边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n和邻接矩阵的复杂度一样，但是我们要在 <code>head</code> 数组的末尾添加新边，并更新头指针</li>\n<li>遍历节点的出边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span><br />\n其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为这个节点的出边数量。直接通过头指针开始遍历链表即可</li>\n<li>断边：最坏情况 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历 <code>edges</code> 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星</li>\n<li>删除节点：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）</li>\n</ul>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为节点数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 为边数</p>\n<h2 id=\"添加与遍历\"><a class=\"markdownIt-Anchor\" href=\"#添加与遍历\"></a> 添加与遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> NODE_LEN=<span class=\"number\">1e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> EDGE_LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"comment\">//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义边，存储指向的目标节点和下一条边的索引，以及边权</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edges[EDGE_LEN];<span class=\"comment\">//图中的所有边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> head[NODE_LEN];<span class=\"comment\">//对于每一条边，记录第一条边在 edges 数组中的下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> cnt_edge=<span class=\"number\">0</span>;<span class=\"comment\">//边的数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span><span class=\"comment\">//添加一条边，由出发节点 u 到目标节点 v ，边权为 w</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edges[cnt_edge].to=v;</span><br><span class=\"line\">    <span class=\"comment\">//当前计数边（也就是目前输入的第几个边）将会指向目标节点 v</span></span><br><span class=\"line\"></span><br><span class=\"line\">    edges[cnt_edge].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt_edge;</span><br><span class=\"line\">    <span class=\"comment\">//下一条边</span></span><br><span class=\"line\">    edges[cnt_edge].weight=w;<span class=\"comment\">//由出发节点伸出的边的权值</span></span><br><span class=\"line\">    cnt_edge++;<span class=\"comment\">//存完一个啦！提前准备好下一个！</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;添加边：( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot; ) 成功！且权值为 &quot;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//由于下面就是示例了，所以就用局部变量了</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;<span class=\"comment\">//共计 n 个节点</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//读入节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;<span class=\"comment\">//出发节点和目标节点</span></span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">add_edge</span>(u,v,w);</span><br><span class=\"line\">        <span class=\"comment\">//add_edge(v,u,w);</span></span><br><span class=\"line\">        <span class=\"comment\">//请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  <span class=\"built_in\">traverse_nodes</span>(i);<span class=\"comment\">//遍历节点 i</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>提示：学到这里已经足够应对大部分算法了，链式前向星 <strong>非常不适合删除操作</strong></p>\n<hr />\n<h2 id=\"断边\"><a class=\"markdownIt-Anchor\" href=\"#断边\"></a> 断边</h2>\n<p>下面介绍如何在链式前向星数据结构上增加删除边的功能。</p>\n<p>需要注意的是，链式前向星本质上是一种一边 <strong>只增不减</strong> 的“静态”存储方式<br />\n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。<br />\n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。</p>\n<div class=\"tag-plugin colorful note\" color=\"red\"><div class=\"title\">注意：</div><div class=\"body\"><ol><li>如果你的图中 <strong>经常需要删除边</strong> ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。</li></ol></div></div>\n<h3 id=\"1-增加删除边所需要的代码\"><a class=\"markdownIt-Anchor\" href=\"#1-增加删除边所需要的代码\"></a> 1. 增加删除边所需要的代码</h3>\n<p>假设我们在前面的加权图结构基础上（包括 <code>to</code>、<code>weight</code> 和 <code>nxt</code> 字段）进行扩展。我们给出一个 <code>delete_edge</code> 函数，函数参数为起点 <code>u</code> 和目标 <code>v</code> ，表示删除一条从 <code>u</code> 到 <code>v</code> 的边（如果存在多条，则只删除第一个碰到的）。</p>\n<p>我们来逐步说明删除边的思路，再给出代码：</p>\n<ol>\n<li><strong>找到目标边所在的链表位置</strong><br />\n对于某个起点 <code>u</code> ，其边链表保存在从 <code>head[u]</code> 开始的一条单链表中。我们用两个变量：\n<ul>\n<li><code>cur</code> 用于遍历链表，初始设为 <code>head[u]</code> 。</li>\n<li><code>pre</code> 记录前驱节点的索引，初始为 <code>-1</code>（表示当前边是链表的第一个）。</li>\n</ul>\n</li>\n<li><strong>遍历链表，搜索符合条件的边</strong><br />\n从 <code>cur</code> 开始，遍历链表：如果发现 <code>edges[cur].to==v</code>（满足目标条件），则说明找到了要删除的边。</li>\n<li><strong>更新指针实现删除</strong>\n<ul>\n<li>如果 <code>pre</code> 为 <code>-1</code>，说明要删除的边正好位于链表头部，此时更新 <code>head[u]=edges[cur].nxt</code>；</li>\n<li>否则，将前驱边的 <code>nxt</code> 指针更新为 <code>edges[cur].nxt</code>，这样跳过了当前边。</li>\n</ul>\n</li>\n<li><strong>结束遍历</strong><br />\n找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。</li>\n</ol>\n<p>下面是完整的删除边函数代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-遍历节点验证删除功能\"><a class=\"markdownIt-Anchor\" href=\"#2-遍历节点验证删除功能\"></a> 2. 遍历节点，验证删除功能</h3>\n<p>为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。<br />\n（其实这已经在 添加与遍历 演示了）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历并输出结点 u 的所有出边（包括边的终点和权值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-示例\"><a class=\"markdownIt-Anchor\" href=\"#3-示例\"></a> 3. 示例</h3>\n<p>下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">省略，真的太长了...</span></span><br><span class=\"line\"><span class=\"comment\">可以翻到上面看看 添加与遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这是张 **无向图** </span></span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;建边后的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">delete_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;现在的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例中的初始图长这样：<br />\n<img src=\"https://imghub.ed-builder.top/file/1746946383810_graph.png\" alt=\"graph\" /></p>\n<h4 id=\"程序执行过程说明\"><a class=\"markdownIt-Anchor\" href=\"#程序执行过程说明\"></a> 程序执行过程说明</h4>\n<ol>\n<li>\n<p><strong>添加边阶段：</strong></p>\n<ul>\n<li>对于结点 1，经过多次调用 <code>add_edge(1, ...)</code>，其边链表可能为（头插法的结果是最新添加的边在链表头）：\n<ul>\n<li>头部指向边：1 -&gt; 4</li>\n<li>通过 <code>nxt</code> 链到边：1 -&gt; 3</li>\n<li>再通过 <code>nxt</code> 链到边：1 -&gt; 2</li>\n</ul>\n</li>\n<li>结点 2 拥有边：2 -&gt; 3。</li>\n</ul>\n</li>\n<li>\n<p><strong>删除操作：</strong></p>\n<ul>\n<li>调用 <code>delete_edge(1,3)</code> 后，会遍历结点 1 的边链。</li>\n<li>当遍历到边记录 <code>edges[i].to==3</code> 时，将其从链表中“删除”：\n<ul>\n<li>如果该边不是头部，就把前一个边的 <code>nxt</code> 指向当前边的 <code>nxt</code>。</li>\n</ul>\n</li>\n<li>此后，遍历结点 1 时，1 -&gt; 3 就不会再被输出。</li>\n</ul>\n</li>\n<li>\n<p><strong>遍历验证：</strong></p>\n<ul>\n<li>调用 <code>traverse_node</code> 验证删除后，结点 1 的链表中只剩下 1 -&gt; 4 和 1 -&gt; 2。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-ascii-图示辅助理解删除操作\"><a class=\"markdownIt-Anchor\" href=\"#4-ascii-图示辅助理解删除操作\"></a> 4. ASCII 图示辅助理解删除操作</h3>\n<p>假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">1</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 1: (1 -&gt;</span> <span class=\"number\">3</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除 1-&gt;3 的过程：</p>\n<ul>\n<li>遍历时，<code>cur</code> 先指向 index 2 (边 1-&gt;4)，不匹配；</li>\n<li>然后 <code>cur</code> 指向 index 1 (边 1-&gt;3)，匹配目标。此时 <code>pre</code> 指向 index 2。</li>\n<li>更新 <code>edges[pre].nxt</code>，即 <code>edges[2].nxt = edges[1].nxt</code>（即 index 0）。</li>\n<li>结果链表变为：</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除后的遍历顺序即输出 1-&gt;4 和 1-&gt;2。</p>\n<hr />\n<h3 id=\"5-小结\"><a class=\"markdownIt-Anchor\" href=\"#5-小结\"></a> 5. 小结</h3>\n<ul>\n<li>\n<p><strong>删除边的思路：</strong></p>\n<ul>\n<li>在链表中找到目标边的位置。</li>\n<li>通过修改上一节点的 <code>nxt</code> 指针或更新 <code>head[u]</code>，跳过目标边，令其不参与后续遍历。</li>\n</ul>\n</li>\n<li>\n<p><strong>局限性：</strong></p>\n<ul>\n<li>这种删除操作只更新了指针，并没有真正回收数组中的空间。</li>\n<li>如果后续还需要添加边，可以继续使用 <code>add_edge</code>，但是删除的空间不会被重用（除非重新构造数据结构）。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩展思考：</strong></p>\n<ul>\n<li>如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。</li>\n</ul>\n</li>\n</ul>\n<p>通过以上代码和说明，你可以在链式前向星上实现边的删除功能。</p>\n<hr />\n<h2 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\"></a> 删除节点</h2>\n<p>下面讨论如何在链式前向星中实现“删除节点”的功能。<br />\n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：</p>\n<ol>\n<li><strong>删除该节点的所有出边（从该节点出发的边），</strong> 这部分比较简单；</li>\n<li><strong>删除其他节点中所有指向该节点的入边，</strong> 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。</li>\n</ol>\n<p>因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：</p>\n<hr />\n<h3 id=\"方法-1物理删除实际修改链表结构\"><a class=\"markdownIt-Anchor\" href=\"#方法-1物理删除实际修改链表结构\"></a> 方法 1：物理删除（实际修改链表结构）</h3>\n<p>在物理删除时，我们需要同时删除：</p>\n<ul>\n<li>节点 <strong>u</strong> 的出边（即把 <code>head[u]</code> 置为 -1 或清空整个链表），</li>\n<li>其他所有节点链表中指向 <strong>u</strong> 的边。</li>\n</ul>\n<p>这种方法的基本思路如下：</p>\n<ol>\n<li>\n<p><strong>删除 u 的出边</strong><br />\n直接将 <code>head[u]</code> 设为 -1，相当于断开了 u 对外的所有边。</p>\n</li>\n<li>\n<p><strong>删除所有指向 u 的入边</strong><br />\n遍历图中所有其他节点 v 的边链表，在每个链表中查找边：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (edges[cur].to == u)</span><br></pre></td></tr></table></figure>\n<p>找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 <code>nxt</code> 指针或更新 <code>head[v]</code>）。</p>\n</li>\n</ol>\n<p>由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> n)</span><span class=\"comment\">//n 表示图中总的节点数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 1. 删除 u 的所有出边：直接断开该链表</span></span><br><span class=\"line\">    head[u]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 删除其他节点中指向 u 的入边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=<span class=\"number\">1</span>;v&lt;=n;v++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==u)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//已经处理了 u 的出边</span></span><br><span class=\"line\">        <span class=\"type\">int</span> cur=head[v];</span><br><span class=\"line\">        <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edges[cur].to==u)<span class=\"comment\">//找到边 v-&gt;u，需要删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pre==<span class=\"number\">-1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//被删除的边在链表头，更新 head[v]</span></span><br><span class=\"line\">                    head[v]=edges[cur].nxt;</span><br><span class=\"line\">                    <span class=\"comment\">//更新 cur 为新的头节点</span></span><br><span class=\"line\">                    cur=head[v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跳过当前边</span></span><br><span class=\"line\">                    edges[pre].nxt=edges[cur].nxt;</span><br><span class=\"line\">                    cur=edges[cur].nxt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 注意：如果存在多条边指向 u，此处可以继续遍历删除</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pre=cur;</span><br><span class=\"line\">                cur=edges[cur].nxt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 删除完成 (出边和入边均已移除）。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h4>\n<ul>\n<li>这种物理删除不会真正回收 <code>edges[]</code> 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。</li>\n<li>删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。</li>\n</ul>\n<hr />\n<h3 id=\"方法-2懒删除逻辑删除\"><a class=\"markdownIt-Anchor\" href=\"#方法-2懒删除逻辑删除\"></a> 方法 2：懒删除（逻辑删除）</h3>\n<p>在很多实际场景下，动态删除节点（或边）时，我们可以采用 <strong>懒删除</strong> 的策略，而不是立即修改链表结构。方法是：</p>\n<ol>\n<li>为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 <code>nodeExist[N]</code>。</li>\n<li>当需要删除节点 <strong>u</strong> 时，只需将 <code>nodeExist[u]</code> 标记为 <code>false</code></li>\n<li>在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。</li>\n</ol>\n<p>这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。</p>\n<p>示例代码（仅思路）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> nodeExist[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化时，将所有节点设为存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  nodeExist[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒删除节点 u，标记为不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lazy_delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    nodeExist[u]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 已被标记为删除。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在遍历时，检查目标节点是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_edges</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!nodeExist[u])  <span class=\"keyword\">return</span>;<span class=\"comment\">//该节点已经被删除，则不处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v=edges[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!nodeExist[v])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//如果终点已删除，则跳过该边</span></span><br><span class=\"line\">        <span class=\"comment\">// 此处对边 (u -&gt; v) 做处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h3 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h3>\n<ul>\n<li>\n<p><strong>物理删除节点：</strong></p>\n<ul>\n<li>将该节点的所有出边置为空（如 <code>head[u]=-1</code>），</li>\n<li>遍历其他所有节点的边链表，删除所有指向该节点的入边。</li>\n<li>需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。</li>\n</ul>\n</li>\n<li>\n<p><strong>懒删除（逻辑删除）：</strong></p>\n<ul>\n<li>通过维护一个节点存在标志，在删除节点时仅做标记。</li>\n<li>在遍历和处理时跳过被删除的节点及其相关边。</li>\n<li>简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。</li>\n</ul>\n</li>\n</ul>\n<p>根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。</p>"},{"title":"图论 - 最短路","date":"2025-07-10T12:01:47.000Z","banner":"https://imghub.ed-builder.top/file/sTEM0QcE.png","cover":"https://imghub.ed-builder.top/file/sTEM0QcE.png","poster":{"headline":"图论 - 最短路","topic":"多种算法，多种应用场景"},"katex":true,"author":"ED_Builder","_content":"\n本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA\n\n<!-- more -->\n\n# Floyd\n## 基本信息\n定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 $a$ 到顶点 $b$）之间的路程变短，只能引入第三个点（顶点 $k$），并通过这个顶点 $k$ 中转，即 `a->k->b`，才可能缩短原来从顶点 $a$ 到顶点 $b$ 的路程。\n\n原理：三重循环枚举中转点 `k`，状态转移方程：`dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])`\n\n时间复杂度：$O(n^3)$\n## 算法步骤\n由于在图中 **没有负环** 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。\n## 例题 - [Luogu B3647](https://luogu.com.cn/problem/B3647)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN],n,m;\nsigned main()\n{\n    cin>>n>>m;\n    memset(graph,INF,sizeof(graph));//初始化为任何顶点都没有相连\n    for(int i=1;i<=n;i++)  graph[i][i]=0;//自己到自己为 0\n    while(m--)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph[u][v]=graph[v][u]=min(graph[u][v],w);//最小值\n    }\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n                //暴力查找第三点 k，以及通过边权求最小值\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(graph[i][j]==INF)  cout<<0<<' ';//没有边相连\n            else  cout<<graph[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n~~上面这玩意只有 80pts~~\n\n---\n# Dijkstra\n## 基本信息\n定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。  \n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 **所有的边权全部非负**。\n\n原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。\n\n时间复杂度：$O(n^2)$\n## 算法步骤\n1. 初始化 `graph[v0]=0` ，**出发点** 到其他顶点的距离 `graph[i]=INF`\n2. 经过 $n$ 次下面的操作，最后得到 $v_0$ 到 $n$ 个顶点的最短距离  \n1\\. 选择一个未被标记的、且 `graph[k]` 的值是最小的顶点 $k$  \n2\\. 标记顶点 $k$，即 `vis[k]=true`  \n3\\. 以 $k$ 为中间点，修改出发点 $v_0$ 到其他未被标记的顶点的 $j$ 的距离值 `graph[j]`\n3. 将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2  \n1\\. 在集合 2 中找一个到出发点距离最近的顶点 $k$： $min\\{dis[k]\\}$  \n2\\. 把顶点 $k$ 加到集合 1 中，同时检查集合 2 中的剩余顶点 $j$ 的 `dis[j]` 是否经过 $k$ 后变短，如果变短修改 `dis[j]`  \n`if(dis[k]+wait[k][j]<dis[j])  dis[j]=dis[k]+wait[k][j]`  \n3\\. 重复步骤 3.1 ，直至集合 2 空为止\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)（但是弱化版）\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint pos=s;\n\twhile(vis[pos]==0)\n\t{\n\t\tint minn=INF;\n\t\tvis[pos]=true;\n\t\tfor(int i=head[pos];i!=0;i=edge[i].nxt)\n\t\t\tif(!vis[edge[i].to]&&ans[edge[i].to]>ans[pos]+edge[i].weight)\n\t\t\t\tans[edge[i].to]=ans[pos]+edge[i].weight;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(ans[i]<minn&&vis[i]==0)\n\t\t\t{\n\t\t\t\tminn=ans[i];\n\t\t\t\tpos=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 `dis[]` 中的最小值，所以我们可以用……\n## 堆优化\n堆是一种可以在 $O(log(n))$ 的时间插入数据，$O(1)$ 的时间删除和查找当前极值（最大或最小值）  \n那么原来求最小值的 $O(n)$ 的算法，可以改为使用堆来求最小值，时间复杂度降到 $O(log(n))$ ，整体复杂度降到 $O(n\\ log(n))$  \n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）\n\n对于 Dijkstra 的堆优化有两种方法:\n1. 重载运算符\n2. 两元组\n## 例题 - [Luogu P4779](https://luogu.com.cn/problem/P4779)（但是标准版）\n别想把 P3371 的代码交上去，全部 TLE\n### Solution-1 重载运算符\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=0x3f;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nstruct Priority\n{\n    int ans,id;\n    bool operator <(const Priority &x)const{return x.ans<ans;}\n};\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n    return;\n}\nvoid init()\n{\n\tmemset(ans,INF,sizeof(ans));\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tinit();\n\tcin>>m>>n>>s;\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint u;\n    priority_queue<Priority> q;\n    q.push((Priority){0,s});\n\twhile(!q.empty())\n    {\n        Priority tmp=q.top();\n        q.pop();\n        u=tmp.id;\n        if(!vis[u])\n        {\n            vis[u]=true;\n            for(int i=head[u];i;i=edge[i].nxt)\n            {\n                int v=edge[i].to;\n                if(ans[v]>ans[u]+edge[i].weight)\n                {\n                    ans[v]=ans[u]+edge[i].weight;\n                    if(!vis[v])  q.push((Priority){ans[v],v});\n                }\n            }\n        }\n    }\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n    return 0;\n}\n```\n### Solution-2 两元组\n```cpp\n#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tpriority_queue<pii,vector<pii>,greater<pii> >q;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tans[s]=0;\n\tq.push(pii{0,s});\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tpii x=q.top();\n\t\tq.pop();\n\t\tif(vis[x.second])  continue;\n\t\tu=x.second;\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=edge[i].nxt)\n\t\t{\n\t\t\tif(ans[edge[i].to]>ans[u]+edge[i].weight)\n\t\t\t{\n\t\t\t\tans[edge[i].to]=ans[u]+edge[i].weight;\n\t\t\t\tq.push(pii(ans[edge[i].to],edge[i].to));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n\n---\n# SPFA\nSPFA 是 Bellman-Ford 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n## 基本信息\n定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n\nSPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。\n\n时间复杂度：$O(kE)$，$E$ 是边数，$k$ 是常数，平均值是 $2$\n## 算法步骤\n1. 初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改\n2. 若某个相邻的顶点修改成功，则将其入队\n3. 队列为空时，算法结束\n## 实现方法\n1. 建立一个队列，并且将出发点入列，用 `dis[i]` 记录出发点到其他所有点的最短路径\n2. 执行松弛操作，一次用队列里有的点 $u$ 去更新所有后继节点 $v_i$ 的最短路，如果 $v_i$ 被更新成功且不在队列中，则把 $v_i$ 加入队列，重复执行直到队列为空\n3. 节点可能多次被更新，可以多次进入队列  \n`if(dis[u]+w<dis[v])  d[v]=d[u]+w;`\n4. 如果 $V$ 被更新了且队列中不存在，再一次进入队列\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=5e5+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[2*LEN];\nint cnt=0,head[LEN],dis[LEN];\nbool vis[LEN];\nint n,m,start;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n\treturn;\n}\nvoid SPFA()\n{\n\tqueue<int> q;\n\tdis[start]=0;\n\tq.push(start);\n\tvis[start]=true;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tvis[now]=false;\n\t\tfor(int i=head[now];i;i=edge[i].nxt)\n\t\t{\n\t\t\tint to=edge[i].to;\n\t\t\tif(edge[i].weight+dis[now]<=dis[to])\n\t\t\t{\n\t\t\t\tdis[to]=edge[i].weight+dis[now];\n\t\t\t\tif(!vis[to])\n\t\t\t\t{\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  dis[i]=INF;\n\tmemset(head,0,sizeof(head));\n\treturn;\n}\nsigned main()\n{\n\tcin>>n>>m>>start;\n\tinit();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tSPFA();\n\tfor(int i=1;i<=n;i++)  cout<<dis[i]<<' ';\n\treturn 0;\n}\n```\n有些考试会用数据卡掉 SPFA 导致 TLE，比如 [Luogu P4779](https://luogu.com.cn/problem/P4779) 会导致 SPFA 算法在 [\\#1,2,3,5,6 TLE](https://luogu.com.cn/record/222522444)  \nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别\n\n---\n# 总结\nFloyd 最简单，多源最短路大暴力，$O(n^3)$ 复杂度卡死你  \nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 $O(n\\ log(n))$  \nSPFA 易理解，和 BFS 很类似，[某些题目](https://luogu.com.cn/problem/P4768) 会卡掉，慎重选择需技巧\n\n被迫回去看链式前向星的笔记了 :\\(","source":"_posts/最短路.md","raw":"---\ntitle: 图论 - 最短路\ndate: 2025-07-10 20:01:47\nbanner: https://imghub.ed-builder.top/file/sTEM0QcE.png\ncover: https://imghub.ed-builder.top/file/sTEM0QcE.png\ntags: ['图论', '最短路', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 图论 - 最短路\n    topic: 多种算法，多种应用场景\nkatex: true\nauthor: ED_Builder\n---\n\n本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA\n\n<!-- more -->\n\n# Floyd\n## 基本信息\n定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 $a$ 到顶点 $b$）之间的路程变短，只能引入第三个点（顶点 $k$），并通过这个顶点 $k$ 中转，即 `a->k->b`，才可能缩短原来从顶点 $a$ 到顶点 $b$ 的路程。\n\n原理：三重循环枚举中转点 `k`，状态转移方程：`dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])`\n\n时间复杂度：$O(n^3)$\n## 算法步骤\n由于在图中 **没有负环** 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。\n## 例题 - [Luogu B3647](https://luogu.com.cn/problem/B3647)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN],n,m;\nsigned main()\n{\n    cin>>n>>m;\n    memset(graph,INF,sizeof(graph));//初始化为任何顶点都没有相连\n    for(int i=1;i<=n;i++)  graph[i][i]=0;//自己到自己为 0\n    while(m--)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph[u][v]=graph[v][u]=min(graph[u][v],w);//最小值\n    }\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n                //暴力查找第三点 k，以及通过边权求最小值\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(graph[i][j]==INF)  cout<<0<<' ';//没有边相连\n            else  cout<<graph[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n~~上面这玩意只有 80pts~~\n\n---\n# Dijkstra\n## 基本信息\n定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。  \n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 **所有的边权全部非负**。\n\n原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。\n\n时间复杂度：$O(n^2)$\n## 算法步骤\n1. 初始化 `graph[v0]=0` ，**出发点** 到其他顶点的距离 `graph[i]=INF`\n2. 经过 $n$ 次下面的操作，最后得到 $v_0$ 到 $n$ 个顶点的最短距离  \n1\\. 选择一个未被标记的、且 `graph[k]` 的值是最小的顶点 $k$  \n2\\. 标记顶点 $k$，即 `vis[k]=true`  \n3\\. 以 $k$ 为中间点，修改出发点 $v_0$ 到其他未被标记的顶点的 $j$ 的距离值 `graph[j]`\n3. 将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2  \n1\\. 在集合 2 中找一个到出发点距离最近的顶点 $k$： $min\\{dis[k]\\}$  \n2\\. 把顶点 $k$ 加到集合 1 中，同时检查集合 2 中的剩余顶点 $j$ 的 `dis[j]` 是否经过 $k$ 后变短，如果变短修改 `dis[j]`  \n`if(dis[k]+wait[k][j]<dis[j])  dis[j]=dis[k]+wait[k][j]`  \n3\\. 重复步骤 3.1 ，直至集合 2 空为止\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)（但是弱化版）\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint pos=s;\n\twhile(vis[pos]==0)\n\t{\n\t\tint minn=INF;\n\t\tvis[pos]=true;\n\t\tfor(int i=head[pos];i!=0;i=edge[i].nxt)\n\t\t\tif(!vis[edge[i].to]&&ans[edge[i].to]>ans[pos]+edge[i].weight)\n\t\t\t\tans[edge[i].to]=ans[pos]+edge[i].weight;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(ans[i]<minn&&vis[i]==0)\n\t\t\t{\n\t\t\t\tminn=ans[i];\n\t\t\t\tpos=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 `dis[]` 中的最小值，所以我们可以用……\n## 堆优化\n堆是一种可以在 $O(log(n))$ 的时间插入数据，$O(1)$ 的时间删除和查找当前极值（最大或最小值）  \n那么原来求最小值的 $O(n)$ 的算法，可以改为使用堆来求最小值，时间复杂度降到 $O(log(n))$ ，整体复杂度降到 $O(n\\ log(n))$  \n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）\n\n对于 Dijkstra 的堆优化有两种方法:\n1. 重载运算符\n2. 两元组\n## 例题 - [Luogu P4779](https://luogu.com.cn/problem/P4779)（但是标准版）\n别想把 P3371 的代码交上去，全部 TLE\n### Solution-1 重载运算符\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=0x3f;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nstruct Priority\n{\n    int ans,id;\n    bool operator <(const Priority &x)const{return x.ans<ans;}\n};\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n    return;\n}\nvoid init()\n{\n\tmemset(ans,INF,sizeof(ans));\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tinit();\n\tcin>>m>>n>>s;\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint u;\n    priority_queue<Priority> q;\n    q.push((Priority){0,s});\n\twhile(!q.empty())\n    {\n        Priority tmp=q.top();\n        q.pop();\n        u=tmp.id;\n        if(!vis[u])\n        {\n            vis[u]=true;\n            for(int i=head[u];i;i=edge[i].nxt)\n            {\n                int v=edge[i].to;\n                if(ans[v]>ans[u]+edge[i].weight)\n                {\n                    ans[v]=ans[u]+edge[i].weight;\n                    if(!vis[v])  q.push((Priority){ans[v],v});\n                }\n            }\n        }\n    }\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n    return 0;\n}\n```\n### Solution-2 两元组\n```cpp\n#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tpriority_queue<pii,vector<pii>,greater<pii> >q;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tans[s]=0;\n\tq.push(pii{0,s});\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tpii x=q.top();\n\t\tq.pop();\n\t\tif(vis[x.second])  continue;\n\t\tu=x.second;\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=edge[i].nxt)\n\t\t{\n\t\t\tif(ans[edge[i].to]>ans[u]+edge[i].weight)\n\t\t\t{\n\t\t\t\tans[edge[i].to]=ans[u]+edge[i].weight;\n\t\t\t\tq.push(pii(ans[edge[i].to],edge[i].to));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n\n---\n# SPFA\nSPFA 是 Bellman-Ford 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n## 基本信息\n定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n\nSPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。\n\n时间复杂度：$O(kE)$，$E$ 是边数，$k$ 是常数，平均值是 $2$\n## 算法步骤\n1. 初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改\n2. 若某个相邻的顶点修改成功，则将其入队\n3. 队列为空时，算法结束\n## 实现方法\n1. 建立一个队列，并且将出发点入列，用 `dis[i]` 记录出发点到其他所有点的最短路径\n2. 执行松弛操作，一次用队列里有的点 $u$ 去更新所有后继节点 $v_i$ 的最短路，如果 $v_i$ 被更新成功且不在队列中，则把 $v_i$ 加入队列，重复执行直到队列为空\n3. 节点可能多次被更新，可以多次进入队列  \n`if(dis[u]+w<dis[v])  d[v]=d[u]+w;`\n4. 如果 $V$ 被更新了且队列中不存在，再一次进入队列\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=5e5+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[2*LEN];\nint cnt=0,head[LEN],dis[LEN];\nbool vis[LEN];\nint n,m,start;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n\treturn;\n}\nvoid SPFA()\n{\n\tqueue<int> q;\n\tdis[start]=0;\n\tq.push(start);\n\tvis[start]=true;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tvis[now]=false;\n\t\tfor(int i=head[now];i;i=edge[i].nxt)\n\t\t{\n\t\t\tint to=edge[i].to;\n\t\t\tif(edge[i].weight+dis[now]<=dis[to])\n\t\t\t{\n\t\t\t\tdis[to]=edge[i].weight+dis[now];\n\t\t\t\tif(!vis[to])\n\t\t\t\t{\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  dis[i]=INF;\n\tmemset(head,0,sizeof(head));\n\treturn;\n}\nsigned main()\n{\n\tcin>>n>>m>>start;\n\tinit();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tSPFA();\n\tfor(int i=1;i<=n;i++)  cout<<dis[i]<<' ';\n\treturn 0;\n}\n```\n有些考试会用数据卡掉 SPFA 导致 TLE，比如 [Luogu P4779](https://luogu.com.cn/problem/P4779) 会导致 SPFA 算法在 [\\#1,2,3,5,6 TLE](https://luogu.com.cn/record/222522444)  \nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别\n\n---\n# 总结\nFloyd 最简单，多源最短路大暴力，$O(n^3)$ 复杂度卡死你  \nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 $O(n\\ log(n))$  \nSPFA 易理解，和 BFS 很类似，[某些题目](https://luogu.com.cn/problem/P4768) 会卡掉，慎重选择需技巧\n\n被迫回去看链式前向星的笔记了 :\\(","slug":"最短路","published":1,"updated":"2025-08-25T04:41:24.453Z","_id":"cmebjcsxm000ec4boegr159u9","comments":1,"layout":"post","photos":[],"content":"<p>本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA</p>\n<span id=\"more\"></span>\n<h1 id=\"floyd\"><a class=\"markdownIt-Anchor\" href=\"#floyd\"></a> Floyd</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>）之间的路程变短，只能引入第三个点（顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>），并通过这个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 中转，即 <code>a-&gt;k-&gt;b</code>，才可能缩短原来从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 的路程。</p>\n<p>原理：三重循环枚举中转点 <code>k</code>，状态转移方程：<code>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</code></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤\"></a> 算法步骤</h2>\n<p>由于在图中 <strong>没有负环</strong> 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。</p>\n<h2 id=\"例题-luogu-b3647\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-b3647\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/B3647\">Luogu B3647</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN],n,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(graph,INF,<span class=\"built_in\">sizeof</span>(graph));<span class=\"comment\">//初始化为任何顶点都没有相连</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  graph[i][i]=<span class=\"number\">0</span>;<span class=\"comment\">//自己到自己为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        graph[u][v]=graph[v][u]=<span class=\"built_in\">min</span>(graph[u][v],w);<span class=\"comment\">//最小值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">                graph[i][j]=<span class=\"built_in\">min</span>(graph[i][j],graph[i][k]+graph[k][j]);</span><br><span class=\"line\">                <span class=\"comment\">//暴力查找第三点 k，以及通过边权求最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(graph[i][j]==INF)  cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;<span class=\"comment\">//没有边相连</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  cout&lt;&lt;graph[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><s>上面这玩意只有 80pts</s></p>\n<hr />\n<h1 id=\"dijkstra\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra\"></a> Dijkstra</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<p>定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。<br />\n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 <strong>所有的边权全部非负</strong>。</p>\n<p>原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤-2\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-2\"></a> 算法步骤</h2>\n<ol>\n<li>初始化 <code>graph[v0]=0</code> ，<strong>出发点</strong> 到其他顶点的距离 <code>graph[i]=INF</code></li>\n<li>经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次下面的操作，最后得到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最短距离<br />\n1. 选择一个未被标记的、且 <code>graph[k]</code> 的值是最小的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><br />\n2. 标记顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，即 <code>vis[k]=true</code><br />\n3. 以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为中间点，修改出发点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到其他未被标记的顶点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的距离值 <code>graph[j]</code></li>\n<li>将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2<br />\n1. 在集合 2 中找一个到出发点距离最近的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">min\\{dis[k]\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span><br />\n2. 把顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 加到集合 1 中，同时检查集合 2 中的剩余顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的 <code>dis[j]</code> 是否经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 后变短，如果变短修改 <code>dis[j]</code><br />\n<code>if(dis[k]+wait[k][j]&lt;dis[j])  dis[j]=dis[k]+wait[k][j]</code><br />\n3. 重复步骤 3.1 ，直至集合 2 空为止</li>\n</ol>\n<h2 id=\"例题-luogu-p3371但是弱化版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371但是弱化版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a>（但是弱化版）</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos=s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(vis[pos]==<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minn=INF;</span><br><span class=\"line\">        vis[pos]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[pos];i!=<span class=\"number\">0</span>;i=edge[i].nxt)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].weight)</span><br><span class=\"line\">                ans[edge[i].to]=ans[pos]+edge[i].weight;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                minn=ans[i];</span><br><span class=\"line\">                pos=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 <code>dis[]</code> 中的最小值，所以我们可以用……</p>\n<h2 id=\"堆优化\"><a class=\"markdownIt-Anchor\" href=\"#堆优化\"></a> 堆优化</h2>\n<p>堆是一种可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> 的时间插入数据，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间删除和查找当前极值（最大或最小值）<br />\n那么原来求最小值的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法，可以改为使用堆来求最小值，时间复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> ，整体复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）</p>\n<p>对于 Dijkstra 的堆优化有两种方法:</p>\n<ol>\n<li>重载运算符</li>\n<li>两元组</li>\n</ol>\n<h2 id=\"例题-luogu-p4779但是标准版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p4779但是标准版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a>（但是标准版）</h2>\n<p>别想把 P3371 的代码交上去，全部 TLE</p>\n<h3 id=\"solution-1-重载运算符\"><a class=\"markdownIt-Anchor\" href=\"#solution-1-重载运算符\"></a> Solution-1 重载运算符</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Priority</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans,id;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"type\">const</span> Priority &amp;x)<span class=\"type\">const</span>&#123;<span class=\"keyword\">return</span> x.ans&lt;ans;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(ans,INF,<span class=\"built_in\">sizeof</span>(ans));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    priority_queue&lt;Priority&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Priority)&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Priority tmp=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        u=tmp.id;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[u])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> v=edge[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans[v]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans[v]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!vis[v])  q.<span class=\"built_in\">push</span>((Priority)&#123;ans[v],v&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"solution-2-两元组\"><a class=\"markdownIt-Anchor\" href=\"#solution-2-两元组\"></a> Solution-2 两元组</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pii pair<span class=\"string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(pii&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pii x=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[x.second])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        u=x.second;</span><br><span class=\"line\">        vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[edge[i].to]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans[edge[i].to]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(<span class=\"built_in\">pii</span>(ans[edge[i].to],edge[i].to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"spfa\"><a class=\"markdownIt-Anchor\" href=\"#spfa\"></a> SPFA</h1>\n<p>SPFA 是 Bellman-Ford 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<h2 id=\"基本信息-3\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-3\"></a> 基本信息</h2>\n<p>定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<p>SPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(kE)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 是边数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 是常数，平均值是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span></p>\n<h2 id=\"算法步骤-3\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-3\"></a> 算法步骤</h2>\n<ol>\n<li>初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改</li>\n<li>若某个相邻的顶点修改成功，则将其入队</li>\n<li>队列为空时，算法结束</li>\n</ol>\n<h2 id=\"实现方法\"><a class=\"markdownIt-Anchor\" href=\"#实现方法\"></a> 实现方法</h2>\n<ol>\n<li>建立一个队列，并且将出发点入列，用 <code>dis[i]</code> 记录出发点到其他所有点的最短路径</li>\n<li>执行松弛操作，一次用队列里有的点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 去更新所有后继节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的最短路，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 被更新成功且不在队列中，则把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加入队列，重复执行直到队列为空</li>\n<li>节点可能多次被更新，可以多次进入队列<br />\n<code>if(dis[u]+w&lt;dis[v])  d[v]=d[u]+w;</code></li>\n<li>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 被更新了且队列中不存在，再一次进入队列</li>\n</ol>\n<h2 id=\"例题-luogu-p3371\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">5e5</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[<span class=\"number\">2</span>*LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt=<span class=\"number\">0</span>,head[LEN],dis[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,start;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    dis[start]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    vis[start]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> now=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        vis[now]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[now];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> to=edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edge[i].weight+dis[now]&lt;=dis[to])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[to]=edge[i].weight+dis[now];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(to);</span><br><span class=\"line\">                    vis[to]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  dis[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;start;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">SPFA</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;dis[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有些考试会用数据卡掉 SPFA 导致 TLE，比如 <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a> 会导致 SPFA 算法在 <a href=\"https://luogu.com.cn/record/222522444\">#1,2,3,5,6 TLE</a><br />\nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别</p>\n<hr />\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h1>\n<p>Floyd 最简单，多源最短路大暴力，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 复杂度卡死你<br />\nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\nSPFA 易理解，和 BFS 很类似，<a href=\"https://luogu.com.cn/problem/P4768\">某些题目</a> 会卡掉，慎重选择需技巧</p>\n<p>被迫回去看链式前向星的笔记了 :(</p>\n","excerpt":"<p>本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA</p>","more":"<h1 id=\"floyd\"><a class=\"markdownIt-Anchor\" href=\"#floyd\"></a> Floyd</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>）之间的路程变短，只能引入第三个点（顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>），并通过这个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 中转，即 <code>a-&gt;k-&gt;b</code>，才可能缩短原来从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 的路程。</p>\n<p>原理：三重循环枚举中转点 <code>k</code>，状态转移方程：<code>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</code></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤\"></a> 算法步骤</h2>\n<p>由于在图中 <strong>没有负环</strong> 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。</p>\n<h2 id=\"例题-luogu-b3647\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-b3647\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/B3647\">Luogu B3647</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN],n,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(graph,INF,<span class=\"built_in\">sizeof</span>(graph));<span class=\"comment\">//初始化为任何顶点都没有相连</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  graph[i][i]=<span class=\"number\">0</span>;<span class=\"comment\">//自己到自己为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        graph[u][v]=graph[v][u]=<span class=\"built_in\">min</span>(graph[u][v],w);<span class=\"comment\">//最小值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">                graph[i][j]=<span class=\"built_in\">min</span>(graph[i][j],graph[i][k]+graph[k][j]);</span><br><span class=\"line\">                <span class=\"comment\">//暴力查找第三点 k，以及通过边权求最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(graph[i][j]==INF)  cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;<span class=\"comment\">//没有边相连</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  cout&lt;&lt;graph[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><s>上面这玩意只有 80pts</s></p>\n<hr />\n<h1 id=\"dijkstra\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra\"></a> Dijkstra</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<p>定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。<br />\n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 <strong>所有的边权全部非负</strong>。</p>\n<p>原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤-2\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-2\"></a> 算法步骤</h2>\n<ol>\n<li>初始化 <code>graph[v0]=0</code> ，<strong>出发点</strong> 到其他顶点的距离 <code>graph[i]=INF</code></li>\n<li>经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次下面的操作，最后得到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最短距离<br />\n1. 选择一个未被标记的、且 <code>graph[k]</code> 的值是最小的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><br />\n2. 标记顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，即 <code>vis[k]=true</code><br />\n3. 以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为中间点，修改出发点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到其他未被标记的顶点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的距离值 <code>graph[j]</code></li>\n<li>将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2<br />\n1. 在集合 2 中找一个到出发点距离最近的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">min\\{dis[k]\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span><br />\n2. 把顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 加到集合 1 中，同时检查集合 2 中的剩余顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的 <code>dis[j]</code> 是否经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 后变短，如果变短修改 <code>dis[j]</code><br />\n<code>if(dis[k]+wait[k][j]&lt;dis[j])  dis[j]=dis[k]+wait[k][j]</code><br />\n3. 重复步骤 3.1 ，直至集合 2 空为止</li>\n</ol>\n<h2 id=\"例题-luogu-p3371但是弱化版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371但是弱化版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a>（但是弱化版）</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos=s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(vis[pos]==<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minn=INF;</span><br><span class=\"line\">        vis[pos]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[pos];i!=<span class=\"number\">0</span>;i=edge[i].nxt)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].weight)</span><br><span class=\"line\">                ans[edge[i].to]=ans[pos]+edge[i].weight;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                minn=ans[i];</span><br><span class=\"line\">                pos=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 <code>dis[]</code> 中的最小值，所以我们可以用……</p>\n<h2 id=\"堆优化\"><a class=\"markdownIt-Anchor\" href=\"#堆优化\"></a> 堆优化</h2>\n<p>堆是一种可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> 的时间插入数据，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间删除和查找当前极值（最大或最小值）<br />\n那么原来求最小值的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法，可以改为使用堆来求最小值，时间复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> ，整体复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）</p>\n<p>对于 Dijkstra 的堆优化有两种方法:</p>\n<ol>\n<li>重载运算符</li>\n<li>两元组</li>\n</ol>\n<h2 id=\"例题-luogu-p4779但是标准版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p4779但是标准版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a>（但是标准版）</h2>\n<p>别想把 P3371 的代码交上去，全部 TLE</p>\n<h3 id=\"solution-1-重载运算符\"><a class=\"markdownIt-Anchor\" href=\"#solution-1-重载运算符\"></a> Solution-1 重载运算符</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Priority</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans,id;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"type\">const</span> Priority &amp;x)<span class=\"type\">const</span>&#123;<span class=\"keyword\">return</span> x.ans&lt;ans;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(ans,INF,<span class=\"built_in\">sizeof</span>(ans));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    priority_queue&lt;Priority&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Priority)&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Priority tmp=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        u=tmp.id;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[u])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> v=edge[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans[v]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans[v]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!vis[v])  q.<span class=\"built_in\">push</span>((Priority)&#123;ans[v],v&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"solution-2-两元组\"><a class=\"markdownIt-Anchor\" href=\"#solution-2-两元组\"></a> Solution-2 两元组</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pii pair<span class=\"string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(pii&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pii x=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[x.second])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        u=x.second;</span><br><span class=\"line\">        vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[edge[i].to]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans[edge[i].to]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(<span class=\"built_in\">pii</span>(ans[edge[i].to],edge[i].to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"spfa\"><a class=\"markdownIt-Anchor\" href=\"#spfa\"></a> SPFA</h1>\n<p>SPFA 是 Bellman-Ford 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<h2 id=\"基本信息-3\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-3\"></a> 基本信息</h2>\n<p>定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<p>SPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(kE)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 是边数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 是常数，平均值是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span></p>\n<h2 id=\"算法步骤-3\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-3\"></a> 算法步骤</h2>\n<ol>\n<li>初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改</li>\n<li>若某个相邻的顶点修改成功，则将其入队</li>\n<li>队列为空时，算法结束</li>\n</ol>\n<h2 id=\"实现方法\"><a class=\"markdownIt-Anchor\" href=\"#实现方法\"></a> 实现方法</h2>\n<ol>\n<li>建立一个队列，并且将出发点入列，用 <code>dis[i]</code> 记录出发点到其他所有点的最短路径</li>\n<li>执行松弛操作，一次用队列里有的点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 去更新所有后继节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的最短路，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 被更新成功且不在队列中，则把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加入队列，重复执行直到队列为空</li>\n<li>节点可能多次被更新，可以多次进入队列<br />\n<code>if(dis[u]+w&lt;dis[v])  d[v]=d[u]+w;</code></li>\n<li>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 被更新了且队列中不存在，再一次进入队列</li>\n</ol>\n<h2 id=\"例题-luogu-p3371\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">5e5</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[<span class=\"number\">2</span>*LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt=<span class=\"number\">0</span>,head[LEN],dis[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,start;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    dis[start]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    vis[start]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> now=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        vis[now]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[now];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> to=edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edge[i].weight+dis[now]&lt;=dis[to])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[to]=edge[i].weight+dis[now];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(to);</span><br><span class=\"line\">                    vis[to]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  dis[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;start;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">SPFA</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;dis[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有些考试会用数据卡掉 SPFA 导致 TLE，比如 <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a> 会导致 SPFA 算法在 <a href=\"https://luogu.com.cn/record/222522444\">#1,2,3,5,6 TLE</a><br />\nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别</p>\n<hr />\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h1>\n<p>Floyd 最简单，多源最短路大暴力，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 复杂度卡死你<br />\nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\nSPFA 易理解，和 BFS 很类似，<a href=\"https://luogu.com.cn/problem/P4768\">某些题目</a> 会卡掉，慎重选择需技巧</p>\n<p>被迫回去看链式前向星的笔记了 :(</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cmebjcswz0009c4bo7syg4cxf","category_id":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsy9000oc4boeucxcbjj"},{"post_id":"cmebjcswz0009c4bo7syg4cxf","category_id":"cmebjcsxy000ic4bodphwgh5k","_id":"cmebjcsye000sc4bo5tbofux3"},{"post_id":"cmebjcsx9000bc4bo54w870s6","category_id":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsyl000xc4bo6rzk2qcb"},{"post_id":"cmebjcsx9000bc4bo54w870s6","category_id":"cmebjcsxy000ic4bodphwgh5k","_id":"cmebjcsyo0010c4bo9395cwlw"},{"post_id":"cmebjcsxm000ec4boegr159u9","category_id":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsyp0012c4bo4w30hd0g"},{"post_id":"cmebjcsxm000ec4boegr159u9","category_id":"cmebjcsxy000ic4bodphwgh5k","_id":"cmebjcsyq0013c4bo8hyod8oe"},{"post_id":"cmebjcsvv0003c4boe06ybo0o","category_id":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsyv0016c4boaq8xd0tp"},{"post_id":"cmebjcsvv0003c4boe06ybo0o","category_id":"cmebjcsxy000ic4bodphwgh5k","_id":"cmebjcsyv0017c4boh050acha"},{"post_id":"cmebjcswo0007c4bo1z1ifvr7","category_id":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsz0001ac4boa4g3cm6n"},{"post_id":"cmebjcswo0007c4bo1z1ifvr7","category_id":"cmebjcsxy000ic4bodphwgh5k","_id":"cmebjcsz1001cc4bo2ultf2f3"},{"post_id":"cmebjcsv40001c4bo0ak6hy3c","category_id":"cmebjcsw60004c4bobabm89ps","_id":"cmebjcsz3001fc4bohjmn1sta"},{"post_id":"cmebjcsv40001c4bo0ak6hy3c","category_id":"cmebjcsy4000lc4bocslr4pjk","_id":"cmebjcsz5001gc4bo0im39feg"},{"post_id":"cmebjcsv40001c4bo0ak6hy3c","category_id":"cmebjcsys0015c4bogf1s3zcz","_id":"cmebjcsz8001ic4bod0zbblsj"}],"PostTag":[{"post_id":"cmebjcsv40001c4bo0ak6hy3c","tag_id":"cmebjcswf0005c4bo024b6xbs","_id":"cmebjcsxx000hc4bog9nwf5nq"},{"post_id":"cmebjcsv40001c4bo0ak6hy3c","tag_id":"cmebjcsxe000dc4bohx6m71tm","_id":"cmebjcsy0000jc4bo9ikkcx2k"},{"post_id":"cmebjcsvv0003c4boe06ybo0o","tag_id":"cmebjcswf0005c4bo024b6xbs","_id":"cmebjcsy8000nc4bo20e84swy"},{"post_id":"cmebjcsvv0003c4boe06ybo0o","tag_id":"cmebjcsy1000kc4boe4n95fj5","_id":"cmebjcsya000pc4bo01sy1crb"},{"post_id":"cmebjcswo0007c4bo1z1ifvr7","tag_id":"cmebjcsy7000mc4bo947r33q5","_id":"cmebjcsyj000vc4boaxya12x1"},{"post_id":"cmebjcswo0007c4bo1z1ifvr7","tag_id":"cmebjcsyc000rc4bo1r2e7q08","_id":"cmebjcsym000yc4bo15j4ftv9"},{"post_id":"cmebjcswz0009c4bo7syg4cxf","tag_id":"cmebjcsyi000uc4bo4sqcemao","_id":"cmebjcsyz0019c4bo7aq075x4"},{"post_id":"cmebjcswz0009c4bo7syg4cxf","tag_id":"cmebjcsym000zc4bobfeufk5z","_id":"cmebjcsz1001bc4bo7g5jbzso"},{"post_id":"cmebjcswz0009c4bo7syg4cxf","tag_id":"cmebjcsyc000rc4bo1r2e7q08","_id":"cmebjcsz3001ec4boh5vbgiup"},{"post_id":"cmebjcsx9000bc4bo54w870s6","tag_id":"cmebjcsyi000uc4bo4sqcemao","_id":"cmebjcszc001kc4boc0o756p8"},{"post_id":"cmebjcsx9000bc4bo54w870s6","tag_id":"cmebjcsz1001dc4bo11ddgo8n","_id":"cmebjcszd001lc4bo0wfsbs3d"},{"post_id":"cmebjcsx9000bc4bo54w870s6","tag_id":"cmebjcsyc000rc4bo1r2e7q08","_id":"cmebjcsze001nc4bo0eb28aoj"},{"post_id":"cmebjcsxm000ec4boegr159u9","tag_id":"cmebjcsyi000uc4bo4sqcemao","_id":"cmebjcszg001pc4bo2uby81z4"},{"post_id":"cmebjcsxm000ec4boegr159u9","tag_id":"cmebjcszd001mc4boh393hp6y","_id":"cmebjcszh001qc4bof147clrs"},{"post_id":"cmebjcsxm000ec4boegr159u9","tag_id":"cmebjcsyc000rc4bo1r2e7q08","_id":"cmebjcszh001rc4bo0fjn70fq"}],"Tag":[{"name":"OI","_id":"cmebjcswf0005c4bo024b6xbs"},{"name":"CSP-J","_id":"cmebjcsxe000dc4bohx6m71tm"},{"name":"模板","_id":"cmebjcsy1000kc4boe4n95fj5"},{"name":"搜索","_id":"cmebjcsy7000mc4bo947r33q5"},{"name":"算法","_id":"cmebjcsyc000rc4bo1r2e7q08"},{"name":"图论","_id":"cmebjcsyi000uc4bo4sqcemao"},{"name":"最小生成树","_id":"cmebjcsym000zc4bobfeufk5z"},{"name":"存储","_id":"cmebjcsz1001dc4bo11ddgo8n"},{"name":"最短路","_id":"cmebjcszd001mc4boh393hp6y"}]}}